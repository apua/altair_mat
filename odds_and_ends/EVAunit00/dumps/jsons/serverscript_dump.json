[
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:31.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:31.000Z", 
    "description": "This script is needed if you want to install Windows 2003 onto an alternate drive letter other than the default \"C\" drive.  It creates a manifest.inf file windows setup will use that maps the desired drive letter as present in the winpe environment to that same driver letter when Windows first boots.  This is done via disk ID and volume label.\n\nUsage:\n\nchange_windows_drive_letter.vbs [LETTER]\n\nwhere LETTER is the single character drive letter where you want Windows to be installed. By default this will be either the value of the SystemDrive custom attribute or default to \"C\", in which case nothing needs to be done. It is recommended that you do NOT provide any parameters to this script and instead specify the SystemDrive custom attribute on your target server because an alternate drive letter must be referenced by several steps in the OS Build Plan in order to succeed.\n\nPrerequisites:\n - Script needs to be run as part of a build plan.\n - Target drive letter must correspond to a mounted, formatted, writable volume.\n - Target server runs a Windows PE maintenance OS.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1180001", 
    "modified": "2014-03-10T21:37:31.000Z", 
    "name": "Change Windows Drive Letter", 
    "source": "' This script obtains the volume id and disk serial numbers that correspond\r\n' to a logical drive that you provide on the commandline.\r\n' It creates a file <drive>:\\$WIN_NT$.~BT\\migrate.inf\r\n' That file contains the syntax windows setup needs to ensure\r\n' that the desired drive letter is used instead of the default \"C\"\r\n' Does not work with reparse/mountpoints\r\n' Don't know if it will work with dynamic disks\r\n'\r\nWscript.Timeout = 75\r\n'On Error Resume Next\r\n\r\nPrivate Function StrPad(Unpadded, Length, Padding)\r\n    StrPad = String((Length-Len(Unpadded)), Padding) & Unpadded\r\nEnd Function\r\n\r\nPrivate Function SigOrder(unordered)\r\n\tSigOrder = LCase(right(unordered,2) & \",\" & left(right(unordered,4),2) & _\r\n        \",\" & right(left(unordered,4),2) & \",\" & left(unordered,2))\r\nEnd Function\r\n\r\nPrivate Function StartSectorOrder(unordered)\r\n\tStartSectorOrder = right(unordered, 2) & \",\" & left(right(unordered,4),2) &_\r\n        \",\" & left(right(unordered,6),2) & \",\" & left(right(unordered,8),2) &_\r\n        \",\" & left(right(unordered,10),2) & \",\" & left(right(unordered,12),2)\r\n\tStartSectorOrder = LCase(StartSectorOrder)\r\nEnd Function\r\n\r\nPrivate Function StartPartition(offsetsectors)\r\n\thexstring = StrPad(Hex(offsetsectors*2), 12, \"0\")\r\n    StartPartition = hexstring\r\nEnd Function\r\n\r\nIf WScript.Arguments.Count > 0 Then\r\n\tdrive = Left(WScript.Arguments.Item(0), 1) & \":\"\r\nElse\r\n\tdrive = \"@SystemDrive:C@:\"\r\nEnd If\r\n\r\nIf UCase(drive) = \"C:\" Then\r\n\tWScript.echo \"SystemDrive is configured for the default of \" & drive & \". No special configuration required. Exiting without any changes.\"\r\n\tWScript.Quit(0)\r\nEnd If\r\n\r\nSet FSO = CreateObject(\"Scripting.FileSystemObject\")\r\nIf Not FSO.FolderExists(drive & \"\\\") Then\r\n\tWScript.Stderr.Write(\"Drive letter \" & drive & \" does not exist.\" & VbCrLf)\r\n\tWScript.Quit(5)\r\nEnd If\r\ndiskSignatureHex = \"\"\r\nmigrateData = \"\"\r\nregistrySignature = \"\"\r\nvolKey = \"\"\r\n\r\nSet objWMIService = GetObject(\"winmgmts:\\\\.\\root\\cimv2\")\r\nSet colDiskDrives = objWMIService.ExecQuery(\"SELECT * FROM Win32_DiskDrive\")\r\nSet objVolumes = objWMIService.InstancesOf(\"Win32_Volume\",48)\r\n\r\nFor Each objDrive In colDiskDrives\r\n   strDeviceID = Replace(objDrive.DeviceID, \"\\\", \"\\\\\")\r\n   Set colPartitions = objWMIService.ExecQuery _\r\n      (\"ASSOCIATORS OF {Win32_DiskDrive.DeviceID=\"\"\" & _\r\n         strDeviceID & \"\"\"} WHERE AssocClass = \" & _\r\n            \"Win32_DiskDriveToDiskPartition\")\r\n \r\n   For Each objPartition In colPartitions\r\n      Set colLogicalDisks = objWMIService.ExecQuery _\r\n         (\"ASSOCIATORS OF {Win32_DiskPartition.DeviceID=\"\"\" & _\r\n            objPartition.DeviceID & \"\"\"} WHERE AssocClass = \" & _\r\n               \"Win32_LogicalDiskToPartition\")\r\n \r\n      For Each objLogicalDisk In colLogicalDisks\r\n         if objLogicalDisk.DeviceID = UCase(drive) Then\r\n            For Each volume in objVolumes\r\n               if volume.DriveLetter = UCase(drive) Then\r\n                  volKey = replace(replace(volume.DeviceID, \"\\\\?\", \"\\??\"), \"}\\\", \"}\")\r\n                  volString = SigOrder(StrPad(Hex(objDrive.signature), 8, \"0\")) & \",00,\" & StartSectorOrder(StartPartition(objPartition.StartingOffset/objDrive.BytesPerSector)) & \",00\"\r\n\t\t\t\t  registrySignature =  Replace(volString, \",\", \"\")\r\n\t\t\t\t  diskSignatureHex = Hex(objDrive.signature)\r\n                  if reg = 0 Then\r\n                     migrateData = migrateData & \"HKLM,\"\"SYSTEM\\MountedDevices\"\",\"\"\" & volKey & _\r\n                       \"\"\"\" & \",0x00030001,\\\" & VbCrLf\r\n                     migrateData = migrateData &  \"     \" & volString & VbCrLf\r\n                     migrateData = migrateData & \"HKLM,\"\"SYSTEM\\MountedDevices\"\",\"\"\" & _\r\n                       \"\\DosDevices\\\" & UCase(objLogicalDisk.DeviceID) & _\r\n                       \"\"\",0x00030001,\\\" & VbCrLf\r\n                     migrateData = migrateData & \"     \" & volString & VbCrLf\r\n                  else\r\n                     migrateData = migrateData & \"Volume: \" & volKey & VbCrLf\r\n                     migrateData = migrateData & \"Registry Signature: \" & registrySignature & VbCrLf\r\n                     migrateData = migrateData & \"Disk Signature: \" & diskSignatureHex & VbCrLf\r\n                  end if\r\n\t\t\t\t  Exit For\r\n               end if\r\n            Next\r\n         end if\r\n      Next\r\n   Next\r\nNext\r\nWScript.Echo(\"Configuring Windows to use drive letter \" & drive & \" as the System Drive\")\r\nWScript.Echo(\"(Drive: \" & drive & \", Registry Signature: \" & registrySignature & \", Volume Key: \" & volKey & \", Disk Signature: \" & diskSignatureHex & \")\")\r\n\r\nbtDir = drive & \"\\$WIN_NT$.~BT\"\r\nIf Not FSO.FolderExists(btDir) Then\r\n    FSO.CreateFolder(btDir)\r\nEnd If\r\nSet TextStream = FSO.CreateTextFile(btDir & \"\\migrate.inf\")\r\nTextStream.WriteLine(\"[Version]\")\r\nTextStream.WriteLine(\"Signature\" & \"=\" & \"\"\"\" & \"$Windows NT$\" & \"\"\"\")\r\nTextStream.WriteBlankLines(1)\r\nTextStream.WriteLine(\"[Addreg]\")\r\nTextStream.WriteLine(\"HKLM,\"\"SYSTEM\\MountedDevices\"\",,0x00000010\")\r\nTextStream.Write(migrateData)\r\nTextStream.Close()\r\n\r\n'See http://www.experts-exchange.com/Programming/Languages/Visual_Basic/VB_Script/Q_22481368.html\r\n'SCROLL TO THE BOTTOM OF THE WEB PAGE TO SEE THE ANSWER\r\nset oShell = WScript.CreateObject (\"Wscript.Shell\")\r\nsTempHive = \"\"\"HKEY_LOCAL_MACHINE\\HPSA\"\"\"\r\noShell.run \"reg load \" & sTempHive & \" \" & drive & \"\\windows\\system32\\config\\system\", true\r\nWScript.Sleep 2000\r\noShell.run \"reg add HKLM\\HPSA\\MountedDevices /ve /f\", true\r\noShell.run \"reg add HKLM\\HPSA\\MountedDevices /v \\DosDevices\\\" & UCase(drive) & \" /t REG_BINARY /d \" & registrySignature & \" /f\", true\r\noShell.run \"reg add HKLM\\HPSA\\MountedDevices /v \" & volKey & \" /t REG_BINARY /d \" & registrySignature & \" /f\", true\r\noShell.run \"reg add HKLM\\HPSA\\Setup /v BootDiskSig /t REG_DWORD /d 0x\" & diskSignatureHex & \" /f\", true\r\noShell.run \"reg unload \" & sTempHive\r\n", 
    "state": null, 
    "version": {
      "usage": "This script is needed if you want to install Windows 2003 onto an alternate drive letter other than the default \"C\" drive.  It creates a manifest.inf file windows setup will use that maps the desired drive letter as present in the winpe environment to that same driver letter when Windows first boots.  This is done via disk ID and volume label.\n\nUsage:\n\nchange_windows_drive_letter.vbs [LETTER]\n\nwhere LETTER is the single character drive letter where you want Windows to be installed. By default this will be either the value of the SystemDrive custom attribute or default to \"C\", in which case nothing needs to be done. It is recommended that you do NOT provide any parameters to this script and instead specify the SystemDrive custom attribute on your target server because an alternate drive letter must be referenced by several steps in the OS Build Plan in order to succeed.\n\nPrerequisites:\n - Script needs to be run as part of a build plan.\n - Target drive letter must correspond to a mounted, formatted, writable volume.\n - Target server runs a Windows PE maintenance OS.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:31.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "VBS", 
    "currentVersionChangedDate": "2014-03-10T21:37:31.000Z", 
    "runAsSuperUser": false, 
    "displayCodeType": "Windows VBScript", 
    "allVersions": [
      {
        "usage": "This script is needed if you want to install Windows 2003 onto an alternate drive letter other than the default \"C\" drive.  It creates a manifest.inf file windows setup will use that maps the desired drive letter as present in the winpe environment to that same driver letter when Windows first boots.  This is done via disk ID and volume label.\n\nUsage:\n\nchange_windows_drive_letter.vbs [LETTER]\n\nwhere LETTER is the single character drive letter where you want Windows to be installed. By default this will be either the value of the SystemDrive custom attribute or default to \"C\", in which case nothing needs to be done. It is recommended that you do NOT provide any parameters to this script and instead specify the SystemDrive custom attribute on your target server because an alternate drive letter must be referenced by several steps in the OS Build Plan in order to succeed.\n\nPrerequisites:\n - Script needs to be run as part of a build plan.\n - Target drive letter must correspond to a mounted, formatted, writable volume.\n - Target server runs a Windows PE maintenance OS.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:31.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:31:11.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:39.000Z", 
    "description": "Installs Windows 2008 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1340001", 
    "modified": "2014-08-26T06:31:11.000Z", 
    "name": "Run Windows 2008 R2 x64 Setup", 
    "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n", 
    "state": null, 
    "version": {
      "usage": "Installs Windows 2008 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
      "current": true, 
      "versionLabel": "3", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:31:11.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-08-26T06:31:11.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs Windows 2008 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:40.000Z"
      }, 
      {
        "usage": "Installs Windows 2008 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:49.000Z"
      }, 
      {
        "usage": "Installs Windows 2008 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": true, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:31:11.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:10:48.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:52.000Z", 
    "description": "This manages configuration files for Proliant iLO.\nReads/Writes HP Manage iLO Configuration\n\nOptional Custom Attributes:\n- Capture parameters: -w ilooutput.xml\n- Deploy parameters: -f iloinput.xml", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/580001", 
    "modified": "2014-03-28T00:10:48.000Z", 
    "name": "Manage iLO Configuration", 
    "source": "#!/bin/sh\n\n# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\n# ======================================================================\n# Reads/Writes HP Manage iLO Configuration\n#\n# Capture parameters: -w ilooutput.xml\n# Deploy parameters: -f iloinput.xml \n# ======================================================================\n\nUTIL=hponcfg\nDIR=\"/tmp/sstk\"\n\n# To check the arguments\n\nif [ $# -lt 2 ]; then\n  echo \"Missing Arguments\"\n  exit 1\nfi\nMODE=$1\nFILE=$2\nshift 2\n\nif [ -f $DIR/$UTIL ];then\n chmod +x $DIR/$UTIL\nelse\n echo \"Missing $DIR/$UTIL file\"\n exit 1\nfi\n\n#Run hponcfg\n\n\"$DIR/$UTIL\" \"$MODE\" \"$FILE\"\nrc=$?\n\ncase $rc in\n   0 )\n      echo \"$UTIL successful\";;\n   127 )\n      echo \"$UTIL failed ($rc): Missing library in automation\" 1>&2;;\n   134 )\n      echo \"$UTIL failed ($rc): Corrupted custom post message\" 1>&2 ;;\n   * )\n      echo \"$UTIL failed ($rc)\" 1>&2 ;;\nesac\nexit $rc\n", 
    "state": null, 
    "version": {
      "usage": "This manages configuration files for Proliant iLO.\nReads/Writes HP Manage iLO Configuration\n\nOptional Custom Attributes:\n- Capture parameters: -w ilooutput.xml\n- Deploy parameters: -f iloinput.xml", 
      "current": true, 
      "versionLabel": "2", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:10:48.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-28T00:10:48.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "This manages configuration files for Proliant iLO.\nReads/Writes HP Manage iLO Configuration\n\nOptional Custom Attributes:\n- Capture parameters: -w ilooutput.xml\n- Deploy parameters: -f iloinput.xml", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:53.000Z"
      }, 
      {
        "usage": "This manages configuration files for Proliant iLO.\nReads/Writes HP Manage iLO Configuration\n\nOptional Custom Attributes:\n- Capture parameters: -w ilooutput.xml\n- Deploy parameters: -f iloinput.xml", 
        "current": true, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:10:48.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:24.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:25.000Z", 
    "description": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1070001", 
    "modified": "2014-08-26T06:30:24.000Z", 
    "name": "Embed files initrd", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" (c) Copyright 2009 Hewlett-Packard Development Company, L.P.\n        OS Build Plan Step used to embed a list of files in the initrd image.\n\"\"\"\n\nimport sys\nimport optparse\nimport os\nimport shutil\nfrom osprov.osbp import logger\nfrom osprov.util import process\nfrom osprov import helpers\nfrom osprov.errors import ProcessExecutionError\n\nfrom osprov.constants import DEFAULT_SA_INITRD_MASK\nfrom osprov.constants import DEFAULT_INITRD_DIR\n\nLOG = logger.getIt('embed to initrd')\nKEYS = helpers.getDataStore()\n\n\ndef embed(sources, initrd):\n    \"\"\" Embed a given directory in an initrd image or\n    append to an existing initrd.\n    \"\"\"\n\n    # create the destination folder of the initrd if it doesn't exist\n    folder = os.path.dirname(initrd)\n    if not os.path.exists(folder):\n        os.makedirs(folder)\n\n    # create an empty tmp folder of the initrd\n    rdpath, rdname = os.path.split(initrd)\n    tmpfolder = \"%s/tmp_%s\" % (rdpath, rdname)\n\n    if os.path.exists(tmpfolder):\n        shutil.rmtree(tmpfolder)\n    os.makedirs(tmpfolder)\n\n    process.runIt(\"sync\")\n    # collect all sources\n    for thissrc in sources:\n        source, dest = thissrc.split(\":\")\n        print \"Adding to intrd %s : source %s -> destination: %s\" % (initrd, source, dest)\n        tmpdest = \"%s/%s\" % (tmpfolder, dest)\n        # add the target dir unless it exists already\n        if not os.path.exists(tmpdest):\n            os.makedirs(tmpdest)\n        # copy now - rc=1 complains about file attrib & permissions\n        # so it gets ignored as we're root anyway.\n        process.runIt(\"cp -a %s %s\" % (source, tmpdest), checkExitCode=(0, 1,), log = LOG)\n\n    # create or append to initrd\n    process.runIt(\"cd %s && find . -print0 | cpio -0 --format=newc -ov | gzip -9 >> %s\" %\n                  (tmpfolder, initrd),\n                  log=LOG, quiet=True, shell=True,\n                  )\n\n    # remove the tmpfolder to cleanup and save space.\n    shutil.rmtree(tmpfolder)\n\n\ndef argsError(parser, msg):\n    print \"%s\" % msg\n    parser.error(msg)\n\n\ndef parseArgs(args):\n    \"\"\"Parse the command line arguments\"\"\"\n    parser = optparse.OptionParser(description=__doc__, version='0.0.1', )\n    parser.add_option('-s', '--source',\n                      help=\"Path to add to initrd. Can be repeated multiple times \",\n                      action=\"append\")\n    parser.add_option('-n', '--name',\n                      help=\"the base name of the new initrd file to be created. \"\n                      \"If this parameter is not present a default name will be used \"\n                      \"also a version number is added and incremented if required to \"\n                      \"make the filename unique and to indicate the sequence of creation.\")\n    opt, args = parser.parse_args(args)\n    if args:\n        argsError(parser, \"Additional positional arguments are not supported\")\n    if not opt.source:\n        argsError(parser, \"At least one source needs to be present\")\n    for eachsrc in opt.source:\n        if \":\" not in eachsrc:\n            argsError(\n                parser, \"Invalid source parameter: needs \\\":\\\" to separate <source>:<destination-dir>.\")\n        if eachsrc.endswith(\":\"):\n            argsError(parser, \"Invalid source parameter: needs <destination-dir> after \\\":\\\".\")\n    return opt\n\n\ndef main():\n    \"\"\" main entry point on the cmdline \"\"\"\n    opt = parseArgs(sys.argv[1:])\n    root_location = KEYS.disk.device_mount\n    if opt.name:\n        initrdmask = opt.initrd\n    else:\n        initrdmask = DEFAULT_SA_INITRD_MASK\n    initrdfile = helpers.generateSeqFileName(\n        path=os.path.join(root_location, DEFAULT_INITRD_DIR), mask=initrdmask)\n    # put all sources into one new initrd file\n    try:\n        embed(opt.source, os.path.join(root_location, DEFAULT_INITRD_DIR, initrdfile))\n    except ProcessExecutionError, why:\n        LOG.exception(why)\n        print \"Failed to create initrd: %s\" % why\n        return why.exitCode\n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "10", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:24.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-08-26T06:30:24.000Z", 
    "runAsSuperUser": false, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:25.000Z"
      }, 
      {
        "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:14.000Z"
      }, 
      {
        "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:56.000Z"
      }, 
      {
        "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:20.000Z"
      }, 
      {
        "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:44.000Z"
      }, 
      {
        "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "6", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:07.000Z"
      }, 
      {
        "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:30.000Z"
      }, 
      {
        "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:59.000Z"
      }, 
      {
        "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "9", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:25.000Z"
      }, 
      {
        "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "10", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:24.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:26.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:02.000Z", 
    "description": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/700001", 
    "modified": "2014-08-26T06:30:26.000Z", 
    "name": "Deploy Agent", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" (c) Copyright 2009 Hewlett-Packard Development Company, L.P.\n    Server script to download unit from the agent cache\n\"\"\"\nimport sys\nimport random\nimport os\nimport socket\n\nfrom httplib import HTTPConnection\nfrom optparse import OptionParser\n\nfrom osprov.errors import ShowErrorMessage, DiscoveryError\nfrom osprov.osbp import logger\nfrom osprov.util import process\nfrom osprov import helpers\nfrom osprov import sa\n\n# pylint: disable=E0611,F0401\nfrom coglib import gwcron\nfrom pytwist.com.opsware.search import Filter\n# pylint: enable=E0611,F0401\n\nLOG = logger.getIt(\"deploy agent\")\n\n\ndef getShortName(platformName):\n    \"\"\" Translate platform name into the short form used to identify the agent \"\"\"\n    twistServer = sa.getTwistServer()\n    unitFilter = Filter()\n    unitFilter.setObjectType(\"platform\")\n    # Customer ID 15 is \"Opsware\"\n    unitFilter.setExpression(\"platform_name EQUAL_TO \\\"%s\\\"\" % platformName)\n    refs = twistServer.device.PlatformService.findPlatformRefs(unitFilter)\n    if not refs:\n        raise ShowErrorMessage(\"Unable to find HP SA Agent Installer package \"\n                               \"for platform '%s'. Most likely your platform name is incorrect or\"\n                               \" misspelled.\" % platformName)\n    platformVO = twistServer.device.PlatformService.getPlatformVO(refs[0])\n    return \"%s-%s\" % (platformVO.shortName, platformVO.version)\n\n\ndef getAgentName(platform, name):\n    \"\"\" Get the name of the agent given the platform short name \"\"\"\n    if not name:\n        name = \"osprov_ogfs_agent\"\n    platform = getShortName(platform)\n    return \"%s-%s\" % (name, platform)\n\n\ndef getGateway():\n    \"\"\" Use the agent configuration to determine valid gateway\n\n            If more GWs are present, one will be chosen by random.choice\n    \"\"\"\n    gcm = gwcron.GatewayConfManager()\n    servers = gcm.load()\n    if servers:\n        return random.choice(servers)\n    else:\n        return []\n\n\ndef discoverPlatform():\n    \"\"\" Discover the platform of the agent that needs downloading\"\"\"\n    platform = helpers.getDataStore().platform.full_name\n    if not platform:\n        raise DiscoveryError(\"Failed to discover the needed platform.\")\n    return platform\n\n\ndef parseArgs(args):\n    \"\"\" parse and normalise arguments for the script \"\"\"\n    parser = OptionParser()\n    parser.add_option(\"-n\", \"--name\", metavar=\"NAME\",\n                      help=\"The name of the agent to retrieve\")\n    parser.add_option(\"-p\", \"--platform\", metavar=\"PLATFORM\",\n                      help=\"The platform for the agent\")\n    parser.add_option(\"-d\", \"--dest\", metavar=\"DEST\", default=None,\n                      help=\"Where to download the agent. This needs to be a full or relative \"\n                      \"path to a file. Directories along the path will be created if they don't \"\n                      \"exist.\")\n    parser.add_option(\"-g\", \"--gateway\",\n                      help=\"Optional server to download from. If not present the agents \"\n                            \"configuration will be used to determine a valid gateway\",\n                      metavar=\"SERVER\", default=None)\n    parser.add_option(\"-u\", \"--unzip\",\n                      help=\"Unzip and delete the agent in the directory where it was downloaded\",\n                      action=\"store_true\", default=False)\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    if not options.dest:\n        parser.error(\"A destination must be provided\")\n    if not options.platform:\n        options.platform = discoverPlatform()\n    options.name = getAgentName(options.platform, options.name)\n    if not options.gateway:\n        gws = getGateway()\n        if not gws:\n            parser.error(\"Can't determine gateway. Please provide one.\")\n        options.gateway = \"%s:%s\" % (gws[0], gws[1])\n    options.dest = os.path.abspath(options.dest)\n    return options\n\n\ndef download(server, unitName, dest):\n    \"\"\" Download the file from the Agent cache \"\"\"\n    dirname = os.path.dirname(dest)\n    if not os.path.exists(dirname):\n        os.makedirs(dirname)\n    conn = HTTPConnection(server)\n    conn.set_tunnel(\"127.0.0.1:8081\")\n    conn.connect()\n    conn.request(\"GET\", \"/%s\" % unitName)\n    resp = conn.getresponse()\n    if resp.status == 200:\n        dfile = open(dest, \"w\")\n        dfile.write(resp.read())\n        dfile.close()\n    else:\n        raise ShowErrorMessage(\"Download failed: %s %s\" % (resp.status, resp.reason))\n\n\ndef unzip(dest):\n    \"\"\" Unzip the agent \"\"\"\n    # we can't use zipfile.extractall(os.path.dirname(dest))\n    # since our python is old\n    process.runIt(\"/opt/opsware/agent/bin/unzip -d %s -o %s\" %\n                 (os.path.dirname(dest), dest),\n                  log=LOG, quiet=True, quieterr=True)\n    os.remove(dest)\n\n\ndef main():\n    \"\"\" Main entry point \"\"\"\n    try:\n        options = parseArgs(sys.argv[1:])\n        download(options.gateway, options.name, options.dest)\n        if options.unzip:\n            unzip(options.dest)\n            print \"Downloaded and extracted %s to %s\" % \\\n                (options.name, os.path.dirname(options.dest))\n        else:\n            print \"Downloaded %s to %s\" % (options.name, options.dest)\n    except socket.error, why:\n        LOG.exception(why)\n        print \"Can't connect to %s : %s\" % (options.gateway, why)\n        return 1\n    except ShowErrorMessage, why:\n        print why\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "17", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:26.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-08-26T06:30:26.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:03.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:35.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:56.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:17.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:36.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "6", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:56.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:18.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:38.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "9", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:14.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "10", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:55.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "11", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:20.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "12", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:44.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "13", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:07.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "14", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:30.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "15", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:59.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "16", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:26.000Z"
      }, 
      {
        "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "17", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:26.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:33.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:32.000Z", 
    "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the CentOS installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1210001", 
    "modified": "2014-03-10T21:37:33.000Z", 
    "name": "Install bootloader for CentOS", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nThis python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, NotFoundError, ShowErrorMessage\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import Netconfig\nfrom osprov.parsers.netconfig import getActiveInterface\nfrom osprov.server import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n# for easier mocking\n\n\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef readFile(filepath):\n    \"\"\"Reads from the file identified by filepath\"\"\"\n    return open(filepath).read()\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATH = \"boot/grub/menu.lst\"\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\" % (source, destination))\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATH = os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\")\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                      % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                         'bootDiskMount': bootDiskMount,\n                         'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                         'bootDisk': bootDisk}, log=LOG, quiet=True)\n        # configure the UEFI boot entries\n        osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    search -n -u %(device_uuid)s -s\n    linux  /%(kernel)s %(kernelArguments)s\n    initrd %(initrds)s\n}\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef configureKernelArguments(osdata, keys, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    os_version = osdata[\"os_version\"]\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in os_version and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    netconfig_ca = StringIO(\"\"\"@hpsa_netconfig@\"\"\")\n    parser = Netconfig.readonly(netconfig_ca)\n    try:\n        activeKey, activeIface = getActiveInterface(localServer, parser.info())\n    except NotFoundError:\n        activeIface = None\n    ip_params = \"\"\n    if activeIface and activeIface.static:\n        net_data = {\n            \"ip\": activeIface.ip[0],\n            \"mask\": activeIface.mask[0],\n            \"dns\": \"\",\n            \"gw\": \"\",\n        }\n        # Static provisioning\n        if hasattr(activeIface, \"dns\") and activeIface.dns:\n            net_data[\"dns\"] = activeIface.dns[0]\n        if hasattr(activeIface, \"gw\"):\n            net_data[\"gw\"] = activeIface.gw[0]\n        ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n    else:\n        # dhcp provisioning\n        ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if not osdata.has_key(\"initrd\"):\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = \"CentOS\"\n    osdata[\"os_version\"] = \"CentOS\"\n    osdata[\"install_params\"] = \"ks=file:/user.ks.cfg  ksdevice=%(mac)s\"\n    osdata[\"ip_config_static\"] = \"ip=%(ip)s gateway=%(gw)s netmask=%(mask)s\"\n    osdata[\"ip_config_dhcp\"] = \"ip=dhcp noipv6\"\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n\n    _open(os.path.join(bootDiskMount, grub.MENU_PATH), \"w\").write(menu)\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the CentOS installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:33.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-10T21:37:33.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the CentOS installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:33.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:09.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:13.000Z", 
    "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the SuSE Linux Enterprise Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/830001", 
    "modified": "2014-08-26T06:30:09.000Z", 
    "name": "Install bootloader for SuSE Linux Enterprise Server", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nThis python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, NotFoundError, ShowErrorMessage\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import Netconfig\nfrom osprov.parsers.netconfig import getActiveInterface\nfrom osprov.server import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n# for easier mocking\n\n\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef readFile(filepath):\n    \"\"\"Reads from the file identified by filepath\"\"\"\n    return open(filepath).read()\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATH = \"boot/grub/menu.lst\"\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\" % (source, destination))\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATH = os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\")\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                      % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                         'bootDiskMount': bootDiskMount,\n                         'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                         'bootDisk': bootDisk}, log=LOG, quiet=True)\n        # configure the UEFI boot entries\n        osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    search -n -u %(device_uuid)s -s\n    linux  /%(kernel)s %(kernelArguments)s\n    initrd %(initrds)s\n}\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef configureKernelArguments(osdata, keys, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    os_version = osdata[\"os_version\"]\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in os_version and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    netconfig_ca = StringIO(\"\"\"@hpsa_netconfig@\"\"\")\n    parser = Netconfig.readonly(netconfig_ca)\n    try:\n        activeKey, activeIface = getActiveInterface(localServer, parser.info())\n    except NotFoundError:\n        activeIface = None\n    ip_params = \"\"\n    if activeIface and activeIface.static:\n        net_data = {\n            \"ip\": activeIface.ip[0],\n            \"mask\": activeIface.mask[0],\n            \"dns\": \"\",\n            \"gw\": \"\",\n        }\n        # Static provisioning\n        if hasattr(activeIface, \"dns\") and activeIface.dns:\n            net_data[\"dns\"] = activeIface.dns[0]\n        if hasattr(activeIface, \"gw\"):\n            net_data[\"gw\"] = activeIface.gw[0]\n        ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n    else:\n        # dhcp provisioning\n        ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if not osdata.has_key(\"initrd\"):\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = \"SuSE Linux Enterprise Server\"\n    osdata[\"os_version\"] = \"SLES\"\n    osdata[\"install_params\"] = \"install=%(url)s autoyast=file:///user.autoinst.xml textmode=1 netdevice=%(mac)s\"\n    osdata[\"ip_config_static\"] = \"hostip=%(ip)s gateway=%(gw)s netmask=%(mask)s nameserver=%(dns)s\"\n    osdata[\"ip_config_dhcp\"] = \"\"\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n\n    _open(os.path.join(bootDiskMount, grub.MENU_PATH), \"w\").write(menu)\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the SuSE Linux Enterprise Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "4", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:09.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-08-26T06:30:09.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the SuSE Linux Enterprise Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:13.000Z"
      }, 
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the SuSE Linux Enterprise Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:55.000Z"
      }, 
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the SuSE Linux Enterprise Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:20.000Z"
      }, 
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the SuSE Linux Enterprise Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:09.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:07.000Z", 
    "serverChanging": true, 
    "created": "2014-08-26T06:30:06.000Z", 
    "description": "Creates and executes a BAT script on the target server that installs the SPP, but does not wait for it to complete.  The BAT script stops the HP SA agent prior to installing the SPP, and starts the HP SA agent after the SPP installation is complete.  The HP SA agent is stopped while the SPP is being installed, because when the NIC firmware is updated, it may cause connection problems between the HP SA agent and the SA core.\n\nOptions:\n    --spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2012.06.0\" or \"2013.09.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n    --hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\nRequirements:\n* Media Server must be mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1810001", 
    "modified": "2014-08-26T06:30:07.000Z", 
    "name": "Install Windows SPP In Background for CSI Test", 
    "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(c) Copyright 2014 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport os\nimport subprocess\n\nfrom subprocess import Popen, PIPE, STDOUT\nfrom optparse import OptionParser\n\nDEBUG=@Debug:0@\n\n# The drive letter on which the media server file share is mounted.\nmediaServerDriveLetter = None\n\n# Get the Windows \"Temp\" directory.\nwindowsSystemDrive = os.getenv(\"SystemDrive\")\nwindowsTempDir = windowsSystemDrive + \"\\\\Windows\\\\Temp\"\n\n# This is where we will copy the HP SUM applications to, so we can run\n# HP SUM from the target server instead of the remote media server\n# file share.\nlocalHpSumDir = windowsTempDir + \"\\\\LocalHpSum\"\n\n# The directory where we will stage our SPP installation scripts and\n# output files.\nicspTempDir = windowsTempDir + \"\\\\icsp\"\nhpSumScript = icspTempDir + \"\\\\hpsum_script.bat\"\nhpSumOutputFile = icspTempDir + \"\\\\hpsum_output.txt\"\nhpSumExitCodeFile = icspTempDir + \"\\\\hpsum_exit_code.txt\"\nsppInstallScript = icspTempDir + \"\\\\spp_install.bat\"\nsppOutputFile = icspTempDir + \"\\\\spp_output.txt\"\n\nsppDir = None\nbuildDir = None\nsppVersionDir = None\nbuildVersionDir = None\nremoteHpSumDir= None\n\n# HP SUM 5.X uses \"hpsum.exe\", while HP SUM 6.X uses \"hpsum.bat\".\nhpSumExe = \"hpsum.exe\"\nhpSumBat = \"hpsum.bat\"\nmasterDependencyXml = \"masterdependency.xml\"\nhpSumApp = None\n\n# The options we will pass to HP SUM.  The \"/silent\" option is required.\n# Additional options may be passed in to this script using the \n# \"--hpsum_options\" parameter.\nhpSumOptions=\"/silent\"\n\n# Parses the command line arguments.\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--spp_version\",\n            default = \"latest\",\n            dest = \"sppVersion\",\n            help = \"The SPP version to install.\")\n    parser.add_option(\"--hpsum_options\",\n            default = \"\",\n            dest = \"hpSumOptions\",\n            help = \"Additional options to pass to hpsum.\")\n    parser.add_option(\"--media_server_drive_letter\",\n            default = \"z\",\n            dest = \"mediaServerDriveLetter\",\n            help = \"The drive letter on which the media server file share is mounted.\")\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n##############################################################################\n# Writes an debug message to stdout.\n##############################################################################\n\ndef writeDebugMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    if (DEBUG):\n        print msg\n\n##############################################################################\n# Writes an info message to stdout.\n##############################################################################\n\ndef writeInfoMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    print msg\n\n##############################################################################\n# Writes an error message to stderr.\n##############################################################################\n\ndef writeErrorMessage(msg):\n\n    # Write the message to stderr so that it shows up in the job output.\n    sys.stderr.write(msg)\n\n##############################################################################\n# Returns the latest SPP version, which is determined by the directory name\n# who comes first in descending sort order.\n##############################################################################\n\ndef getLatestSppVersion():\n\n    writeDebugMessage(\"Searching for the latest SPP\")\n\n    # Get the subdirectories under the \"Media/spp\" directory.\n    sppVersions = [name for name in os.listdir(sppDir) if os.path.isdir(os.path.join(sppDir, name))]\n\n    # Sort the directories in descending order.\n    sortedSppVersions = sorted(sppVersions, reverse=True)\n\n    if (len(sortedSppVersions) == 0):\n        raise Exception(\"No SPP versions were found under the '%s' directory.\" % sppDir)\n\n    writeDebugMessage(\"Found %d SPP versions under '%s'\" % (len(sortedSppVersions),sppDir))\n    writeDebugMessage(\"Selected '%s' as latest SPP\" % sortedSppVersions[0])\n\n    # Return the first directory, which should represent the latest SPP based\n    # on sort order, assuming the name convention is \"YYYY.MM\".\n    return sortedSppVersions[0]\n\n##############################################################################\n# Returns the latest SPP version, which is determined by the directory name\n# who comes first in descending sort order.\n##############################################################################\n\ndef getLatestBUILDVersion():\n\n    writeDebugMessage(\"Searching for the latest BUILD\")\n\n    # Get the subdirectories under the \"Media/spp\" directory.\n    buildVersions = [name for name in os.listdir(sppVersionDir) if os.path.isdir(os.path.join(sppVersionDir, name))]\n\n    # Sort the directories in descending order.\n    sortedBUILDVersions = sorted(buildVersions, reverse=True)\n\n    if (len(sortedBUILDVersions) == 0):\n        raise Exception(\"No SPP versions were found under the '%s' directory.\" % sppVersionDir)\n\n    writeDebugMessage(\"Found %d BUILD versions under '%s'\" % (len(sortedBUILDVersions),sppVersionDir))\n    writeDebugMessage(\"Selected '%s' as latest BUILD\" % sortedBUILDVersions[0])\n\n    # Return the first directory, which should represent the latest SPP based\n    # on sort order, assuming the name convention is \"YYYY.MM\".\n    return sortedBUILDVersions[0]\n\t\n##############################################################################\n# Creates our temporary ICSP directory on which we will land our scripts that\n# run HP SUM.\n##############################################################################\n\ndef createIcspTempDir():\n\n    writeDebugMessage(\"Creating %s\" % icspTempDir)\n\n    dirExists = False;\n\n    # Check if \"icsp\" already exists, and is a directory, not a file.  If it's\n    # a file, remove it.\n    if (os.path.exists(icspTempDir)):\n        if (os.path.isdir(icspTempDir)):\n            dirExists = True\n        else:          \n            removeFile(icspTempDir)\n\n    # If the directory didn't already exist, then create it.\n    if (not dirExists):\n        cmdArgs = [\"mkdir\", icspTempDir]\n\n        retCode, output = executeCommand(cmdArgs)\n\n        if (retCode != 0):\n            raise Exception(\"An error occurred while creating directory '%s': %s\" % (icspTempDir, output))\n\n##############################################################################\n# Create the \"LocalHpSum\" directory where we are going to copy the necessesary\n# HPSUM application files.  The firmware files and software packages will\n# remain on the media server.  The reason why we copy the HP SUM application\n# files locally, is because, otherwise, HP SUM might get a segmentation fault\n# when the NIC firmware is updated, due to loss of network connectivity with\n# the media server.  It's possible that not all pages are loaded into memory,\n# which is a problem if the NIC goes down and another page is requested.\n##############################################################################\n\ndef createLocalHpSumDir():\n\n    writeDebugMessage(\"Creating %s\" % localHpSumDir)\n\n    if (os.path.exists(localHpSumDir)):\n        if not (os.path.isdir(localHpSumDir)):\n            raise Exception(\"'%s' exists, but is not a directory.\" % localHpSumDir)\n    else:\n        cmdArgs = [\"mkdir\", localHpSumDir]\n\n        retCode, output = executeCommand(cmdArgs)\n\n        if (retCode != 0):\n            raise Exception(\"An error occurred while creating directory '%s': %s\" % (localHpSumDir, output))\n\n##############################################################################\n# Copies the HP SUM 6.X application files locally to the target server.  The\n# reason for copying the files locally, is because HP SUM will core dump if\n# it's run remotely from the media server and the NIC firmware is updated,\n# causing the network connection to be lost.\n##############################################################################\n \ndef copyHpSum6AppsToTargetServer():\n\n    global hpSumApp\n\n    createLocalHpSumDir()\n\n    fullPathToMasterDependency = remoteHpSumDir + \"\\\\\" + masterDependencyXml\n\n    # Copy the \"masterdependency.xml\" file locally to the target server.\n    cmdArgs = [\"copy\", \"/Y\", fullPathToMasterDependency, localHpSumDir]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occured while copying '%s' to '%s': %s\" % (fullPathToMasterDependency, localHpSumDir, output))\n\n    fullPathToHpSumBat = remoteHpSumDir + \"\\\\\" + hpSumBat\n\n    writeDebugMessage(\"Copying HP SUM 6.X files locally to target server\")\n\n    # Copy the \"hpsum.bat\" file locally to the target server.\n    cmdArgs = [\"copy\", \"/Y\", fullPathToHpSumBat, localHpSumDir]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occured while copying '%s' to '%s': %s\" % (fullPathToHpSumBat, localHpSumDir, output))\n\n    # These are the subdirectories needed by HP SUM to run locally to the target server.\n    subDirs = [ \"x64\", \"x86\", \"cygwin\", \"assets\"]\n\n    # Copy the subdirectories needed by HP SUM locally to the target server.\n    for dirName in subDirs:\n        fullPathToRemoteSubDir = remoteHpSumDir + \"\\\\\" + dirName\n        fullPathToLocalSubDir = localHpSumDir + \"\\\\\" + dirName\n\n        cmdArgs = [\"xcopy\", \"/s\", \"/y\", \"/i\", \"/q\", fullPathToRemoteSubDir, fullPathToLocalSubDir]\n\n        retCode, output = executeCommand(cmdArgs)\n\n        if (retCode != 0):\n            raise Exception(\"An error occured while copying '%s' to '%s': %s\" % (fullPathToRemoteSubDir, fullPathToLocalSubDir, output))\n\n##############################################################################\n# Gets the HP SUM application to call, which is different, depending on\n# whether HP SUM 6.X is being used or HP SUM 5.X is being used.\n##############################################################################\n\ndef getHpSumApp():\n\n    hpSumAppToCall = None\n\n    # HP SUM 6.X uses \"hpsum.bat\".\n    fullPathToHpSumBat = remoteHpSumDir + \"\\\\\" + hpSumBat\n\n    # HP SUM 5.X uses \"hpsum.exe\".\n    fullPathToHpSumExe = remoteHpSumDir + \"\\\\\" + hpSumExe\n\n    # HP SUM 6.X uses \"hpsum.bat\", whereas HP SUM 5.X uses \"hpsum.exe\".\n    if (os.path.exists(fullPathToHpSumBat)):\n        writeDebugMessage(\"Found %s\" % fullPathToHpSumBat)\n\n        # This is the executable that we'll call to install HP SUM 6.X.\n        hpSumAppToCall = hpSumBat\n    elif (os.path.exists(fullPathToHpSumExe)):\n        writeDebugMessage(\"Found %s\" % fullPathToHpSumExe)\n\n        # This is the executable that we'll call to install HP SUM 5.X.\n        hpSumAppToCall = hpSumExe\n    else:\n        raise Exception(\"Could not find '%s' or '%s'\" % (fullPathToHpSumBat, fullPathToHpSumExe))\n\n    return hpSumAppToCall\n\n##############################################################################\n# Removes the specified file.\n##############################################################################\n\ndef removeFile(filePath):\n\n    writeDebugMessage(\"Removing file %s\" % filePath)\n\n    cmdArgs = [\"del\", \"/q\", \"/s\", filePath]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occurred while removing file '%s': %s\" % (filePath, output))\n\n##############################################################################\n# Removes the specified directory.\n##############################################################################\n\ndef removeDir(dirPath):\n\n    writeDebugMessage(\"Removing directory %s\" % dirPath)\n\n    cmdArgs = [\"rmdir\", \"/q\", \"/s\", dirPath]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occurred while removing directory '%s': %s\" % (dirPath, output))\n\n##############################################################################\n# Removes the HP SUM temporary directory.\n##############################################################################\n\ndef removeHpSumTempDir():\n    writeDebugMessage(\"Removing HP SUM temporary directory\")\n\n    # HP SUM 5.X and HP SUM 6.X used different temporary directory, so lets\n    # check for both.\n    hpSum5TempDir = windowsTempDir + \"\\\\hp_sum\"\n    hpSum6TempDir = windowsTempDir + \"\\\\HPSUM\"\n\n    for tempDir in [ hpSum5TempDir, hpSum6TempDir]:\n        if (os.path.exists(tempDir)):\n            if (os.path.isdir(tempDir)):\n                removeDir(tempDir)\n            else:\n                removeFile(tempDir)\n\n##############################################################################\n# delimiter character (default = ' ').\n##############################################################################\n\ndef listToString(list, delimeter=' '):\n\n    str = delimeter.join(list)\n\n    return str\n\n##############################################################################\n# Executes the specified command, which must be a list contaning the \n# executable name and its arguments.\n##############################################################################\n\ndef executeCommand(cmdArgs):\n\n    cmdAsString = listToString(cmdArgs)\n\n    writeDebugMessage(\"Executing => \" + cmdAsString)\n\n    p = subprocess.Popen(cmdArgs, stdout=subprocess.PIPE, stderr=STDOUT, shell=True)\n\n    output = p.communicate()[0].strip()\n\n    retCode = p.poll()\n\n    p.stdout.close()\n\n    return retCode, output\n\n##############################################################################\n# Executes the specified command, which must be a list contaning the \n# executable name and its arguments, and returns immediately, without\n# waiting for the process to finish.\n##############################################################################\n\ndef executeCommandAndDetach(cmdArgs):\n\n    cmdAsString = listToString(cmdArgs)\n\n    writeDebugMessage(\"Executing => \" + cmdAsString)\n\n    retCode = 0\n\n    try:\n        CREATE_NO_WINDOW=0x08000000\n        CREATE_NEW_PROCESS_GROUP=0x00000200\n        CREATE_BREAKAWAY_FROM_JOB=0x01000000\n\n        p = subprocess.Popen(cmdArgs, close_fds = True, creationflags=CREATE_NO_WINDOW|CREATE_NEW_PROCESS_GROUP|CREATE_BREAKAWAY_FROM_JOB)\n\n        retCode = p.poll()\n    except (Exception), why:\n        retCode = 1\n        sys.stderr.write(\"An error occured while executing '%s': %s\" % (cmdAsString,str(why)))\n\n    return retCode\n\n##############################################################################\n# Checks if the specified directory is accessible.\n##############################################################################\n\ndef checkIfDirIsAccessible(dirPath):\n\n    if (os.path.exists(dirPath)):\n        if not (os.path.isdir(dirPath)):\n            raise Exception(\"'%s' is not a directory.\" % dirPath)\n    else:\n        raise Exception(\"The directory '%s' does not exist or the file share is not mounted.\" % dirPath)\n\n##############################################################################\n# Checks if the SPP directory is accessible.\n##############################################################################\n\ndef checkIfSppDirIsAccessible():\n\n    global sppDir\n\n    if (sppDir is not None):\n        try:\n            checkIfDirIsAccessible(sppDir)\n        except (Exception), why:\n            raise Exception(\"The SPP directory is not accessible: %s\" % why)\n    else:\n        raise Exception(\"The sppDir variable is not set\")\n\n##############################################################################\n# Checks if the SPP version directory is accessible.\n##############################################################################\n\ndef checkIfSppVersionDirIsAccessible():\n\n    global sppVersionDir\n\n    if (sppVersionDir is not None):\n        try:\n            checkIfDirIsAccessible(sppVersionDir)\n        except (Exception), why:\n            raise Exception(\"The SPP version directory is not accessible: %s\" % why)\n    else:\n        raise Exception(\"The sppVersionDir variable is not set\")\n\n##############################################################################\n# Checks if the BUILD version directory is accessible.\n##############################################################################\n\ndef checkIfBUILDVersionDirIsAccessible():\n\n    global buildVersionDir\n\n    if (buildVersionDir is not None):\n        try:\n            checkIfDirIsAccessible(buildVersionDir)\n        except (Exception), why:\n            raise Exception(\"The BUILD version directory is not accessible: %s\" % why)\n    else:\n        raise Exception(\"The buildVersionDir variable is not set\")\n\t\t\n##############################################################################\n# Creates the SPP installation script that runs the HP SUM installation\n# script and captures its output to a file.\n##############################################################################\n\ndef createSppInstallScript():\n\n    global hpSumScript\n    global hpSumOutputFile\n    global sppInstallScript\n\n    writeDebugMessage(\"Creating %s\" % sppInstallScript)\n\n    # This is a Python here document containing the contents of the SPP \n    # installation script.  All this script does is call the HP SUM installation\n    # script and capture its output to a file.\n    scriptContents = \"\"\"\ncall %s > %s\n\"\"\" % (hpSumScript,hpSumOutputFile)\n\n    # Write the file.\n    f = open( sppInstallScript, 'w')\n    f.write( scriptContents )\n    f.close()\n\n##############################################################################\n# Creates the HP SUM installation script that stops the SA agent, runs\n# HP SUM, and starts the SA agent again.\n##############################################################################\n\ndef createHpSumScript():\n\n    global hpSumOptions\n    global localHpSumDir\n    global remoteHpSumDir\n    global mediaServerDriveLetter\n    global hpSumApp\n    global hpSumBat\n\n    writeDebugMessage(\"Creating %s\" % hpSumScript)\n\n    # The 'hpSumApp' variable should have been set in the function that copies\n    # the HP SUM applications locally to the target server.\n    if (hpSumApp is None):\n        raise Exception(\"hpSumApp is not set\")\n\n    # The HP SUM command we're going to run.\n    hpSumCommand = hpSumApp + \" \" + \"/use_location\" + \" \" + remoteHpSumDir + \" \" + hpSumOptions\n\n    # HP SUM 6.X uses \"hpsum.bat\" and must be run from a directory on the target server\n    # to prevent the application from crashing when the NIC firmware is updated and\n    # the media server is no longer accessible.\n    #\n    # HP SUM 5.X uses \"hpsum.exe\" and is not susceptible to crashing when the NIC\n    # firmware is updated.  We always ran it from the remote directory on the media\n    # server, so we will continue to run it that way.\n    if (hpSumApp == hpSumBat):\n        dirToExecuteHpSumFrom = localHpSumDir\n    else:\n        dirToExecuteHpSumFrom = remoteHpSumDir\n\n    # This is a Python here document containing the contents of the script that is\n    # going to stop the SA agent, run HP SUM, and start the SA agent.  The DOS\n    # variables use \"%%\", which is to escape the second \"%\", so that Python doesn't\n    # interpret it as a format character.\n    scriptContents = \"\"\"\n@echo off\n\necho TIME: %%DATE%% %%TIME%%\n\necho Sleeping for 10 seconds to ensure that the build plan step has completed before stopping the SA agent\n\nping -n 10 127.0.0.1 >nul\n\necho TIME: %%DATE%% %%TIME%%\n\necho Stopping Opsware Agent\n\nsc stop OpswareAgent\n\nif %%ERRORLEVEL%% NEQ 0 (\n    echo Failed to stop Opware Agent\n    exit 1\n)\n\nset dirToExecuteHpSumFrom=%s\n\necho Changing directory to '%%dirToExecuteHpSumFrom%%'\n\ncd /D %%dirToExecuteHpSumFrom%%\n\nif %%ERRORLEVEL%% NEQ 0 (\n    echo Could not change directory to '%%dirToExecuteHpSumFrom%%'\n    exit 1\n)\n\necho TIME: %%DATE%% %%TIME%%\n\necho Starting hpsum\n\ncall %s\n\nset hpSumRetCode=%%ERRORLEVEL%%\n\necho hpsum exited with return code '%%hpSumRetCode%%'\n\necho TIME: %%DATE%% %%TIME%%\n\necho %%hpSumRetCode%% > %s\n\necho Starting Opsware Agent\n\nsc start OpswareAgent\n\nif %%ERRORLEVEL%% NEQ 0 (\n    echo Failed to start Opware Agent\n    exit 1\n)\n\necho TIME: %%DATE%% %%TIME%%\n\necho Changing directory to SystemDrive\n\nREM Make sure we're not on the media server drive when we exit, in order\nREM to prevent any potential problem later on if the media server drive\nREM is attempted to be unmounted.  You can't unmount a drive if a process\nREM is using it.\ncd /D %%SYSTEMDRIVE%%\\\\\n\n\"\"\" % (dirToExecuteHpSumFrom,hpSumCommand,hpSumExitCodeFile)\n\n    # Write the file.\n    f = open( hpSumScript, 'w')\n    f.write( scriptContents )\n    f.close()\n\n##############################################################################\n# Runs the HP SUM installation.\n##############################################################################\n\ndef runHpSum():\n\n    # Create the temporary directory that will contain our scripts and the\n    # output files produced by our scripts.\n    createIcspTempDir()\n\n    # Create our HP SUM script that stops the SA agent, runs HP SUM, and \n    # starts the SA agent.\n    createHpSumScript()\n\n    # Create that script that calls our HP SUM script and captures its output\n    # to a file, for debugging purposes.\n    createSppInstallScript()\n\n    cmdArgs = [sppInstallScript]\n\n    retCode = executeCommandAndDetach(cmdArgs)\n    \n    return retCode\n\n##############################################################################\n# Main Routine.\n##############################################################################\n\ndef main():\n\n    global hpSumApp\n    global hpSumBat\n    global hpSumOptions\n    global sppDir\n    global sppVersionDir\n\tglobal buildVersionDir\n    global remoteHpSumDir\n    global mediaServerDriveLetter\n\tsppVersion = \"\"\n\tbuildVersion = \"\"\n\n    retCode = 0\n\t\n\toptions, remaining_args = parseArgs(sys.argv[1:])\n\t\n    try:\n        # Get the drive letter that the meda server file share is mounted on.\n        mediaServerDriveLetter = options.mediaServerDriveLetter.strip()\n\n        writeDebugMessage(\"Media Server Drive Letter => %s\" % mediaServerDriveLetter)\n\n        # The directory on the media server where the SPPs are stored.\n        sppDir = mediaServerDriveLetter + \":\" + \"\\\\Media\\\\spp\"\n\n        # Verify that the directory is accessible.  If the media server file share\n        # was manually mounted by the user, it may not be accessible to the build plan,\n        # even though you can see it mounted from Windows.  This could cause HP SUM\n        # to hang.\n        checkIfSppDirIsAccessible()\n\n\t\tsppVersion = '@SPP_VER@'\n\t\tbuildVersion = '@BUILD_VER@'\n\t\t\n        # Check which SPP to use. If it's \"latest\", select the latest SPP from the\n        # available SPPs under the \"Media/spp\" directory.  It is expected that the\n        # SPPs are stored under \"Media/spp\", with a directory name of \"YYYY.MM\",\n        # such that the latest SPP has the highest value, according to sort order.\n        if ((sppVersion == \"\")or(buildVersion == \"\")):\n            sppVersion = getLatestSppVersion()\n            print \"Latest SPP version is '%s'\" % sppVersion\n            sppVersionDir = sppDir + \"\\\\\" + sppVersion\n\t\t\tbuildVersion = getLatestBUILDVersion()\n\t\t\tprint \"Latest BUILD version is '%s'\" % buildVersion\n\t\t\tbuildVersionDir = sppVersionDir + \"\\\\\" + buildVersion\n        else:\n            print \"SPP version is '%s'\" % sppVersion\n\t\t\tprint \"BUILD version is '%s'\" % buildVersion\n            sppVersionDir = sppDir + \"\\\\\" + sppVersion\n            checkIfSppVersionDirIsAccessible()\n\t\t\tbuildVersionDir = sppVersionDir + \"\\\\\" + buildVersion\n\t\t\tcheckIfBUILDVersionDirIsAccessible()\n\n        # The remote HP SUM directory is \"hp\\swpackages\" under the SPP - BUILD version\n        # directory.\n        remoteHpSumDir = buildVersionDir + \"\\\\hp\\\\swpackages\"\n\t\t\n        # Append any additional HP SUM options to the \"/silent\" option that we\n        # already require.\n        hpSumOptions += \" \" + hpSumOptions\n \n        writeInfoMessage(\"HP SUM options => %s\" % hpSumOptions)\n        hpSumApp = getHpSumApp()\n\n        # Remove the old HP SUM temporary directory, if exists.\n        removeHpSumTempDir()\n\n        # If the HP SUM application is \"hpsum.bat\", than means we're using\n        # HP SUM 6.X, which must be run from the target server.  So, we must\n        # copy the necessary application files over from the media server to\n        # the target server.\n        if (hpSumApp == hpSumBat):\n            copyHpSum6AppsToTargetServer()\n\n        # Run HP SUM.\n        retCode = runHpSum()\n    except (Exception), why:\n        retCode = 1\n        sys.stderr.write(\"%s\" % why)\n\n    return retCode\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Creates and executes a BAT script on the target server that installs the SPP, but does not wait for it to complete.  The BAT script stops the HP SA agent prior to installing the SPP, and starts the HP SA agent after the SPP installation is complete.  The HP SA agent is stopped while the SPP is being installed, because when the NIC firmware is updated, it may cause connection problems between the HP SA agent and the SA core.\n\nOptions:\n    --spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2012.06.0\" or \"2013.09.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n    --hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\nRequirements:\n* Media Server must be mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.", 
      "current": true, 
      "versionLabel": "25", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:06.000Z"
    }, 
    "isCustomerContent": true, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-08-26T06:30:07.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Creates and executes a BAT script on the target server that installs the SPP, but does not wait for it to complete.  The BAT script stops the HP SA agent prior to installing the SPP, and starts the HP SA agent after the SPP installation is complete.  The HP SA agent is stopped while the SPP is being installed, because when the NIC firmware is updated, it may cause connection problems between the HP SA agent and the SA core.\n\nOptions:\n    --spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2012.06.0\" or \"2013.09.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n    --hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\nRequirements:\n* Media Server must be mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.", 
        "current": true, 
        "versionLabel": "25", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:06.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:36.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:35.000Z", 
    "description": "This is a basic diskpart partitioning script that makes a single partition on\nthe first disk using the entire available space and assigning drive letter C.\nThis script does not need any command line parameters.  It will reference the\n@SystemDrive@ and @SystemDiskNumber@ custom attributes if\nthey exist. @SystemDrive@ specifies the drive letter to assign to the\nsystem disk.  This defaults to \"C\" and should be a single letter that\ncorresponds to an available valid windows drive letter.\n@SystemDiskNumber@ is an integer indicating which disk (as seen by\ndiskpart) should be formatted.  This defaults to 0.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1270001", 
    "modified": "2014-03-10T21:37:36.000Z", 
    "name": "Partition and format the system disk", 
    "source": "@echo off\r\necho rescan > X:\\diskpart.txt\r\necho select disk @SystemDiskNumber:0@ >> X:\\diskpart.txt\r\necho clean >> X:\\diskpart.txt\r\necho create partition primary >> X:\\diskpart.txt\r\necho select partition=1 >> X:\\diskpart.txt\r\necho assign letter=@SystemDrive:C@ >> X:\\diskpart.txt\r\necho active >> X:\\diskpart.txt\r\necho format FS=NTFS LABEL=\"OS\" REVISION=\"6.00\" quick >> X:\\diskpart.txt\r\necho exit >> X:\\diskpart.txt\r\necho  >> X:\\diskpart.txt\r\necho  >> X:\\diskpart.txt\r\ndiskpart.exe /s X:\\diskpart.txt > %TEMP%\\diskpart.out 2>&1\r\nif %ERRORLEVEL% == 0 (\r\n    echo diskpart completed successfully\r\n    find /V \"0 percent completed\" %TEMP%\\diskpart.out\r\n    exit\r\n) else (\r\n    echo ERROR: diskpart exited status %ERRORLEVEL%\r\n    find /V \"0 percent completed\" %TEMP%\\diskpart.out\r\n    exit /B %ERRORLEVEL%\r\n)\r\n    ", 
    "state": null, 
    "version": {
      "usage": "This is a basic diskpart partitioning script that makes a single partition on\nthe first disk using the entire available space and assigning drive letter C.\nThis script does not need any command line parameters.  It will reference the\n@SystemDrive@ and @SystemDiskNumber@ custom attributes if\nthey exist. @SystemDrive@ specifies the drive letter to assign to the\nsystem disk.  This defaults to \"C\" and should be a single letter that\ncorresponds to an available valid windows drive letter.\n@SystemDiskNumber@ is an integer indicating which disk (as seen by\ndiskpart) should be formatted.  This defaults to 0.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:36.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-10T21:37:36.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "This is a basic diskpart partitioning script that makes a single partition on\nthe first disk using the entire available space and assigning drive letter C.\nThis script does not need any command line parameters.  It will reference the\n@SystemDrive@ and @SystemDiskNumber@ custom attributes if\nthey exist. @SystemDrive@ specifies the drive letter to assign to the\nsystem disk.  This defaults to \"C\" and should be a single letter that\ncorresponds to an available valid windows drive letter.\n@SystemDiskNumber@ is an integer indicating which disk (as seen by\ndiskpart) should be formatted.  This defaults to 0.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:36.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:31:07.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:35.000Z", 
    "description": "Installs Windows 2008 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1260001", 
    "modified": "2014-08-26T06:31:07.000Z", 
    "name": "Run Windows 2008 x64 Setup", 
    "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n", 
    "state": null, 
    "version": {
      "usage": "Installs Windows 2008 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
      "current": true, 
      "versionLabel": "3", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:31:06.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-08-26T06:31:07.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs Windows 2008 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:35.000Z"
      }, 
      {
        "usage": "Installs Windows 2008 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:53.000Z"
      }, 
      {
        "usage": "Installs Windows 2008 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": true, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:31:06.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:16.000Z", 
    "serverChanging": false, 
    "created": "2014-03-10T21:37:15.000Z", 
    "description": "Syncs mounted filesystem to persist modified files", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/880001", 
    "modified": "2014-03-10T21:37:16.000Z", 
    "name": "Sync Mounted Filesystem (Linux)", 
    "source": "#!/bin/sh\necho \"Syncing modified files in mounted filesystem\"\nsync", 
    "state": null, 
    "version": {
      "usage": "Syncs mounted filesystem to persist modified files", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:16.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-10T21:37:16.000Z", 
    "runAsSuperUser": false, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Syncs mounted filesystem to persist modified files", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:16.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:41.000Z", 
    "serverChanging": false, 
    "created": "2014-03-10T21:37:41.000Z", 
    "description": "This program will modify the Automated Installer manifest files to inject personalization settings.\n\nUsage: inject_ai_personalization.py [options]\n\noptions:\n  -n HOSTNAME, --hostname=HOSTNAME\n                        Installed system hostname\n  -t TIMEZONE, --timezone=TIMEZONE\n                        Timezone for the installed system\n  -l LOCALE, --locale=LOCALE\n                        System language and locale, specified in POSIX format (eg. en_US.UTF-8)\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1370001", 
    "modified": "2014-03-10T21:37:41.000Z", 
    "name": "Inject AI Personalization Settings", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n\"\"\"\nThis program will modify the sc.xml manifest file to inject\nthe optional personalization settings for the final system.\n\nThis includes hostname, timezone and locale.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\n\nfrom osprov.profile import SCManifest\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\n\nSC_XML_PATH = \"/tmp/sc.xml\"\n\nLOG = logger.getIt(\"Inject AI Personalization settings\")\n\n\nclass InjectOptionsParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"-n\", \"--hostname\", help=\"Installed system hostname\")\n        self.add_option(\"-t\", \"--timezone\", help=\"Timezone for the installed system\")\n        self.add_option(\n            \"-l\", \"--locale\", help=\"System language and locale, specified in POSIX format (eg. en_US.UTF-8)\")\n\n\n@HandleShowErrorMessage(\"inject AI personalization\", LOG)\ndef main():\n    \"\"\"Inject AI Personalization settings.\"\"\"\n\n    opts, args = InjectOptionsParser().parse_args()\n\n    scFile = open(SC_XML_PATH, \"r\")\n    scManifest = SCManifest(scFile)\n\n    try:\n        if opts.hostname:\n            scManifest.hostname = opts.hostname\n        if opts.timezone:\n            scManifest.timezone = opts.timezone\n        if opts.locale:\n            scManifest.locale = opts.locale\n\n        scManifest.save()\n    finally:\n        scFile.close()\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "This program will modify the Automated Installer manifest files to inject personalization settings.\n\nUsage: inject_ai_personalization.py [options]\n\noptions:\n  -n HOSTNAME, --hostname=HOSTNAME\n                        Installed system hostname\n  -t TIMEZONE, --timezone=TIMEZONE\n                        Timezone for the installed system\n  -l LOCALE, --locale=LOCALE\n                        System language and locale, specified in POSIX format (eg. en_US.UTF-8)\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:41.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:41.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "This program will modify the Automated Installer manifest files to inject personalization settings.\n\nUsage: inject_ai_personalization.py [options]\n\noptions:\n  -n HOSTNAME, --hostname=HOSTNAME\n                        Installed system hostname\n  -t TIMEZONE, --timezone=TIMEZONE\n                        Timezone for the installed system\n  -l LOCALE, --locale=LOCALE\n                        System language and locale, specified in POSIX format (eg. en_US.UTF-8)\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:41.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:31:04.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:19.000Z", 
    "description": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/950001", 
    "modified": "2014-08-26T06:31:04.000Z", 
    "name": "Set Media Source", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" (c) Copyright 2009 Hewlett-Packard Development Company, L.P.\nServer script to set the media source to be used\n\"\"\"\nimport sys\nimport socket\nfrom osprov.optparse_ext import OptionParser\n\nfrom osprov import helpers\nfrom osprov import media\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.osbp import logger\n\nLOG = logger.getIt(\"set_media_source\")\n\n\nclass CustomParser(OptionParser):\n\n    \"\"\" local, custom parser \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        OptionParser.__init__(self, *args, **kwargs)\n\n    def defineOptions(self):\n        self.add_option(\"--resolve-hostname\", default=False, action=\"store_true\",\n                        dest=\"doDNS\",\n                        help=\"Forces DNS resolution at this time. Useful with installers with DNS issues.\"\n                        )\n\n    def validateArgs(self, opt, args):\n        if not args:\n            self.error(\"The URL is mandatory\")\n\n\ndef resolveHostname(parsedUrl):\n    \"\"\" Resolve the hostname in the URL to an IP address \"\"\"\n    try:\n        hostname = socket.gethostbyname(parsedUrl.hostname)\n    except socket.gaierror, why:\n        raise ShowErrorMessage(\"Could not resovle %s: %s\" % (parsedUrl.hostname, why), cause=why)\n    port = parsedUrl.port\n    if hostname != parsedUrl.hostname:\n        print \"Resolved %s to %s\" % (parsedUrl.hostname, hostname)\n    if port:\n        parsedUrl.netloc = \"%s:%s\" % (hostname, port)\n    else:\n        parsedUrl.netloc = hostname\n\n\n@HandleShowErrorMessage(\"Set Media Source\", LOG)\ndef main():\n    \"\"\" Entry point if called form the cli  \"\"\"\n    parser = CustomParser(\"usage: %prog [options] url\")\n    options, args = parser.parse_args()\n    url = media.parseUrl(args[0])\n    if options.doDNS:\n        resolveHostname(url)\n    mediaObj = media.factor(str(url), log=LOG)\n    datastore = helpers.getDataStore()\n    datastore.media.url = str(url)\n    helpers.putDataStore(datastore)\n    print \"Successfully set media source %s\" % mediaObj\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "32", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:31:04.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-08-26T06:31:04.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:19.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:34.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:55.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:16.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:35.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "6", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:55.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:17.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:37.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "9", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:12.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "10", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:34.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "11", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:49.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "12", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:18.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "13", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:53.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "14", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:18.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "15", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:42.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "16", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:05.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "17", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:28.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "18", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:58.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "19", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:24.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "20", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:46.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "21", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:08.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "22", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:28.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "23", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:52.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "24", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:11.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "25", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:29.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "26", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:51.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "27", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:12.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "28", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:32.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "29", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:49.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "30", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:08.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "31", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:26.000Z"
      }, 
      {
        "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "32", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:31:04.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:09:50.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:09:50.000Z", 
    "description": "Updates the target server's (Gen8 or above)  Intelligent Provisioning firmware with specified Intelligent Provisioning media.\n\nOptional Parameters:\n--ip_version=directory_name    The name of the directory containing the Intelligent Provisioning media to be installed, such as \"1.60\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the extracted HP Intelligent Provisioning ISO must reside on the Media Server under the \"\\Media\\ip\" directory.\n", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1540001", 
    "modified": "2014-03-28T00:09:50.000Z", 
    "name": "Update Intelligent Provisioning Firmware", 
    "source": "#!/bin/bash\n\n#(c) Copyright 2014 Hewlett-Packard Development Company, L.P.\n\nmountPoint=/mnt/media\nif [ ! -d \"$mountPoint\" ];\nthen\n   mountPoint=/mnt/ms\nfi\n\nipFolder=\"$mountPoint/Media/ip/\"\nipVersion=\n\nif [ ! -d \"$mountPoint/Media/ip\" ]; then\n   echo \"The 'Media/ip' directory was not found on the Media Server.\" 1>&2\n   echo \"Make sure that this directory exists and that a subdirectory containing the extracted Intelligent Provisioning media also exists.\" 1>&2\n   exit 2\nfi\n\n\n#Create /tmp/ip\nipInitrd=/tmp/ip\nmkdir -p $ipInitrd\n\n##############################################################################\n# This function determines which version of the IP to install.  Unless a\n# specific IP version is specifed, the latest IP, as determined by the\n# sort order, is used.\n##############################################################################\n\nfindIPVersion()\n{\n    if [ \"$ipVersion\" == \"\" ] || [ \"$ipVersion\" == \"latest\" ]\n    then\n        ipVersion=$(find \"${ipFolder}\" -mindepth 1 -maxdepth 1 -type d -printf %f\\\\n | sort | tail -1)\n\n        if [ \"$ipVersion\" == \"\" ]\n        then\n            echo \"No IP directories were found under '${ipFolder}'\" 1>&2\n            echo \"Check your media server and verify that there is at least one directory under the '/Media/ip' directory which contains the IP files\" 1>&2\n            echo \"IP directories are typically named using the IP version, for example '1.60'\" 1>&2\n            return 1\n        fi\n    fi\n\n    ipVersionDir=${ipFolder}/${ipVersion}\n\n    # Check for a valid Intelligent Provisioning firmware directory.\n    if [ ! -e \"${ipVersionDir}\" ]\n    then\n        echo \"'${ipVersionDir}' does not exist\" 1>&2\n        return 1\n    elif [ ! -d \"${ipVersionDir}\" ]\n    then\n        echo \"'${ipVersionDir}' is not a directory\" 1>&2\n        return 1\n    fi\n    \n    echo \"IP folder to use: $ipVersion\"\n    return 0\n}\n\nextractInitrd() {\n#Extract IP's initrd.img into /tmp/ip\n  cd $ipInitrd\n  xz -d < \"$ipFolder/$ipVersion/system/initrd.img\" | cpio -id\n  if [ $? != 0 ]; then\n     echo \"Unable to access files from Intelligent Provisioning media\"\n     return 1\n  fi\n\n}\n\n#Clean iLO blob store\nupdateBlob() {\n    touch /tmp/nothing\n    cd /tmp\n        hpblob -w -k SSLOCALE -f /tmp/nothing\n        hpblob -w -k SSEULA -f /tmp/nothing\n        hpblob -w -k SSERS -f /tmp/nothing\n        hpblob -w -k SSOPTIN -f /tmp/nothing\n        echo = \"<network><device>eth0</device><mode>dhcp</mode><staticip></staticip><staticmask></staticmask><staticgateway></staticgateway><staticdns></staticdns><repo_type>0</repo_type><repo_url></repo_url><proxyip></proxyip><proxyport></proxyport></network>\" > /tmp/net\n        hpblob -w -k SSNETWORK -f /tmp/net\n\n    cd $ipFolder/$ipVersion/system\n\n    temp=$(ls HPIP*|cut -d'.' -f1)\n    ipversion=${temp:4}\n    buildate=$(ls HPIP*|cut -d'.' -f2)\n    buildver=$(ls HPIP*|cut -d'.' -f3)\n    echo \"<ip><version>$ipversion</version><build_date>$buildate</build_date><build_ver>$buildver</build_ver></ip>\" > /tmp/ver.xml\n    hpblob -w -k SMARTSTART_FLASH -f /tmp/ver.xml\n    cd $ipInitrd\n}\n\n#Enable ilo devices\nenableiLOdevices() {\n  xmlsmif < $ipInitrd/etc/gaiusmount.xml > /dev/null\n  if [ \"$?\" -ne \"0\" ]; then\n     echo \"Unable to enable iLO Devices\"\n     return 1\n  fi\n}\n\n\n##############################################################################\n# Main Routine\n##############################################################################\n\necho \"Parameters to script => ${*}\"\n\n# Parse the command line arguments.\nlastOpt=\nfor arg in $*\ndo\n    optName=`echo $arg | awk -F'=' '{print $1;}'`\n    optValue=${arg:$((${#optName}+1))}\n\n    if [ \"${optName}\" == \"--ip_version\" ]; then\n\n        if [[ ! \"${optValue}\" =~ [^[:space:]] ]]\n        then\n            echo \"Missing argument to '--ip_version'\" 1>&2\n            exit 1\n        fi\n\n        ipVersion=${optValue}\n\n        lastOpt=\n    else\n        echo \"invalid option '${optName}'\" 1>&2\n        exit 1\n    fi\ndone\n\n#Locate the IP Version to use\nfindIPVersion\nif [ $? -ne 0 ]\nthen\n  exit 1\nfi\n\n# Extract the IP provided initrd to get needed files\nextractInitrd\nif [ $? -ne 0 ]\nthen\n  exit 2\nfi\n\n#Do necessary soft links\nexport PATH=$PATH:$ipInitrd/bin\nexport LD_LIBRARY_PATH=$ipInitrd/usr/lib64\n\n#simple hack to avoid unwanted plymouth not found error messages\necho > $ipInitrd/bin/plymouth\nchmod 755 $ipInitrd/bin/plymouth\n\n#Enable iLO Devices\nenableiLOdevices\nif [ $? -ne 0 ]\nthen\n  exit 2\nfi\n\n#Update HP Blob store to reset values\n#No error checking done here\nupdateBlob\n\n\n#Start the actual Update process\ngaius $ipFolder/$ipVersion/ip/gaius.img.gz $ipFolder/$ipVersion/ip/vid.img.gz\nif [ $? != 0 ]; then\n   echo \"Updating Intelligent Provisioning failed...\"\n   exit 9\nfi\nsync\n\nexit 0\n\n", 
    "state": null, 
    "version": {
      "usage": "Updates the target server's (Gen8 or above)  Intelligent Provisioning firmware with specified Intelligent Provisioning media.\n\nOptional Parameters:\n--ip_version=directory_name    The name of the directory containing the Intelligent Provisioning media to be installed, such as \"1.60\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the extracted HP Intelligent Provisioning ISO must reside on the Media Server under the \"\\Media\\ip\" directory.\n", 
      "current": true, 
      "versionLabel": "22", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:09:50.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-28T00:09:50.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Updates the target server's (Gen8 or above)  Intelligent Provisioning firmware with specified Intelligent Provisioning media.\n\nOptional Parameters:\n--ip_version=directory_name    The name of the directory containing the Intelligent Provisioning media to be installed, such as \"1.60\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the extracted HP Intelligent Provisioning ISO must reside on the Media Server under the \"\\Media\\ip\" directory.\n", 
        "current": true, 
        "versionLabel": "22", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:50.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:11:35.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:11:34.000Z", 
    "description": "This script will set one time PXE boot.  It is intended for servers migrated from IC Server Deployment.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1600001", 
    "modified": "2014-03-28T00:11:35.000Z", 
    "name": "Set One Time PXE Boot", 
    "source": "#!/bin/sh\n# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\n# Script uses the /sbin/hpbootcfg utility to set a one time PXE boot\n\nif [ -x /sbin/hpbootcfg ]; then\n  /sbin/hpbootcfg -P\n  if [ $? -ne 0 ]; then\n     echo \"Setting of one time PXE boot failed\"\n     exit 1\n  fi\nelse\n  echo \"Required utility /sbin/hpbootcfg does not exist\"\n  exit 1\nfi", 
    "state": null, 
    "version": {
      "usage": "This script will set one time PXE boot.  It is intended for servers migrated from IC Server Deployment.", 
      "current": true, 
      "versionLabel": "17", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:11:34.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-28T00:11:35.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "This script will set one time PXE boot.  It is intended for servers migrated from IC Server Deployment.", 
        "current": true, 
        "versionLabel": "17", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:34.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:11:04.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:22.000Z", 
    "description": "Captures or sets the target server's Smart Array configuration using the hpssascripting utility.\n\nRequired Parameters:\nTo capture: -c output_filename (-internal | external) (-nofail)\nTo set: -i input_filename  (-internal | external) (-reset) (-nofail)\n-nofail is indicated if the script should not fail if a Smart Array controller is not found.\n\nCustom Attribute: None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1010001", 
    "modified": "2014-03-28T00:11:04.000Z", 
    "name": "Manage Smart Array Configuration", 
    "source": "#!/bin/sh\n\n# (c) Copyright 2012-2014 Hewlett-Packard Development Company, L.P.\n\n# ======================================================================\n# Reads/Writes HP Smart Array configuration\n#\n# Capture parameters: -c output.ini [-internal | -external] [-nofail]\n# Deploy parameters: -i input.ini [-internal | -external] [-reset] [-nofail]\n# ======================================================================\n\nUSAGE=\"usage: $(basename $0) {-c|-i} cfg.ini [-options] [-nofail]\"\n\n# expected location of the installed HP HPSSACLI utilities\nDIR=\"/tmp/sstk/hpssacli\"\nHPSSACLI=\"${DIR}/hpssacli\"\nHPSSASCRIPTING=\"${DIR}/hpssascripting\"\n\n# In the PXE-booted Linux service OS, the \"tr\" command\n# is in a non-standard directory.  Set PATH for \"tr\".\nexport PATH=${PATH}:/opt/opsware/agent/osprov/bin/x86\n\n# Required libraries for HP SSACLI utilities\nexport LD_LIBRARY_PATH=\"$DIR\"\n\n# for each HPSSA utility:\n# - verify existence\n# - ensure executable\nfor UTIL in \"$HPSSACLI\" \"$HPSSASCRIPTING\"\ndo\n    # verify Existence\n    if [ ! -e \"$UTIL\" ]; then\n\techo \"$UTIL can not be found\" 1>&2\n\texit 1\n    fi\n    # ensure utility has eXecute permission\n    [ -x \"$UTIL\" ] || chmod +x \"$UTIL\"\ndone\n\n# specify scripting mode: -c (capture) | -i (input)\nMODE=${1:?$USAGE}\nshift\n\n# specify full path for configuration filename on target system\nCFG_FILE=${1:?$USAGE}\nshift\n\n# specify full path for error log file on target system\nERR_FILE=\"$DIR/error.log\"\n\n# validate supported mode\nif [ \"$MODE\" != \"-c\" ] && [ \"$MODE\" != \"-i\" ]; then\n    echo $USAGE 1>&2\n    exit 1\nfi\n\n# Parse additional args\nwhile [ \"$1\" != \"\" ] ; do\n    case $1 in\n    -internal|-external)\n        OPT3=$1\n\t;;\n    -reset)\n        OPT4=$1\n        ;;\n    -nofail)\n        NOFAIL=true\n        ;;\n     *)\n        echo $USAGE 1>&2\n        exit 1\n     esac\n     shift\ndone\n\n# Check for presence of controller we can reset.\nif ! $HPSSACLI controller all show > /dev/null ; then\n    echo \"No controller found. Exiting..\"\n    #No controller was found now check to see if we need to\n    #signal an error\n    if [ \"$NOFAIL\" == \"\" ]; then\n\t# nofail wasn't set, so fail\n\texit 1\n    else\n\t# nofail was set, so we can quit but signal success.\n\texit 0\n    fi\nfi\n\n# a logical drive with OS Status of LOCKED can't be reset\n# unmount logical drives to avoid error 3036 in use by OS\n\n# Run the unmount from the osprov lib.\nPYTHONPATH=/opt/opsware/pylibs2/ /opt/opsware/agent/bin/python -c \"from osprov.diskmgr.diskmanager import DiskManager; dm = DiskManager(); dm.disable_automount(); dm.unmountDisks(skipUsb=True)\"\n\n# also force unmount, to ensure everything is unmounted\nDEVS=`($HPSSACLI controller all show config detail | grep 'Mount Points' | sed -e 's/.*Mount Points:\\(.*\\)/\\1/' | tr , '\\012' | cut -d' ' -f2) 2>/dev/null`\n[ -n \"$DEVS\"  -a \"$DEVS\" != \"None\" ] && umount -v $DEVS 2>/dev/null\n\n# remove any leftover error log file; don't want old errors\nrm -f \"$ERR_FILE\"\n\n# run utility\n\"$HPSSASCRIPTING\" $MODE \"$CFG_FILE\" $OPT3 $OPT4 -e \"$ERR_FILE\"\nrc=$?\n\ncase $rc in\n   0 )\n      echo \"$HPSSASCRIPTING successful\";;\n   * )\n      # output error log on stderr\n      [ -e \"$ERR_FILE\" ] && cat \"$ERR_FILE\" 1>&2\n      echo \"$HPSSASCRIPTING failed ($rc)\" 1>&2;;\nesac\nexit $rc", 
    "state": null, 
    "version": {
      "usage": "Captures or sets the target server's Smart Array configuration using the hpssascripting utility.\n\nRequired Parameters:\nTo capture: -c output_filename (-internal | external) (-nofail)\nTo set: -i input_filename  (-internal | external) (-reset) (-nofail)\n-nofail is indicated if the script should not fail if a Smart Array controller is not found.\n\nCustom Attribute: None", 
      "current": true, 
      "versionLabel": "3", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:11:04.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-28T00:11:04.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Execute hpacuscripting for Smart Array configuration management to either capture or deploy a configuration.\n\nArguments:\n$1 = mode switch: capture (-c) | input (-i)\n$2 = input/output configuration filename\n$3 = (optional) [-internal | -external]\n$4 = (optional, -i only) [-reset]\n$5 = (optional) [-nofail]\n\nDependencies:\nRelies upon hpacuscripting utility provided by ProLiant Scripting Toolkit installed to /tmp/sstk/.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:22.000Z"
      }, 
      {
        "usage": "Captures or sets the target server's Smart Array configuration using the hpssascripting utility.\n\nRequired Parameters:\nTo capture: -c output_filename (-internal | external) (-nofail)\nTo set: -i input_filename  (-internal | external) (-reset) (-nofail)\n-nofail is indicated if the script should not fail if a Smart Array controller is not found.\n\nCustom Attribute: None", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:10:09.000Z"
      }, 
      {
        "usage": "Captures or sets the target server's Smart Array configuration using the hpssascripting utility.\n\nRequired Parameters:\nTo capture: -c output_filename (-internal | external) (-nofail)\nTo set: -i input_filename  (-internal | external) (-reset) (-nofail)\n-nofail is indicated if the script should not fail if a Smart Array controller is not found.\n\nCustom Attribute: None", 
        "current": true, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:04.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:26.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:26.000Z", 
    "description": "Will inject the personalization settings into the necessary configuration files from the default jumpstart.\n\nusage: install_jumpstart_personalization.py\n\noptions:\n  -b BOOTOPTIONS, --bootOptions=BOOTOPTIONS\n                        Specifies Solaris kernel arguments\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition', 'Configure Solaris 10 Default Jumpstart', 'Inject Required Jumpstart Settings'", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1090001", 
    "modified": "2014-03-10T21:37:26.000Z", 
    "name": "Inject Jumpstart Personalization Settings", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n\"\"\"\nWill inject the personalization settings into the necessary\nconfiguration files from the default jumpstart.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nfrom osprov import helpers, media\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import DiscoveryError\nfrom osprov.osbp import logger\nfrom osprov.parsers.jumpstart import JumpstartParser\nfrom osprov.optparse_ext import OptionParser\n\nLOG = logger.getIt(\"Inject Jumpstart Personalization Settings\")\n\n\nclass InjectPersonalizationJumpstartOptionParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"-b\", \"--bootOptions\", dest=\"boot_options\",\n                        default=\"\", help=\"Specifies Solaris kernel arguments\")\n\n\ndef injectBootOptions(jumpstartDir, bootOptions, jumpstartParser):\n    \"\"\"Injecting the Solaris kernel parameters\"\"\"\n    finishFilePath = os.path.join(jumpstartDir, \"finish\")\n    if not os.path.exists(finishFilePath):\n        raise DiscoveryError(\n            \"The post-installation script was not found! There was a problem injecting the required settings.\")\n    jumpstartParser.data[\"finish\"] = jumpstartParser.data[\"finish\"].replace(\n        \"\"\"BOOT_OPTS=\"kernel/unix\\\"\"\"\", \"\"\"BOOT_OPTS=\"kernel/unix %s\\\"\"\"\" % bootOptions)\n    writeToFile(finishFilePath, jumpstartParser.toString(\"finish\"))\n\n\ndef writeToFile(pathToFile, content):\n    fd = open(pathToFile, \"wb+\")\n    fd.write(content)\n    fd.close()\n    LOG.debug(\"File %s : \\n%s\" % (pathToFile, content))\n\n\n@HandleShowErrorMessage(\"Inject Jumpstart Personalization Settings\", LOG)\ndef main():\n    \"\"\"Injecting personalized settings for installer and production Solaris10\"\"\"\n    options, args = InjectPersonalizationJumpstartOptionParser().parse_args()\n    keys = helpers.getDataStore()\n    stubMountpoint = keys.disk.device_mount\n    jumpstartDir = os.path.join(stubMountpoint, \"jumpstart\")\n    if not os.path.exists(jumpstartDir):\n        raise DiscoveryError(\n            \"Jumpstart target location was not found! There was a problem injecting the required settings.\")\n\n    defaultJumpstart = \"/tmp/default_jumpstart.txt\"\n    jumpstartParser = JumpstartParser.Readonly(open(defaultJumpstart))\n    jumpstartParser.info()\n    injectBootOptions(jumpstartDir=jumpstartDir,\n                      bootOptions=options.boot_options, jumpstartParser=jumpstartParser)\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Will inject the personalization settings into the necessary configuration files from the default jumpstart.\n\nusage: install_jumpstart_personalization.py\n\noptions:\n  -b BOOTOPTIONS, --bootOptions=BOOTOPTIONS\n                        Specifies Solaris kernel arguments\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition', 'Configure Solaris 10 Default Jumpstart', 'Inject Required Jumpstart Settings'", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:26.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:26.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Will inject the personalization settings into the necessary configuration files from the default jumpstart.\n\nusage: install_jumpstart_personalization.py\n\noptions:\n  -b BOOTOPTIONS, --bootOptions=BOOTOPTIONS\n                        Specifies Solaris kernel arguments\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition', 'Configure Solaris 10 Default Jumpstart', 'Inject Required Jumpstart Settings'", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:26.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:10:09.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:10:09.000Z", 
    "description": "Resets the target server's BIOS system configuration to factory default settings using the rbsureset utility.\n\nParameters: None\n\nCustom Attribute: None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1560001", 
    "modified": "2014-03-28T00:10:09.000Z", 
    "name": "Reset System Configuration", 
    "source": "#!/bin/sh\n\n# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nUTIL=rbsureset\nDIR=\"/tmp/sstk\"\n\nif [ ! -f \"$DIR/$UTIL\" ]; then\n   echo \"$DIR/$UTIL can not be found\" 1>&2\n   exit 1\nfi\n\nchmod +x \"$DIR/$UTIL\"\n\n# Run Utility\n\"$DIR/$UTIL\"\nrc=$?\n\ncase $rc in\n   0 )\n      echo \"$UTIL successful\";;\n   127 )\n      echo \"$UTIL failed ($rc): Missing library in automation\" 1>&2;;\n   * )\n      echo \"$UTIL failed ($rc)\" 1>&2 ;;\nesac\nexit $rc", 
    "state": null, 
    "version": {
      "usage": "Resets the target server's BIOS system configuration to factory default settings using the rbsureset utility.\n\nParameters: None\n\nCustom Attribute: None", 
      "current": true, 
      "versionLabel": "8", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:10:09.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-28T00:10:09.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Resets the target server's BIOS system configuration to factory default settings using the rbsureset utility.\n\nParameters: None\n\nCustom Attribute: None", 
        "current": true, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:10:09.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:52.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:18:52.000Z", 
    "description": "Adds a target server running a Windows production OS to a Domain.  A reboot is required after this script is run.\nRequirements:  DNS needs to be configured on the target server\nParameters:  None\nRequired Custom Attributes:\n\u2022         DomainFQDN\n\u2022         DomainName\n\u2022         DomainUser\n\u2022         DomainPassword (plain text)\n\u2022         EncryptedDomainPassword (encrypted)\n\u2022         Key\n", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1770001", 
    "modified": "2014-03-28T00:18:52.000Z", 
    "name": "Add Windows Server to Domain", 
    "source": "set DOMAIN=@DomainName@\nset DNSDOMAIN=@DomainFQDN@\nset DOMAINUSERROOT=@DomainUser@\nset DOMAINPASS=@DomainPassword@\nset KEY=@Key@\nset ENCYPTPASSWORD=@EncryptedDomainPassword@\n;@Findstr -bv ;@F \"%~f0\" |powershell.exe -ExecutionPolicy Unrestricted -NoLogo -NonInteractive -NoProfile -Command - & ;exit $LastExitCode\n\n#######################################################\n##        Check custom attributes\n## exit the script if any custom attribute is missing \n##############################################################\nFunction checkCA\n{\n    if (!$domain)\n    {\n        write-host \"Please provide a value for custom attribute 'DomainName' to proceed\"\n        Exit 3\n    }\n    elseif (!$dnsdomain)\n    {\n        write-host \"Please provide a value for custom attribute 'DomainFQDN' to proceed\"\n        Exit 3\n    }\n    elseif (!$domainuserroot)\n    {\n        write-host \"Please provide a value for custom attribute 'DomainUser' to proceed\"\n        Exit 3\n    }\n        \n}\n\n\n################################################################################\n#        Check DNS\n# check if DNS is configure. If DNS IP not found exit the script\n##################################################################################\nFunction checkDNS\n{\n    $colItems = Get-WmiObject Win32_NetworkAdapterConfiguration -Namespace \"root\\CIMV2\" | where{$_.IPEnabled -eq \"True\"}\n    if(!$colItems.DNSServerSearchOrder)\n    {\n        write-host \"ERROR: The target server is not configured with any DNS servers. This is required for adding to a domain.\"\n        Exit 5\n    }\n    \n}\n\n######################################################################################\n#        getCredobj\n#######################################################################################\nFunction getCredobj\n{\n    if ($key -and $encryptpassword)\n    {\n        $keyarr=$key.tocharArray()\n        $securepass = ConvertTo-SecureString -String $encryptpassword -key $keyarr\n        if ($?)\n        {\n        write-host \"Created secure string successfully from encrypted string\"\n        }\n        else\n        {\n        write-host \"ERROR:Creating secure sting from encrypted string failed.\"\n        Exit 2\n        }\n    }\n    elseif ($domainpass)\n    {\n        #No Key/Encrypted password specified using domain password as plain text\n        #\n        $securepass = ConvertTo-SecureString  $domainpass -AsPlainText -force\n        if ($?)\n        {\n        write-host \"Created secure string successfully\"\n        }\n        else\n        {\n        write-host \"ERROR: Creating secure string from plain text failed.\"\n        Exit 2\n        }\n    }\n    else\n    {\n        write-host \"Error: \"Please provide value for custom attribute Key/EncryptedDomainPassword or DomainPassword to proceed.\n        Exit 2\n    }\n    $cred = New-Object System.Management.Automation.PSCredential($domainUser,$securePass)\n    if ($?)\n    {\n        write-host \"created DomainCred obj.\"\n        return $cred\n    }\n    else\n    {\n        write-host \"Fail to create DomainCred obj.\"\n        Exit 2\n    }\n}\n\n######################################################################################\n#        Add-Computer\n#######################################################################################\nFunction addComp\n{\n\nAdd-Computer -DomainName $dnsdomain -Credential $domaincred \nif ($?)\n    {\n    write-host \"System moved to $DNSDomain Successfully\"\n    }\nelse\n    {\n    write-host \"ERROR: Script failed to moved system under $DNSDomain. Please check more error details at %windir%\\debug\\NetSetup.txt on target\"\n    Exit 1\n    }\n    \n}\n\n\n#################################\n##    Main\n############################\n\n$domain=$env:DOMAIN\nwrite-host \"Your Domain: $domain\"\n   \n$dnsdomain = $env:DNSDOMAIN\nwrite-host \"Your DNS: $dnsdomain\"\n\n$domainuserroot = $env:DOMAINUSERROOT\nwrite-host \"User: $domainuserroot\"\n\n$key=$env:KEY\n$domainpass = $env:DOMAINPASS\n$encryptpassword=$env:ENCYPTPASSWORD\n#Checking for customattribute\ncheckCA\ncheckDNS\n$domainuser = $domain+'\\'+$domainuserroot \nwrite-host \"$domainuser\"\n\n#get Credential object\n$domaincred=getCredobj\n#Call Add-Computer\naddComp", 
    "state": null, 
    "version": {
      "usage": "Adds a target server running a Windows production OS to a Domain.  A reboot is required after this script is run.\nRequirements:  DNS needs to be configured on the target server\nParameters:  None\nRequired Custom Attributes:\n\u2022         DomainFQDN\n\u2022         DomainName\n\u2022         DomainUser\n\u2022         DomainPassword (plain text)\n\u2022         EncryptedDomainPassword (encrypted)\n\u2022         Key\n", 
      "current": true, 
      "versionLabel": "22", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:52.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-28T00:18:52.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Adds a target server running a Windows production OS to a Domain.  A reboot is required after this script is run.\nRequirements:  DNS needs to be configured on the target server\nParameters:  None\nRequired Custom Attributes:\n\u2022         DomainFQDN\n\u2022         DomainName\n\u2022         DomainUser\n\u2022         DomainPassword (plain text)\n\u2022         EncryptedDomainPassword (encrypted)\n\u2022         Key\n", 
        "current": true, 
        "versionLabel": "22", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:52.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:36:48.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:48.000Z", 
    "description": "Adds the Hyper-V Role to the Windows Installation. After the role is added the machine is rebooted to re-configure the system.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/510001", 
    "modified": "2014-03-10T21:36:48.000Z", 
    "name": "Add Hyper-V Role", 
    "source": "@echo off\n\n:: (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nset wdir=%windir%\nset FEATURE=Hyper-V\nset RESULTFILE=\"%wdir%\\HVInstallResult.xml\"\n\n:: Try PowerShell if exists\nfor %%X in (powershell.exe) do (set FOUND1=%%~$PATH:X)\nif defined FOUND1 (\n   echo Import-module servermanager > \"%wdir%\\FeatureInstall.ps1\"\n   echo add-windowsfeature -Name %FEATURE% -logPath %RESULTFILE% -Restart >> \"%wdir%\\FeatureInstall.ps1\"\n   powershell.exe -ExecutionPolicy Unrestricted -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -File \"%wdir%\\FeatureInstall.ps1\"\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n)\n\n:: Try ServerManagerCmd if exists and PowerShell wasn't found\nfor %%X in (ServerManagerCmd.exe) do (set FOUND2=%%~$PATH:X)\nif defined FOUND2 (\n   ServerManagerCmd.exe -install %FEATURE% -resultPath %RESULTFILE%\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n) \n\nif NOT defined rc (\n   echo PowerShell and ServerManagerCmd were not found and could not set %FEATURE%\n   set rc=999\n   goto End\n)\n\n:EndWithFailureMessage\nif NOT %rc%==0 (\n   echo PowerShell and ServerManagerCmd Add Windows Feature failed to install %FEATURE%:  error code %rc%\n   echo Refer to %RESULTFILE% log file.\n)\n\n:End\nexit /B %rc%", 
    "state": null, 
    "version": {
      "usage": "Adds the Hyper-V Role to the Windows Installation. After the role is added the machine is rebooted to re-configure the system.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:36:48.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-10T21:36:48.000Z", 
    "runAsSuperUser": false, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Adds the Hyper-V Role to the Windows Installation. After the role is added the machine is rebooted to re-configure the system.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:48.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:50.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:35.000Z", 
    "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/300001", 
    "modified": "2014-08-26T06:30:50.000Z", 
    "name": "Install bootloader for RedHat Enterprise Linux Server", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nThis python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, NotFoundError, ShowErrorMessage\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import Netconfig\nfrom osprov.parsers.netconfig import getActiveInterface\nfrom osprov.server import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n# for easier mocking\n\n\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef readFile(filepath):\n    \"\"\"Reads from the file identified by filepath\"\"\"\n    return open(filepath).read()\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATH = \"boot/grub/menu.lst\"\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\" % (source, destination))\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATH = os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\")\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                      % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                         'bootDiskMount': bootDiskMount,\n                         'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                         'bootDisk': bootDisk}, log=LOG, quiet=True)\n        # configure the UEFI boot entries\n        osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    search -n -u %(device_uuid)s -s\n    linux  /%(kernel)s %(kernelArguments)s\n    initrd %(initrds)s\n}\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef configureKernelArguments(osdata, keys, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    os_version = osdata[\"os_version\"]\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in os_version and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    netconfig_ca = StringIO(\"\"\"@hpsa_netconfig@\"\"\")\n    parser = Netconfig.readonly(netconfig_ca)\n    try:\n        activeKey, activeIface = getActiveInterface(localServer, parser.info())\n    except NotFoundError:\n        activeIface = None\n    ip_params = \"\"\n    if activeIface and activeIface.static:\n        net_data = {\n            \"ip\": activeIface.ip[0],\n            \"mask\": activeIface.mask[0],\n            \"dns\": \"\",\n            \"gw\": \"\",\n        }\n        # Static provisioning\n        if hasattr(activeIface, \"dns\") and activeIface.dns:\n            net_data[\"dns\"] = activeIface.dns[0]\n        if hasattr(activeIface, \"gw\"):\n            net_data[\"gw\"] = activeIface.gw[0]\n        ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n    else:\n        # dhcp provisioning\n        ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if not osdata.has_key(\"initrd\"):\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = \"RedHat Enterprise Linux Server\"\n    osdata[\"os_version\"] = \"RHEL\"\n    osdata[\"install_params\"] = \"ks=file:/user.ks.cfg  ksdevice=%(mac)s\"\n    osdata[\"ip_config_static\"] = \"ip=%(ip)s gateway=%(gw)s netmask=%(mask)s\"\n    osdata[\"ip_config_dhcp\"] = \"ip=dhcp noipv6\"\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n\n    _open(os.path.join(bootDiskMount, grub.MENU_PATH), \"w\").write(menu)\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "8", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:50.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-08-26T06:30:50.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:36.000Z"
      }, 
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:08.000Z"
      }, 
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:57.000Z"
      }, 
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:21.000Z"
      }, 
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:45.000Z"
      }, 
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "6", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:08.000Z"
      }, 
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:31.000Z"
      }, 
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:50.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:27.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:15:09.000Z", 
    "description": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1650001", 
    "modified": "2014-03-28T00:18:27.000Z", 
    "name": "Validate ImageX Package Contents", 
    "source": "@echo off\r\n\r\n:: (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\r\n\r\nset imagexValidated=0\r\n\r\nREM When run from production Windows, this script expects that the ImageX package \r\nREM was previously extracted to \"\\HPPROVTEMP\" on the system drive so that its\r\nREM contents can be checked to see if 'imagex.exe' present.\r\nREM\r\nREM WARNING: DO NOT CHANGE THIS DIRECTORY. IT AND ITS SUBDIRECTORIES AND FILES\r\nREM          ARE RECURSIVELY REMOVED AT THE END OF THIS SCRIPT.  SPECIFYING\r\nREM          A DIFFERENT DIRECTORY MAY CAUSE DAMAGE TO YOUR SYSTEM.\r\nset hpProvTempDir=%SystemDrive%\\HPPROVTEMP\r\n\r\nREM In WinPE, it is expected that \"imagex.exe\" will always be extracted to\r\nREM the \"X:\\Windows\\System32\".\r\nset winPeSystemDir=X:\\Windows\\System32\r\n\r\nREM If the ImageX package was extracted to \"\\HPPROVTEMP\", then the directory will exist.\r\nif exist \"%hpProvTempDir%\" (\r\n    REM Check if 'imagex.exe' is in the ImageX package.  The ImageX package\r\n    REM will not contain 'imagex.exe' until WinPE is uploaded to the appliance.\r\n    if exist \"%hpProvTempDir%\\imagex.exe\" (\r\n        echo '%hpProvTempDir%\\imagex.exe' exists\r\n\r\n        set imagexValidated=1\r\n    ) else (\r\n        echo '%hpProvTempDir%\\imagex.exe' was not found\r\n    )\r\n\r\n    echo Removing directory '%hpProvTempDir%'\r\n\r\n    REM Remove the temporary directory where the ImageX package contents were\r\n    REM extracted to.\r\n    rmdir /S /Q %hpProvTempDir%\r\n\r\n    if %errorlevel% neq 0 (\r\n        echo Failed to remove '%hpProvTempDir%' 1>&2\r\n    )\r\n)\r\n\r\nREM If \"imagex.exe\" was not extracted to \"\\HPPROVTEMP\" on the system drive of\r\nREM the production OS, then check for it in \"X:\\Windows\\System32\", in case we're\r\nREM in WinPE.\r\nif \"%imagexValidated%\" == \"0\" (\r\n    if exist \"%winPeSystemDir%\" (\r\n        if exist \"%winPeSystemDir%\\imagex.exe\" (\r\n            echo '%winPeSystemDir%\\imagex.exe' exists\r\n\r\n            set imagexValidated=1\r\n        ) else (\r\n            echo '%winPeSystemDir%\\imagex.exe' was not found.\r\n        )\r\n    ) else (\r\n        echo The directory '%winPeSystemDir%' does not exist.\r\n    )\r\n)\r\n\r\nif \"%imagexValidated%\" == \"1\" (\r\n    exit /B 0\r\n) else (\r\n    echo The ImageX package in this Build Plan does not contain 'imagex.exe'. 1>&2\r\n    echo In order to add 'imagex.exe' to the ImageX package, WinPE must be 1>&2\r\n    echo uploaded to the appliance. 1>&2\r\n\r\n    exit /B 1\r\n)\r\n\r\n", 
    "state": null, 
    "version": {
      "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.", 
      "current": true, 
      "versionLabel": "8", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:27.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-28T00:18:27.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:09.000Z"
      }, 
      {
        "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:29.000Z"
      }, 
      {
        "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:12.000Z"
      }, 
      {
        "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:30.000Z"
      }, 
      {
        "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.", 
        "current": false, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:33.000Z"
      }, 
      {
        "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.", 
        "current": false, 
        "versionLabel": "6", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:50.000Z"
      }, 
      {
        "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:09.000Z"
      }, 
      {
        "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.", 
        "current": true, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:27.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:33.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:33.000Z", 
    "description": "Will create the necessary files and will aggregate them into a .tar file\nneeded in the Jumpstart installation process of Solaris 10 x86 over NFS.\nContents of these files is present in the default jumpstart configuration template.\n\nusage: install_required_jumpstart.py\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition' and 'Configure Solaris 10 Default Jumpstart'", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1220001", 
    "modified": "2014-03-10T21:37:33.000Z", 
    "name": "Inject Required Jumpstart Settings", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n\"\"\"\nWill install create the necessary files and will aggregate them into a .tar file\nneeded in the Jumpstart installation process of Solaris 10 x86 over NFS. Contents of these files\nis present in the default jumpstart configuration template.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nimport tarfile\nimport shutil\n\nfrom osprov import helpers, media\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import NotSupportedError, DiscoveryError\nfrom osprov.osbp import logger\nfrom osprov.server import ThisLocalServer\nfrom osprov.parsers.jumpstart import JumpstartParser\nfrom osprov.netconfig.solaris import NetworkInterface\n\nLOG = logger.getIt(\"Inject Required Jumpstart\")\n\n\ndef createSysidcfg(jumpstartDir, sysidcfgDict, parserObj, targetServer):\n    \"\"\" Creates the sysidcfg file in the jumpstart directory on the mounted path \"\"\"\n    sysidcfgPath = os.path.join(jumpstartDir, \"sysidcfg\")\n    # verify that necessary items are in place & assemble file\n    mandatoryKeys = [\"network_interface\", \"system_locale\", \"timezone\", \"timeserver\", \"nfs4_domain\"]\n    for key in mandatoryKeys:\n        if not sysidcfgDict.has_key(key):\n            raise DiscoveryError(\n                \"The following setting : %s is needed in order for the installation to work\" % key)\n\n    # inject active network interface\n    macAddress = targetServer.getMACAddress()\n    networkIf = NetworkInterface(macAddress=macAddress)\n    deviceName = networkIf.getDeviceName()\n    LOG.debug(\"Discovered network interface %s with MAC address %s\" % (deviceName, macAddress))\n\n    # delete network_interface with value primary, this is not supported when\n    # configuring another specific interface\n    if parserObj.data[\"sysidcfg\"][\"network_interface\"].has_key('primary'):\n        LOG.debug(\"Discovered network_interface set to primary. Deleting it.\")\n        del parserObj.data[\"sysidcfg\"][\"network_interface\"]['primary']\n\n    # setting if a network interface is up the one used for communication\n    config = \"{dhcp protocol_ipv6=no}\\n\"\n    if not parserObj.data[\"sysidcfg\"][\"network_interface\"].has_key(deviceName):\n        parserObj.data[\"sysidcfg\"][\"network_interface\"][deviceName] = config\n    elif \"dhcp\" not in parserObj.data[\"sysidcfg\"][\"network_interface\"][deviceName]:\n        parserObj.data[\"sysidcfg\"][\"network_interface\"][deviceName] = config\n    LOG.debug(\"Configured interface %s with %s\" %\n              (deviceName, parserObj.data[\"sysidcfg\"][\"network_interface\"][deviceName]))\n\n    content = parserObj.toString(\"sysidcfg\")\n    writeToFile(sysidcfgPath, content)\n\n\ndef createProfile(jumpstartDir, profileDict, parserObj):\n    \"\"\" Creates the install.input file in the jumpstart directory on the mounted path \"\"\"\n    profilePath = os.path.join(jumpstartDir, \"install.input\")\n    # verify that necessary items are in place & assemble file\n    mandatoryKeys = [\"install_type\", \"partitioning\", \"system_type\"]\n    for key in mandatoryKeys:\n        if not profileDict.has_key(key):\n            raise DiscoveryError(\n                \"The following setting : %s is needed in order for the installation to work\" % key)\n    content = parserObj.toString(\"profile\")\n    writeToFile(profilePath, content)\n\n\ndef createRules(jumpstartDir):\n    \"\"\" Creates the rules file in the jumpstart directory on the mounted path \"\"\"\n    rules = os.path.join(jumpstartDir, \"rules\")\n    content = \"any - profile -\"\n    writeToFile(rules, content)\n\n\ndef createRulesok(jumpstartDir):\n    \"\"\" Creates the rules.ok file in the jumpstart directory on the mounted path \"\"\"\n    rulesok = os.path.join(jumpstartDir, \"rules.ok\")\n    content = \"\"\"probe arch\nprobe disks\nprobe domainname\nprobe hostaddress\nprobe hostname\nprobe installed\nprobe karch\nprobe memsize\nprobe model\nprobe network\nprobe osname\nprobe rootdisk\nprobe totaldisk\nany - begin = finish\n# version=2 checksum=20755\n\"\"\"\n    writeToFile(rulesok, content)\n\n\ndef injectReqToBeginScript(jumpstartDir, parserObj, injectedValues):\n    \"\"\" Creates the begin (pre-script) file in the jumpstart directory on the mounted path \"\"\"\n    begin = os.path.join(jumpstartDir, \"begin\")\n    content = \"\"\"#!/bin/sh\necho \"Copying install.input profile ...\"\ncp /jumpstart/install.input /tmp/install.input\necho \"Remounting root ...\"\nmount -o remount,rw /\necho \"Setting up dns ...\"\ncat %(dnsSource)s > /etc/resolv.conf\ncp /etc/nsswitch.dns /etc/nsswitch.conf\necho \"Mounting install media ...\"\nnfspath=%(mediaSource)s\nmount -F nfs -o ro $nfspath /cdrom\necho $nfspath > /tmp/.netmnt\necho \"Starting Opsware OS Provisioning agent ...\"\nagwIpPort=%(agwIpPort)s\necho \"Contacting agent gateway at $agwIpPort...\"\n/bin/sh /opt/opsware/agent/osprov/ogfs-agent-setup.sh $agwIpPort\necho \"Setup done, launching OGFS agent ...\"\necho \"coglib.platform.lc_path: /opt/opsware/agent\" >> /etc/opt/opsware/agent/agent.args\n/bin/sh /opt/opsware/agent/osprov/ogfs-agent-start.sh\necho \"\" > /tmp/finish.flag\n\"\"\" % injectedValues\n    content += \"\\n\" + parserObj.toString(\"begin\")\n    parserObj.data[\"begin\"] = content\n    writeToFile(begin, content)\n\n\ndef injectReqFinishScript(jumpstartDir, parserObj):\n    \"\"\" Creates the finish (post-script) file in the jumpstart directory on the mounted path \"\"\"\n    finish = os.path.join(jumpstartDir, \"finish\")\n    content = \"\"\"#!/bin/sh\necho \"Adding kernel/unix to boot parameters ...\"\nBASE=/a\nBOOT_OPTS=\"kernel/unix\"\nexport BOOT_OPTS\nif [ -f $BASE/boot/grub/menu.lst ]; then\n    perl -p -i -e 's#^kernel(.*)multiboot#kernel$1multiboot $ENV{\"BOOT_OPTS\"}#g' $BASE/boot/grub/menu.lst\nelse\n    grep -v \"setprop boot-file \" $BASE/boot/solaris/bootenv.rc > \\\n        /tmp/bootenv$$\n    echo \"setprop boot-file '$BOOT_OPTS'\" >> /tmp/bootenv$$\n    mv /tmp/bootenv$$ $BASE/boot/solaris/bootenv.rc\nfi\n\n%s\n\necho \"Stopping installation...\"\necho \"\" > /tmp/HPSAMonitoringStop.flag\nwhile [ -f /tmp/finish.flag ]; do sleep 1; done\n\"\"\" % parserObj.toString(\"finish\")\n    parserObj.data[\"finish\"] = content\n    writeToFile(finish, content)\n\n\ndef createDestAndValues(targetServer):\n    \"\"\" Creates the jumpstart directory on the mounted path and determines the necessary values that will be injected \"\"\"\n    keys = helpers.getDataStore()\n    stubMountpoint = keys.disk.device_mount\n    jumpstartDir = os.path.join(stubMountpoint, \"jumpstart\")\n    if not os.path.isdir(jumpstartDir):\n        os.makedirs(jumpstartDir)\n    LOG.debug(\"Jumpstart Configuration directory path : %s\" % str(jumpstartDir))\n\n    # finding dns values\n    resolv_file = os.path.join(jumpstartDir, \"resolv.conf\")\n    shutil.copyfile(\"/etc/resolv.conf\", resolv_file)\n\n    agwIp, agwPort = targetServer.getRandomAgentGateway()\n    urlMedia = media.parseUrl(keys.media.url)\n    injectedValues = {\n        'mediaSource': '%s:%s' % (urlMedia.netloc, urlMedia.path),\n        'agwIpPort': \"%s:%s\" % (agwIp, agwPort),\n        'dnsSource': \"/jumpstart/resolv.conf\"\n    }\n    LOG.debug(\"Determined values that will be injected : %s\" % str(injectedValues))\n    return (jumpstartDir, injectedValues)\n\n\ndef writeToFile(pathToFile, content):\n    fd = open(pathToFile, \"wb+\")\n    fd.write(content)\n    fd.close()\n    LOG.debug(\"File %s : \\n%s\" % (pathToFile, content))\n\n\n@HandleShowErrorMessage(\"Inject Required Jumpstart\", LOG)\ndef main():\n    \"\"\"Creates necessary files for Jumpstart installation and injects required values\"\"\"\n    if not os.uname()[-1].startswith(\"i86\"):\n        raise NotSupportedError(\"Injecting required jumpstart is not supported on SPARC.\")\n\n    defaultJumpstart = \"/tmp/default_jumpstart.txt\"\n    targetServer = ThisLocalServer()\n\n    jumpstartParser = JumpstartParser.Readonly(open(defaultJumpstart))\n    jumpstartData = jumpstartParser.info()\n    LOG.debug(\"Parsed default jumpstart: \\n%s\" % str(jumpstartData))\n\n    (jumpstartDir, injectedValues) = createDestAndValues(targetServer=targetServer)\n\n    createSysidcfg(jumpstartDir=jumpstartDir, sysidcfgDict=jumpstartData[\n                   \"sysidcfg\"], parserObj=jumpstartParser, targetServer=targetServer)\n    createProfile(jumpstartDir=jumpstartDir,\n                  profileDict=jumpstartData[\"profile\"], parserObj=jumpstartParser)\n\n    injectReqToBeginScript(\n        jumpstartDir=jumpstartDir, parserObj=jumpstartParser, injectedValues=injectedValues)\n    injectReqFinishScript(jumpstartDir=jumpstartDir, parserObj=jumpstartParser)\n\n    createRules(jumpstartDir=jumpstartDir)\n    createRulesok(jumpstartDir=jumpstartDir)\n\n    writeToFile(defaultJumpstart, jumpstartParser.extractFileContents())\n\n    LOG.info(\"Finished creating necessary files for Jumpstart installation\")\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Will create the necessary files and will aggregate them into a .tar file\nneeded in the Jumpstart installation process of Solaris 10 x86 over NFS.\nContents of these files is present in the default jumpstart configuration template.\n\nusage: install_required_jumpstart.py\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition' and 'Configure Solaris 10 Default Jumpstart'", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:33.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:33.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Will create the necessary files and will aggregate them into a .tar file\nneeded in the Jumpstart installation process of Solaris 10 x86 over NFS.\nContents of these files is present in the default jumpstart configuration template.\n\nusage: install_required_jumpstart.py\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition' and 'Configure Solaris 10 Default Jumpstart'", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:33.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:24.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:24.000Z", 
    "description": "This is a simple wrapper script to apply a WIM image using the imagex program.  \n\nUsage: IMAGEPATH [IMAGENUMBER] [TARGETDRIVE]\n\nParameters:\n  IMAGEPATH:  Required. Full local path to the WIM file to apply.\n IMAGENUMBER: image number within the WIM to apply. Default is 1.\n TARGETDRIVE: drive letter where WIM should be applied. \n              Default is \"C\" or the value of the @SystemDrive@ custom attribute.  \n\t\t\t  This should be a single letter corresponding to a valid windows drive. \n\t\t\t  Do not include a trailing colon.\n\nExample:\n apply_wim_image.cmd z:\\windows\\images\\2008.wim\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1060001", 
    "modified": "2014-03-10T21:37:24.000Z", 
    "name": "Apply WIM Image", 
    "source": "@echo off\n::Usage: apply_wim_image.cmd IMAGEPATH [IMAGENUMBER] [TARGETDRIVE]\nset SIG=WINPE\nset IMAGENUMBER=1\nset TARGETDRIVE=@SystemDrive:C@\n\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif not exist %1 (\n    echo image file %1 missing! Cannot apply image.\n\texit /B 2\n)\nif not X%2==X (\n    set IMAGENUMBER=%2\n)\nif not X%3==X (\n    set TARGETDRIVE=%3\n)\n\nif \"%TARGETDRIVE%\"==\"C\" goto have_targetdrive\nif \"%TARGETDRIVE%\"==\"c\" goto have_targetdrive\necho Only C: drive deploy is supported\n\n:have_targetdrive\n\n::start \"Applying WIM Image\" /wait cmd /c imagex /verify /scroll /apply %1 %IMAGENUMBER% %TARGETDRIVE%:\necho Applying WIM Image %1 to drive %TARGETDRIVE%: (Image Number %IMAGENUMBER%)\nimagex /check /verify /scroll /apply %1 %IMAGENUMBER% %TARGETDRIVE%:\n\nif %ERRORLEVEL% == 0 (\n    echo Image applied successfully\n) else (\n    echo ERROR: imagex exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n\nif exist %TARGETDRIVE%:\\Windows\\System32\\bcdboot.exe (\n\techo Running bcdboot against %TARGETDRIVE%:\\Windows\n\tcopy %TARGETDRIVE%:\\Windows\\System32\\bcdboot.exe %temp%\n    %temp%\\bcdboot.exe %TARGETDRIVE%:\\Windows /s %TARGETDRIVE%:\n)\n", 
    "state": null, 
    "version": {
      "usage": "This is a simple wrapper script to apply a WIM image using the imagex program.  \n\nUsage: IMAGEPATH [IMAGENUMBER] [TARGETDRIVE]\n\nParameters:\n  IMAGEPATH:  Required. Full local path to the WIM file to apply.\n IMAGENUMBER: image number within the WIM to apply. Default is 1.\n TARGETDRIVE: drive letter where WIM should be applied. \n              Default is \"C\" or the value of the @SystemDrive@ custom attribute.  \n\t\t\t  This should be a single letter corresponding to a valid windows drive. \n\t\t\t  Do not include a trailing colon.\n\nExample:\n apply_wim_image.cmd z:\\windows\\images\\2008.wim\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:24.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-10T21:37:24.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "This is a simple wrapper script to apply a WIM image using the imagex program.  \n\nUsage: IMAGEPATH [IMAGENUMBER] [TARGETDRIVE]\n\nParameters:\n  IMAGEPATH:  Required. Full local path to the WIM file to apply.\n IMAGENUMBER: image number within the WIM to apply. Default is 1.\n TARGETDRIVE: drive letter where WIM should be applied. \n              Default is \"C\" or the value of the @SystemDrive@ custom attribute.  \n\t\t\t  This should be a single letter corresponding to a valid windows drive. \n\t\t\t  Do not include a trailing colon.\n\nExample:\n apply_wim_image.cmd z:\\windows\\images\\2008.wim\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:24.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:31:03.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:09:13.000Z", 
    "description": "Reports the results of the SPP installation, by collecting the HP SUM return code from a file left behind by the \"Install Windows SPP In Background\" step.\n\nOptions:\n    --fail_on_warning  Causes the build plan step to fail if the HP SUM return code is -3, which means that there were some components that could not be installed.\n\nRequirements:\n* The \"Install Windows SPP In Background\" step must have been previously run.\n", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1510001", 
    "modified": "2014-08-26T06:31:03.000Z", 
    "name": "Report Windows SPP Installation Results", 
    "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(c) Copyright 2014 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport os\nfrom optparse import OptionParser\n\nwindowsSystemDrive = os.getenv(\"SystemDrive\")\nwindowsTempDir = windowsSystemDrive + \"\\\\Windows\\\\Temp\"\nlocalHpSumDir = windowsTempDir + \"\\\\LocalHpSum\"\nicspTempDir = windowsTempDir + \"\\\\icsp\"\nhpSumExitCodeFile = icspTempDir + \"\\\\hpsum_exit_code.txt\"\n\n##############################################################################\n# Parses the command line arguments.\n##############################################################################\n\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--fail_on_warning\",\n            action = \"store_true\",\n            default = False,\n            dest = \"failOnWarning\",\n            help=\"Causes the build plan step to fail if hpsum could not install one of the components\")\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n##############################################################################\n# Returns the HP SUM return code.\n##############################################################################\n\ndef getHpSumExitCode():\n\n    exitCode = \"0\";\n\n    if (os.path.exists(hpSumExitCodeFile)):\n        try:\n            f = open( hpSumExitCodeFile, 'r')\n\n            contents = f.read();\n\n            exitCode = contents.strip()\n\n            f.close();\n        except (Exception), why:\n            raise Exception(\"An error occurred while reading '%s': %s\" % (hpSumExitCodeFile,why))\n    else:\n        raise Exception(\"'%s' not found\" % hpSumExitCodeFile)\n\n    return exitCode\n\n##############################################################################\n# Main Routine\n##############################################################################\n\ndef main():\n\n    retCode = 0\n\n    options, remaining_args = parseArgs(sys.argv[1:])\n\n    # If this is set to True, then a \"-3\" returned by HP SUM will result in\n    # the build plan step returning an error.\n    failOnWarning = options.failOnWarning\n\n    try:\n        hpSumExitCode = getHpSumExitCode()\n\n        print \"HP SUM return code is '%s'\" % hpSumExitCode\n\n        if (hpSumExitCode == \"0\"):\n            print \"The installation was successful\"\n        elif (hpSumExitCode == \"1\"):\n            print \"The installation was successful, but a reboot is required\"\n        elif (hpSumExitCode == \"3\"):\n            print \"The component was current or not required\"\n        elif (hpSumExitCode == \"-1\"):\n            print \"A general failure occurred.  For details, see the error log.\"\n            retCode = 1\n        elif (hpSumExitCode == \"-2\"):\n            print \"A bad input parameter was encountered\"\n            retCode = 1\n        elif (hpSumExitCode == \"-3\"):\n            print \"The installation of the component failed\"\n            if (failOnWarning):\n                retCode = 1\n        else:\n            print \"Unknown HP SUM return code\"\n            retCode = 1\n    except (Exception), why:\n        retCode = 1\n        sys.stderr.write(\"%s\" % why)\n\n    return retCode\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Reports the results of the SPP installation, by collecting the HP SUM return code from a file left behind by the \"Install Windows SPP In Background\" step.\n\nOptions:\n    --fail_on_warning  Causes the build plan step to fail if the HP SUM return code is -3, which means that there were some components that could not be installed.\n\nRequirements:\n* The \"Install Windows SPP In Background\" step must have been previously run.\n", 
      "current": true, 
      "versionLabel": "9", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:31:03.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-08-26T06:31:03.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Reports the results of the SPP installation, by collecting the HP SUM return code from a file left behind by the \"Install Windows SPP In Background\" step.\n\nOptions:\n    --fail_on_warning  Causes the build plan step to fail if the HP SUM return code is -3, which means that there were some components that could not be installed.\n\nRequirements:\n* The \"Install Windows SPP In Background\" step must have been previously run.\n", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:13.000Z"
      }, 
      {
        "usage": "Reports the results of the SPP installation, by collecting the HP SUM return code from a file left behind by the \"Install Windows SPP In Background\" step.\n\nOptions:\n    --fail_on_warning  Causes the build plan step to fail if the HP SUM return code is -3, which means that there were some components that could not be installed.\n\nRequirements:\n* The \"Install Windows SPP In Background\" step must have been previously run.\n", 
        "current": false, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:18.000Z"
      }, 
      {
        "usage": "Reports the results of the SPP installation, by collecting the HP SUM return code from a file left behind by the \"Install Windows SPP In Background\" step.\n\nOptions:\n    --fail_on_warning  Causes the build plan step to fail if the HP SUM return code is -3, which means that there were some components that could not be installed.\n\nRequirements:\n* The \"Install Windows SPP In Background\" step must have been previously run.\n", 
        "current": true, 
        "versionLabel": "9", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:31:03.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:07.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:15:06.000Z", 
    "description": "Unmaps the network drive that is associated with the specified drive letter.  If there is no network drive associated with the specified drive letter, this script still completes successfully.\n\nRequired Parameters:\n--driveLetter     The letter that's associated with the network drive to be unmapped.\n\nCustom Attributes:  None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1640001", 
    "modified": "2014-03-28T00:18:07.000Z", 
    "name": "Unmap Network Drive", 
    "source": "#!/usr/bin/python\n\n# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nimport subprocess\nfrom subprocess import Popen, PIPE, STDOUT\n\nimport sys\n\nfrom optparse import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.errors import ShowErrorMessage\n\nLOG = logger.getIt('unmap_network_drive')\n\n############################################################################################\n# Our parser.\n############################################################################################\n\nclass CustomParser(OptionParser):\n        \"\"\" a custom parser \"\"\"\n        def __init__(self, *args, **kwargs):\n                OptionParser.__init__(self, *args, **kwargs)\n                self.add_option(\"--driveLetter\",\n                                default=None,\n                                help=\"The drive letter of the network drive to be unmapped\")\n\n############################################################################################\n# Unmaps the network drive that's associated with the specified drive letter.\n#\n# Parameters:\n#    driveLetter - The drive letter to be unmapped.\n############################################################################################\n\ndef unmapNetworkDrive(driveLetter):\n\n\tcmd = \"net use \" + driveLetter + \":\" + \" /delete\"\n\n\tp = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=STDOUT)\n\n\tnet_stdout = p.communicate()[0]\n\n\tretCode = p.poll()\n\n\tp.stdout.close()\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"The command '%s' failed : %s\" % (cmd,net_stdout))\n\n############################################################################################\n# Returns true if the specified drive letter is assigned to a network drive; false otherwise.\n#\n# Parameters:\n#    driveLetter - The drive letter to be tested.\n############################################################################################\n\ndef isNetworkDrive(driveLetter):\n\n\tcmd = \"net use \" + driveLetter + \":\"\n\n\tp = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=STDOUT)\n\n\tp.communicate()[0]\n\n\tretCode = p.poll()\n\n\tp.stdout.close()\n\n\tif (retCode == 0):\n\t\treturn True\n\telse:\n\t\treturn False\n\n############################################################################################\n# The main function.\n############################################################################################\n\ndef main(argv):\n\n\targs_parser = CustomParser()\n\toptions, remaining_args = args_parser.parse_args(sys.argv[1:])\n\n\tif (options.driveLetter is None):\n\t\targs_parser.error(\"The '--driveLetter=<drive letter>' option is required.\")\n\n\ttry:\n\t\tif (isNetworkDrive(options.driveLetter)):\n\t\t\tunmapNetworkDrive(options.driveLetter)\n\t\t\tprint \"Successfully unmapped network drive '%s'\" % options.driveLetter\n\t\telse:\n\t\t\tprint \"There are no network drives mapped to '%s'\" % options.driveLetter\n\texcept (ShowErrorMessage), why:\n\t\tLOG.exception(why)\n\t\tsys.stderr.write(\"Failed to unmap network drive : %s\\n\" % why)\n\t\treturn 1\n\nif __name__ == \"__main__\":\n\tsys.exit(main(sys.argv))", 
    "state": null, 
    "version": {
      "usage": "Unmaps the network drive that is associated with the specified drive letter.  If there is no network drive associated with the specified drive letter, this script still completes successfully.\n\nRequired Parameters:\n--driveLetter     The letter that's associated with the network drive to be unmapped.\n\nCustom Attributes:  None", 
      "current": true, 
      "versionLabel": "66", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:07.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-28T00:18:07.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Unmaps the network drive that is associated with the specified drive letter.  If there is no network drive associated with the specified drive letter, this script still completes successfully.\n\nRequired Parameters:\n--driveLetter     The letter that's associated with the network drive to be unmapped.\n\nCustom Attributes:  None", 
        "current": false, 
        "versionLabel": "63", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:07.000Z"
      }, 
      {
        "usage": "Unmaps the network drive that is associated with the specified drive letter.  If there is no network drive associated with the specified drive letter, this script still completes successfully.\n\nRequired Parameters:\n--driveLetter     The letter that's associated with the network drive to be unmapped.\n\nCustom Attributes:  None", 
        "current": false, 
        "versionLabel": "64", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:10.000Z"
      }, 
      {
        "usage": "Unmaps the network drive that is associated with the specified drive letter.  If there is no network drive associated with the specified drive letter, this script still completes successfully.\n\nRequired Parameters:\n--driveLetter     The letter that's associated with the network drive to be unmapped.\n\nCustom Attributes:  None", 
        "current": false, 
        "versionLabel": "65", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:30.000Z"
      }, 
      {
        "usage": "Unmaps the network drive that is associated with the specified drive letter.  If there is no network drive associated with the specified drive letter, this script still completes successfully.\n\nRequired Parameters:\n--driveLetter     The letter that's associated with the network drive to be unmapped.\n\nCustom Attributes:  None", 
        "current": true, 
        "versionLabel": "66", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:07.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:31:15.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:36.000Z", 
    "description": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/310001", 
    "modified": "2014-08-26T06:31:15.000Z", 
    "name": "Copy Boot Media", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\nCopy the media needed to boot the target installer.\n\nBe smart and try to figure out the media that is needed.\n\"\"\"\n\nimport os\nimport sys\nimport StringIO\n\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov import media, helpers\nfrom osprov.errors import ShowErrorMessage, DiscoveryError\nfrom osprov.decorators import simplecache\n\n\nclass CopyBootMedia(object):\n\n    \"\"\" Do everything needed to copy the media \"\"\"\n\n    CFG_FILES = [\n        # Ubuntu support\n        \"install/netboot/ubuntu-installer/amd64/boot-screens/syslinux.cfg\",\n        \"install/netboot/ubuntu-installer/i386/boot-screens/syslinux.cfg\",\n        # Common locations for isolinux.cfgs in the supported platforms\n        \"isolinux/isolinux.cfg\",\n        \"isolinux.cfg\",\n        \"boot/i386/loader/isolinux.cfg\",\n        \"boot/x86_64/loader/isolinux.cfg\"\n    ]\n\n    def __init__(self, log=None):\n        \"\"\" Init the class \"\"\"\n        if log is None:\n            self.log = logger.getIt(self.__class__.__name__)\n        else:\n            self.log = log\n        self.media = None\n\n    @property\n    @simplecache\n    def keys(self):\n        return helpers.getDataStore()\n\n    def discoverMediaObject(self, arg=None):\n        \"\"\" Figure out the type of media used and return the appropriate object type\"\"\"\n        if self.keys.media.url:\n            self.media = media.factor(self.keys.media.url, log=self.log)\n        else:\n            mediaServer = open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n            mediaPath = open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n            mediaMount = open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n            url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n            self.log.debug(\n                \"Being Backward compatible with old mount script. will use url %s\" % url)\n            self.media = media.factor(url)\n        if arg:\n            if self.media.parsed_url.scheme == \"nfs\" and \\\n                    os.path.isfile(os.path.join(self.media.basepath, arg[0])):\n                #  we can only support the iso if the media is presented using nfs\n                #  and we threat any files as supported\n                #  - This is only to be backwards compatibile,\n                # this would be better off unsupported\n                self.media = media.factor(\"iso://%s/%s\" % (self.media.basepath, arg[0]))\n            else:\n                if not arg[0].lower().endswith(\".iso\"):\n                    # If it's not an iso, consider it a subdir\n                    self.media.subdir(arg[0])\n                # Just ignore an iso if we are not on NFS\n\n    def flattenSyslinuxCfg(self, cfgFile):\n        \"\"\" Flattens nested syslinux.cfg files that use the include statement.\n                If a file to be included is not found it is skipped.\n        \"\"\"\n        result = Syslinux.readwrite(StringIO.StringIO())\n\n        if not self.media.exists(cfgFile):\n            return result\n\n        parser = Syslinux.readonly(self.media.open(cfgFile))\n        for key in parser.info():\n            if key.startswith(\"include\"):\n                nestedCfg = key.split()[1]\n                nestedCfgPath = os.path.join(os.path.dirname(cfgFile), os.path.split(nestedCfg)[-1])\n                nestedParser = self.flattenSyslinuxCfg(nestedCfgPath)\n                for nestedKey, nestedValue in nestedParser.info().items():\n                    result.info()[nestedKey] = nestedValue\n            else:\n                result.info()[key] = parser.info()[key]\n        return result\n\n    def getConfigFile(self):\n        \"\"\" \"\"\"\n        cfg_file = None\n        for each_file in self.CFG_FILES:\n            if self.media.exists(each_file):\n                cfg_file = each_file\n                break\n        if not cfg_file:\n            raise DiscoveryError(\"Found no isolinux config file. \"\n                                 \"Discovery of media files cannot be achieved. Make sure the media is \"\n                                 \"correct\")\n        return cfg_file\n\n    def getBootFiles(self, bootLabel):\n        print \"Adding kernel to be copied\"\n        files = [bootLabel[\"kernel\"]]\n        # hunt for additional files, initrd first\n        for param in bootLabel[\"append\"].split(' '):\n            if param.startswith(\"initrd=\"):\n                print \"Adding initrd(s) to files to be copied\"\n                files.extend([x.strip() for x in param[len(\"initrd=\"):].split(',')])\n                break\n        return files\n\n    def getMBootFiles(self, bootLabel):\n        \"\"\" Get mboot.c32 style files \"\"\"\n        files = []\n        if \" --- \" in bootLabel[\"append\"]:\n            print \"Adding mboot modules\"\n            # might want to account for parameters too here\n            files.extend([x.strip() for x in bootLabel[\"append\"].split(\" --- \")])\n        return files\n\n    def getESXi5BootFiles(self, bootLabel, cfg_file):\n        \"\"\" Get boot files from nested boot configs \"\"\"\n        files = []\n        where = bootLabel[\"append\"].find(\"-c\")\n        if where >= 0:\n            print \"Adding modules from boot configuration file\"\n            bootcfg_name = bootLabel[\"append\"][where + 2:].strip().split(' ', 1)[0]\n            bootcfg_file = self.media.open(\n                os.path.join(os.path.dirname(cfg_file), bootcfg_name))\n            files.append(bootcfg_name)\n            bootcfg = Syslinux.Bootcfg.readonly(bootcfg_file).info()\n            files.append(bootcfg[\"kernel\"])\n            files.extend(bootcfg[\"modules\"])\n            # also retrieve the UEFI bootloader\n            files.append(\"/efi/boot/bootx64.efi\")\n        return files\n\n    def discoverMediaFiles(self):\n        \"\"\" Check the install media  \"\"\"\n        cfg_file = self.getConfigFile()\n        print \"Found configuration at %s\" % cfg_file\n        config = self.flattenSyslinuxCfg(cfg_file)\n        self.log.debug(\"Discovered syslinux cfg file: %s\" % config)\n        # get the first label without a localboot option\n        # we will use that for discovery\n        name = config.first_non_local_label()\n        if name is None:\n            raise DiscoveryError(\"Cannot discover media files. \"\n                                 \"The %s config file has an unexpected configuration.\" % cfg_file)\n        values = config.info()[\"label \" + name]\n        print \"Will discover media using label %s\" % name\n        # if we go this far, we have our name and value\n        # get a list of the media files\n        files = []\n        try:\n            files.extend(self.getBootFiles(values))\n            files.extend(self.getMBootFiles(values))\n            files.extend(self.getESXi5BootFiles(values, cfg_file))\n        except KeyError, why:\n            raise DiscoveryError(\"Cannot discover media files. \"\n                                 \"Unexpected isolinux configuration. Property %s not found\" % why)\n        # normalize the files to the isolinux.cfg location\n        files = [helpers.pathMerge(cfg_file, x) for x in files]\n        return files, config\n\n    def discoverTarget(self):\n        \"\"\" discover the target partition \"\"\"\n        target = self.keys.disk.device_mount\n        if not target:\n            raise DiscoveryError(\"Cannot determine target destination. \"\n                                 \"Was the stub partition created?\")\n        return target\n\n    def copyFiles(self, target, files):\n        \"\"\" copy the files onto the stub partition \"\"\"\n        for each in files:\n            print \"Copying %s to %s\" % (each, target)\n            ex = None\n            for i in xrange(5):\n                try:\n                    self.media.copyTo(each, target)\n                    break\n                except IOError, ex:\n                    self.log.warning(\n                        \"Copy operation of file %s failed, retry %d of 5; exception follows\" % (each, i + 1))\n                    self.log.exception(ex)\n            else:\n                raise ex\n\n    def main(self, args):\n        \"\"\" do the media copying  \"\"\"\n        try:\n            self.discoverMediaObject(args[1:2])\n            print \"Will copy from %s\" % self.media\n            target = self.discoverTarget()\n            if not os.path.isdir(target):\n                print \"Error: %s is not a directory. Can't copy media there.\" % target\n                print \"There might be an issue with the stub partition.\"\n                return 1\n            files = None\n            if args:\n                if args[2:]:\n                    # old style parameters\n                    files = args[2:]\n            if not files:\n                files, config = self.discoverMediaFiles()\n                fd = open(os.path.join(target, \"isolinux.cfg\"), \"w+b\")\n                try:\n                    fd.write(config.format())\n                finally:\n                    fd.close()\n            self.copyFiles(target, files)\n            print \"Successfully copied all boot media\"\n        except DiscoveryError, why:\n            self.log.exception(why)\n            print \"Auto discovery failed: %s\" % why\n            return 3\n        except ShowErrorMessage, why:\n            self.log.exception(why)\n            print \"Failed to copy boot media %s\" % why\n            return why[1]\n        except (IOError, OSError), why:\n            self.log.exception(why)\n            print \"Failed to copy boot media : %s. Is this the correct media?\" % why\n            return 4\n\n\nif __name__ == \"__main__\":\n    sys.exit(CopyBootMedia().main(sys.argv))\n", 
    "state": null, 
    "version": {
      "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
      "current": true, 
      "versionLabel": "17", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:31:14.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-08-26T06:31:15.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:37.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:38.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:59.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:19.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:38.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "6", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:58.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:19.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:39.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "9", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:16.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "10", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:58.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "11", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:24.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "12", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:47.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "13", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:09.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "14", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:33.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "15", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:00.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": false, 
        "versionLabel": "16", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:26.000Z"
      }, 
      {
        "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": true, 
        "versionLabel": "17", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:31:14.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:11.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:15:10.000Z", 
    "description": "Uninstalls HP agents and utilities that store system specific information in the registry.  There may be problems if a Windows image captured with these agents and utilities installed is deployed to another system.\n\nParameters: None\n\nCustom Attributes: None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1660001", 
    "modified": "2014-03-28T00:18:11.000Z", 
    "name": "Uninstall HP ProLiant Utilities", 
    "source": "'Sysprep Imaging Preparation Script\n'vbscript\n\n'(c) Copyright 2013, 2014 Hewlett-Packard Development Company, L.P.\n\ndim aNames(11)\naNames(0) = \"HP Insight Management Agents\"\naNames(1) = \"HP Lights-Out Online Configuration Utility\"\naNames(2) = \"HP ProLiant Rack Infrastructure Interface Service\"\naNames(3) = \"HP Smart Array SAS/SATA Event Notification Service\"\naNames(4) = \"HP Insight Diagnostics Online Edition for Windows\"\naNames(5) = \"HP Insight Diagnostics  Online Edition for Windows\"\naNames(6) = \"HP ProLiant Online RBSU\"\naNames(7) = \"HP Insight \ufffd}\ufffdl\ufffdW\ufffd\ufffd\ufffd\ufffd\ufffdg \ufffdG\ufffd[\ufffdW\ufffdF\ufffd\ufffd\ufffdg\"\naNames(8) = \"HP ProLiant \ufffd\ufffd\ufffdb\ufffdN \ufffdC\ufffd\ufffd\ufffdt\ufffd\ufffd\ufffdX\ufffdg\ufffd\ufffd\ufffdN\ufffd`\ufffd\ufffd \ufffdC\ufffd\ufffd\ufffd^\ufffdt\ufffdF\ufffdC\ufffdX \ufffdT\ufffd[\ufffdr\ufffdX\"\naNames(9) = \"HP Smart \ufffdA\ufffd\ufffd\ufffdCSAS/SATA\ufffdC\ufffdx\ufffd\ufffd\ufffdg\ufffd\ufffd\ufffdm\ufffdT\ufffd[\ufffdr\ufffdX\"\naNames(10) = \"HP Lights-Out \ufffdI\ufffd\ufffd\ufffd\ufffd\ufffdC\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd[\ufffde\ufffdB\ufffd\ufffd\ufffde\ufffdB\"\n\n\nset oFSO = Wscript.CreateObject(\"Scripting.FileSystemObject\")\nset oShell = Wscript.CreateObject(\"Wscript.Shell\")\nset oRegistry = GetObject(\"winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv\")\nconst nHKLM = 2147483650\n\n\n'uninstall software\nconst sUninstallKey = \"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\noRegistry.EnumKey nHKLM, sUninstallKey, aKeys\nfor each sKey In aKeys\n   oRegistry.GetStringValue nHKLM, sUninstallKey & \"\\\" & sKey, \"DisplayName\", sDisplayName\n   oRegistry.GetExpandedStringValue nHKLM, sUninstallKey & \"\\\" & sKey, \"UninstallString\", sUninstallString\n   if IsNull(sDisplayName) = False and IsNull(sUninstallString) = False and IsAMatch(sDisplayName) then\n      uninstallCommand = sUninstallString & \" /passive\"\n      WScript.echo \"Uninstalling component => \" & uninstallCommand\n      oShell.Run(uninstallCommand),1,true\n   end if\nnext\n\n'Get the system drive.\n'Set WshShell = CreateObject(\"WScript.Shell\")\n'systemDrive = WshShell.ExpandEnvironmentStrings(\"%SystemDrive%\")\n\n'Create windows scheduled task which reinstalls Broadcom driver on reboot with 15 min delay \n'reinstallCommand = \"schtasks /create /sc ONSTART /tn ReinstallBroadCom  /tr \" & Chr(34) & systemDrive & \"\\\" & Chr(36) & \"oem\" & Chr(36) & \"\\components\\update_broadcom.cmd\" & Chr(34) & \" /DELAY 0015:00 /f /ru SYSTEM\"\n'WScript.echo \"Scheduling reinstalling of Broadcom driver => \" & reinstallCommand\n'oShell.Run(reinstallCommand)\n\n\nfunction IsAMatch(sString)\n   fFound = False\n   for each sName in aNames\n      if sName = sString then\n         fFound = True\n      end if\n   next\n   IsAMatch = fFound\nend function\n\n\nfunction DeleteFile (sPathExist, sPathDelete)\n   if oFSO.FileExists(sPathExist) then\n      oFSO.DeleteFile(sPathDelete), True\n   end if\nend function\n\n", 
    "state": null, 
    "version": {
      "usage": "Uninstalls HP agents and utilities that store system specific information in the registry.  There may be problems if a Windows image captured with these agents and utilities installed is deployed to another system.\n\nParameters: None\n\nCustom Attributes: None", 
      "current": true, 
      "versionLabel": "50", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:11.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "VBS", 
    "currentVersionChangedDate": "2014-03-28T00:18:11.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows VBScript", 
    "allVersions": [
      {
        "usage": "Uninstalls HP agents and utilities that store system specific information in the registry.  There may be problems if a Windows image captured with these agents and utilities installed is deployed to another system.\n\nParameters: None\n\nCustom Attributes: None", 
        "current": false, 
        "versionLabel": "47", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:10.000Z"
      }, 
      {
        "usage": "Uninstalls HP agents and utilities that store system specific information in the registry.  There may be problems if a Windows image captured with these agents and utilities installed is deployed to another system.\n\nParameters: None\n\nCustom Attributes: None", 
        "current": false, 
        "versionLabel": "48", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:13.000Z"
      }, 
      {
        "usage": "Uninstalls HP agents and utilities that store system specific information in the registry.  There may be problems if a Windows image captured with these agents and utilities installed is deployed to another system.\n\nParameters: None\n\nCustom Attributes: None", 
        "current": false, 
        "versionLabel": "49", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:34.000Z"
      }, 
      {
        "usage": "Uninstalls HP agents and utilities that store system specific information in the registry.  There may be problems if a Windows image captured with these agents and utilities installed is deployed to another system.\n\nParameters: None\n\nCustom Attributes: None", 
        "current": true, 
        "versionLabel": "50", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:11.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:26.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:25.000Z", 
    "description": "Installs Windows 2003 x64 from OS Media. Requires full path to winnt32.exe from the installation media.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1080001", 
    "modified": "2014-03-10T21:37:26.000Z", 
    "name": "Run Windows 2003 x64 Setup", 
    "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.txt\nset ARGS=/noreboot /unattend:%ANSWER% /syspart:@SystemDrive:C@: /tempdrive:@SystemDrive:C@: /debug3:%SystemDrive%\\install.log\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n", 
    "state": null, 
    "version": {
      "usage": "Installs Windows 2003 x64 from OS Media. Requires full path to winnt32.exe from the installation media.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:25.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-10T21:37:26.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs Windows 2003 x64 from OS Media. Requires full path to winnt32.exe from the installation media.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:25.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:19.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:18.000Z", 
    "description": "Updates existing agent with new MID, crypto, and gateway information.\n\nPrerequisites:\n- Target server runs a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as an OS Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/940001", 
    "modified": "2014-03-10T21:37:19.000Z", 
    "name": "Update HP SA Agent Information", 
    "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(c) Copyright 2012 Hewlett-Packard Development Company, L.P.\nIntegrates the HP SA Agent into a server\n\nThis consists of:\n\n * Copying the MID and crypto into place\n * Updating the gateway information\n\"\"\"\nimport glob\nimport optparse\nimport os\nimport stat\nimport shutil\nimport string\nimport sys\nimport time\nimport stat\n\nfrom osprov import constants, helpers\nfrom osprov.server import ThisLocalServer\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.errors import NotFoundError\nfrom osprov.server.local import linux, winpe\n\nLOCAL_SERVER = ThisLocalServer()\n\n# backup timestamp\nBACKUP_TIMESTAMP = string.replace(time.ctime(time.time()), ':', '-')\n\n\ndef backupAndReplaceFile(sourceFile, destFile):\n\n    if not os.path.exists(sourceFile):\n        raise NotFoundError(\"Unable to find HP SA Agent file (\" + sourceFile +\n                            \").  Guest Customization is only supported when HP SA Agent is previously installed.\")\n\n    # backup and delete existing file\n    if os.path.exists(destFile):\n        # chmod to writable\n        os.chmod(destFile, stat.S_IWRITE | stat.S_IREAD)\n        shutil.copy(destFile, destFile + \".backup_\" + BACKUP_TIMESTAMP)\n        os.remove(destFile)\n\n    # copy new file\n    shutil.copy(sourceFile, destFile)\n    print \"Copy \" + sourceFile + \" to \" + destFile\n\n    if os.stat(destFile)[stat.ST_SIZE] == 0:\n        raise ShowErrorMessage(\"file %s copied over was size 0\" % destFile)\n\n\ndef copyMidCryptoGateway():\n    \"\"\"Copies the essential identity files from the OGFS Agent to the real OS filesystem.\n\n    Server is expected to already be agent-managed.\n\n    This include the unique machine identifier (MID) and the device-specific\n    crypto certificates.\n    \"\"\"\n\n    sourceMidFile = LOCAL_SERVER.MID_FILE\n    sourceGatewayFile = os.path.join(os.path.dirname(sourceMidFile), \"opswgw.args\")\n    sourceCryptoDir = LOCAL_SERVER.CRYPTO_DIR\n\n    if isinstance(LOCAL_SERVER, linux.LinuxSOSLocalServer):\n        mountPath = constants.OGFS_SYSTEM_ROOT\n        destMidFile = mountPath + sourceMidFile\n        destGatewayFile = mountPath + sourceGatewayFile\n        destCryptoDir = mountPath + sourceCryptoDir\n    else:\n        mountPath = helpers.getSystemDrive(\"@SystemPartition:C@\")\n        destMidFile = mountPath + sourceMidFile[1:]\n        destGatewayFile = mountPath + sourceGatewayFile[1:]\n        destCryptoDir = mountPath + sourceCryptoDir[1:]\n\n    backupAndReplaceFile(sourceMidFile, destMidFile)\n    backupAndReplaceFile(sourceGatewayFile, destGatewayFile)\n\n    # replace old crypto files with new crypto files\n    for srcCryptoFile in glob.glob(sourceCryptoDir + \"/*.*\"):\n        dstCryptoFile = destCryptoDir + \"/\" + os.path.basename(srcCryptoFile)\n        backupAndReplaceFile(srcCryptoFile, dstCryptoFile)\n\n    print \"This server's unique MID and crypto material successfully installed, and gateway value updated\"\n\n\ndef error(message):\n    sys.stderr.write(message + \"\\n\")\n\ntry:\n    copyMidCryptoGateway()\nexcept ShowErrorMessage, ex:\n    error(ex.args[0])\n    sys.exit(ex.args[1])\n", 
    "state": null, 
    "version": {
      "usage": "Updates existing agent with new MID, crypto, and gateway information.\n\nPrerequisites:\n- Target server runs a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as an OS Build Plan step.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:19.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:19.000Z", 
    "runAsSuperUser": false, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Updates existing agent with new MID, crypto, and gateway information.\n\nPrerequisites:\n- Target server runs a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as an OS Build Plan step.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:19.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:29.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:29.000Z", 
    "description": "Prepares the OS installer for use with kexec\n\nUsage:\n  -h, --help            show this help message and exit\n  -k KERNEL_ARGUMENTS, --kernel_arguments=\"KERNEL_ARGUMENTS\"  Kernel arguments to be given to the OS Installer kernel, must be enclosed in quotes (\"\"). Any quotes in arguments must be escaped\n\nPrerequisites:\n- Target server runs a maintenance Linux OS and \"Create and mount stub ramdisc\" step was performed.\n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1140001", 
    "modified": "2014-03-10T21:37:29.000Z", 
    "name": "Run Rebootless Installer", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\nThis program will prepare OS installer for use with kexec\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\nimport os\nimport sys\n\nfrom osprov.osbp import logger\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.errors import DiscoveryError\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov import helpers\nfrom osprov.util import process\nfrom osprov.server import ThisLocalServer\nfrom osprov.sysinfo import LinuxSysInfo\n\nfrom osprov.constants import DEFAULT_INITRD_DIR\nfrom osprov.constants import DEFAULT_SA_INITRD_MASK\n\nLOG = logger.getIt(\"Prepare OS Installer\")\n\n\nclass PrepareOSInstallerOptionsParser(OptionParser):\n\n    \"\"\" An options' parser for this step. \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\n            \"-k\", \"--kernel_arguments\", type=\"string\", dest=\"kernel_arguments\", metavar=\"KERNEL_ARGUMENTS\", default=\"\",\n            help=\"Kernel arguments to be given to the OS Installer kernel, must be enclosed in quotes (\"\"). Any quotes in arguments must be escaped\")\n\n\ndef getKernelImage(stub_path, cfgFile):\n    \"\"\" gets the name of the kernel image based on the \"isolinux.cfg\" file \"\"\"\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point: %s. \"\n                             \"Was the stub partition/ramdisk created?\" % stub_path)\n\n    cfgFile.seek(0)\n    isocfg = Syslinux.readonly(cfgFile)\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n\n    kernel = os.path.basename(isocfg_label[\"kernel\"])\n    if not kernel:\n        raise DiscoveryError(\"Failed to discover the boot kernel\")\n\n    kernelPath = os.path.join(stub_path, kernel)\n    if not os.path.exists(kernelPath):\n        raise DiscoveryError(\"Failed to discover the boot kernel: %s\" % kernelPath)\n\n    return kernel\n\n\ndef getInitrdImage(stub_path, cfgFile):\n    \"\"\" gets the name of the initrd image based on the \"solinux.cfg\" file \"\"\"\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point: %s. \"\n                             \"Was the stub partition/ramdisk created?\" % stub_path)\n\n    cfgFile.seek(0)\n    isocfg = Syslinux.readonly(cfgFile)\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n\n    initrd = \"\"\n    appendLine = isocfg_label[\"append\"].split(' ')\n    for each in appendLine:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                initrd = os.path.basename(value)\n    if not initrd:\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    initrdPath = os.path.join(stub_path, initrd)\n    if not os.path.exists(initrdPath):\n        raise DiscoveryError(\"Failed to discover the initrd: %s\" % initrdPath)\n\n    return initrd\n\n\ndef getEmbededInitrds(stub_path):\n    \"\"\" get embeded initrds images names \"\"\"\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point: %s. \"\n                             \"Was the stub partition/ramdisk created?\" % stub_path)\n    embInitrd = helpers.findFiles(\n        path=os.path.join(stub_path, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    embededInitrd = []\n    if embInitrd:\n        for eachrd in embInitrd:\n            embededInitrd.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        embededInitrd = helpers.numericalSort(embededInitrd)\n    return embededInitrd\n\n\ndef concatFiles(srcFile, destFile):\n    \"\"\" concatenates one file to dest \"\"\"\n    buflen = 1024 * 1024 * 2\n    while True:\n        data = srcFile.read(buflen)\n        if data:\n            destFile.write(data)\n        else:\n            break\n\n\ndef concatInitrds(stub_path):\n    \"\"\" Concatenates localrds created from embed initrd to the OS Installer initrd \"\"\"\n    # strip first \"/\" for path.join to work\n    localrds = [x.lstrip(\"/\") for x in getEmbededInitrds(stub_path)]\n\n    for localrd in localrds:\n        localrdFile = open(os.path.join(stub_path, localrd), 'rb')\n        isolinuxFile = open(os.path.join(stub_path, \"isolinux.cfg\"))\n        initrdFile = open(os.path.join(stub_path, getInitrdImage(stub_path, isolinuxFile)), 'ab')\n\n        concatFiles(localrdFile, initrdFile)\n\n        isolinuxFile.close()\n        localrdFile.close()\n        initrdFile.close()\n\n\ndef getKernelSetupParams():\n    \"\"\" get kernel parameters for OS Installer \"\"\"\n    defaultParams = \"ks=file:/user.ks.cfg hpsa_monitoring_agent=1 ip=dhcp noipv6\"\n    localServer = ThisLocalServer()\n    mac = localServer.getMACAddress().lower()\n\n    defaultParams += \" ksdevice=%s\" % mac\n    return defaultParams\n\n\ndef runRebootlessInstaller(kernel_arguments):\n    stub_path = helpers.getDataStore().disk.device_mount\n    concatInitrds(stub_path)\n\n    isolinuxFile = open(os.path.join(stub_path, \"isolinux.cfg\"))\n    process.runIt(\n        'kexec -l %s --initrd=%s --command-line=\"%s\"' % (os.path.join(stub_path, getKernelImage(stub_path, isolinuxFile)),\n                                                         os.path.join(stub_path, getInitrdImage(stub_path, isolinuxFile)), getKernelSetupParams() + \" \" + kernel_arguments), log=LOG)\n    isolinuxFile.close()\n    process.runIt(\n        '/opt/opsware/agent/pylibs/cogbot/etc/opsware-agent stop ; kexec -e', shell=True, log=LOG)\n\n\n@HandleShowErrorMessage(\"Prepare OS Installer step\", LOG)\ndef main():\n    \"\"\"Main entry point when executed as a script from the command line\"\"\"\n    parser = PrepareOSInstallerOptionsParser()\n    options, args = parser.parse_args()\n\n    LOG.info('given args: %s' % options.kernel_arguments)\n    runRebootlessInstaller(options.kernel_arguments.replace('\"', '\\\\\"'))\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Prepares the OS installer for use with kexec\n\nUsage:\n  -h, --help            show this help message and exit\n  -k KERNEL_ARGUMENTS, --kernel_arguments=\"KERNEL_ARGUMENTS\"  Kernel arguments to be given to the OS Installer kernel, must be enclosed in quotes (\"\"). Any quotes in arguments must be escaped\n\nPrerequisites:\n- Target server runs a maintenance Linux OS and \"Create and mount stub ramdisc\" step was performed.\n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:29.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:29.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Prepares the OS installer for use with kexec\n\nUsage:\n  -h, --help            show this help message and exit\n  -k KERNEL_ARGUMENTS, --kernel_arguments=\"KERNEL_ARGUMENTS\"  Kernel arguments to be given to the OS Installer kernel, must be enclosed in quotes (\"\"). Any quotes in arguments must be escaped\n\nPrerequisites:\n- Target server runs a maintenance Linux OS and \"Create and mount stub ramdisc\" step was performed.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:29.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:39:43.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:39:43.000Z", 
    "description": "Script to clean the Oracle DbScanner on a managed server", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1430001", 
    "modified": "2014-03-10T21:39:43.000Z", 
    "name": "post-uninstall script for Database scanner for Oracle (win)", 
    "source": "set RMFOLDER=%ProgramFiles%\\Opsware\\dbscanner.oracle\nif exist \"%RMFOLDER%\" (rd /S /Q \"%RMFOLDER%\") ", 
    "state": null, 
    "version": {
      "usage": "Script to clean the Oracle DbScanner on a managed server", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:39:43.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-10T21:39:43.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Script to clean the Oracle DbScanner on a managed server", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:39:43.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:36:39.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:39.000Z", 
    "description": "This script inject required settings into the preseed file:\n- The media server used in the installation process. Only HTTP is supported.\n- Sets the network interface detection to auto. Later on the BOOTIF kernel parameter will be set to the specific network interface that should be used by the system.\nThis is determined either from the hpsa_netconfig custom attribute in static IP deployments or the interface the agent used to connect to the agent gateway.\n- Sets the disk to be used for partitioning, if not already customized by the user, to the first available disk or as specified by the boot_disk custom attribute.\n\nUsage: inject_required_preseed.py\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ps file must be in /tmp/preseed.cfg.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/340001", 
    "modified": "2014-03-10T21:36:39.000Z", 
    "name": "Inject Required Preseed Settings", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\nInject required options and move the file onto the boot\npartition. \"\"\"\n\nimport os\nimport sys\n\nfrom osprov.constants import MONITORING_STOP_FLAG\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.profile.preseed import Preseed\nfrom osprov.diskmgr.diskmanager import DiskManager\nfrom osprov.osbp import logger\nfrom osprov.diskmgr.disk import Disk\nfrom osprov import helpers\nfrom osprov.server import ThisLocalServer\n\nLOG = logger.getIt('inject_required')\n\nBASE_PS_FILE = \"tmp/preseed.cfg\"\nBOOT_DISK = \"@boot_disk@\"  # ScriptWeaver will parametrize this data at run time\n\n\ndef initPreseed(baseFile):\n    \"\"\" Initialize a Preseed object \"\"\"\n    return Preseed(open(baseFile, \"r\"))\n\n\ndef writeFinalPs(psobj):\n    \"\"\" Write the preseed file onto the boot disk \"\"\"\n    psfile = open(BASE_PS_FILE, \"w\")\n    psfile.write(str(psobj))\n    psfile.close()\n    LOG.info(\"Preseed contents after injecting required settings\")\n    LOG.info(str(psobj))\n    print \"Preseed file written to disk\"\n\n\ndef injectMonitoringAgentPreScript(targetServer, psobj):\n    \"\"\" Configure the monitoring osprov ogfs agent to start during the install before anything else \"\"\"\n    agwIp, agwPort = targetServer.getRandomAgentGateway()\n    ogfsAgentStartScript = targetServer.getOgfsAgentStartupScript(\n        agent=targetServer.AGENT_PATH,\n        agwIpPort=\"%s:%s\" % (\n            agwIp, agwPort),\n        env=\"LD_LIBRARY_PATH=%s\" % os.path.join(\n            targetServer.AGENT_PATH, \"osprov/lib\"),\n        flags={\"daemonize\": True, \"mount\": False, \"quiet\": True})\n    LOG.debug(\"Using the following script to start the monitoring agent:\\n%s\" %\n              ogfsAgentStartScript)\n    psobj.setPreScript(script=ogfsAgentStartScript)\n\n\ndef injectDisk(preseed):\n    \"\"\" Inject the disk the installer to use. Only do this if the user does not have custom partitioning.\n        Also make use of the boot_disk custom attribute. \"\"\"\n    # Only set the disk if the user does not have custom partitioning.\n    _cmd, (_type, value) = getattr(preseed, \"d-i partman-auto/disk\", (None, (None, \"\")))\n    if not value.strip():\n        # Use the first disk for partitioning or the one specified by the boot_disk CA.\n        if BOOT_DISK and not \"@\" in BOOT_DISK:\n            bootDisk = Disk(BOOT_DISK).getDeviceFilePath()\n            print \"Injecting 'd-i partman-auto/disk %s' into the preseed\" % bootDisk\n        else:\n            bootDisk = None\n            print \"Configuring 'd-i partman-auto/disk' to use the first available disk\"\n        preseed.setDisk(bootDisk)\n        return True\n    else:\n        return False\n\n\n@HandleShowErrorMessage(\"inject required preseed settings\", LOG)\ndef main():\n    \"\"\" Do the injection into the preseed \"\"\"\n    try:\n        targetServer = ThisLocalServer()\n        keys = helpers.getDataStore(targetServer)\n\n        preseed = initPreseed(BASE_PS_FILE)\n        mediaUrl = keys.media.url\n\n        if not mediaUrl.startswith(\"http:\"):\n            print \"Provisioning Ubuntu Server through anything other than http is not yet supported : \\n%s\" % str(\n                mediaUrl)\n            return 100\n\n        preseed.setMediaSource(mediaUrl)\n        preseed.setNetworkInterfaceToAuto()\n\n        injectDisk(preseed)\n\n        # Start the ogfs agent during the installation.\n        injectMonitoringAgentPreScript(targetServer, preseed)\n        # This flag is used to stop the monitoring step.\n        preseed.setPostScript(\"touch %s\" % MONITORING_STOP_FLAG)\n        # Stop the installer in order to integrate the HPSA agent.\n        preseed.stopInstaller()\n\n        writeFinalPs(preseed)\n        print \"Successfully injected required settings\"\n        LOG.info(\"Preseed after required settings were injected:\\n%s\" % str(preseed))\n    except (IOError, OSError), why:\n        LOG.exception(why)\n        sys.stderr.write(\"Failed to inject required settings.%s\\n\" % why)\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "This script inject required settings into the preseed file:\n- The media server used in the installation process. Only HTTP is supported.\n- Sets the network interface detection to auto. Later on the BOOTIF kernel parameter will be set to the specific network interface that should be used by the system.\nThis is determined either from the hpsa_netconfig custom attribute in static IP deployments or the interface the agent used to connect to the agent gateway.\n- Sets the disk to be used for partitioning, if not already customized by the user, to the first available disk or as specified by the boot_disk custom attribute.\n\nUsage: inject_required_preseed.py\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ps file must be in /tmp/preseed.cfg.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:36:39.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-10T21:36:39.000Z", 
    "runAsSuperUser": false, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "This script inject required settings into the preseed file:\n- The media server used in the installation process. Only HTTP is supported.\n- Sets the network interface detection to auto. Later on the BOOTIF kernel parameter will be set to the specific network interface that should be used by the system.\nThis is determined either from the hpsa_netconfig custom attribute in static IP deployments or the interface the agent used to connect to the agent gateway.\n- Sets the disk to be used for partitioning, if not already customized by the user, to the first available disk or as specified by the boot_disk custom attribute.\n\nUsage: inject_required_preseed.py\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ps file must be in /tmp/preseed.cfg.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:39.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:36:59.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:59.000Z", 
    "description": "This program will unpack, resize and modify the Solaris miniroot to include\nall necessary files for automated installation.\n\nusage: prepare_miniroot.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Inject Required Jumpstart'", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/660001", 
    "modified": "2014-03-10T21:36:59.000Z", 
    "name": "Prepare Miniroot x86", 
    "source": "# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n\"\"\"\nThis program will unpack, resize and modify the Solaris miniroot to include\nall necessary files for automated installation.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\nimport os\nimport sys\nimport shutil\nimport tarfile\nfrom osprov import helpers\nfrom osprov.osbp import logger\nfrom osprov.server import ThisLocalServer\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.wrappers.boot_archive import BootArchive\n\n\nLOG = logger.getIt(\"Prepare Miniroot x86\")\n\n\ndef createConfigTar(jumpstartDir):\n    \"\"\" Creates the config.tar file in the jumpstart directory on the mounted path \"\"\"\n    os.chdir(jumpstartDir)\n    configTarPath = os.path.join(jumpstartDir, \"config.tar\")\n\n    LOG.debug(\"Jumpstart Configuration .tar path : %s\" % configTarPath)\n    tar = tarfile.open(configTarPath, \"w:\")\n    configFilesList = os.listdir(jumpstartDir)\n    for configFile in configFilesList:\n        tar.add(configFile)\n    LOG.debug(\"Files compressed in %s : %s\" % (configTarPath, str(tar.getmembers())))\n    tar.close()\n    return configTarPath\n\n\ndef injectJumpstartToMiniroot(jumpstartDir, unpackMrDir):\n    \"\"\" Copies Jumpstart files to the mounted miniroot \"\"\"\n    createConfigTar(jumpstartDir=jumpstartDir)\n    destJumpstartDir = os.path.join(unpackMrDir, \"jumpstart/\")\n    shutil.copytree(jumpstartDir, destJumpstartDir)\n    LOG.debug(\"Injected Jumpstart Files to miniroot %s \" % destJumpstartDir)\n\n\ndef injectAgentFilesToMiniroot(tmpOGFSAgentPath, unpackMrDir):\n    \"\"\" Copies ogfs agent files to the mounted miniroot \"\"\"\n    destOGFSAgentPath = os.path.join(unpackMrDir, \"opt/opsware/agent/\")\n    shutil.copytree(tmpOGFSAgentPath, destOGFSAgentPath)\n    LOG.debug(\"Injected Agent Files to miniroot %s \" % destOGFSAgentPath)\n\n\ndef injectSmbiosToMiniroot(smbiosPath, unpackMrDir):\n    \"\"\" Copies smbios filee to the mounted miniroot \"\"\"\n    destSmbiosPath = os.path.join(unpackMrDir, \"dev/smbios\")\n    shutil.copyfile(smbiosPath, destSmbiosPath)\n    LOG.debug(\"Injected smbios File to miniroot %s \" % destSmbiosPath)\n\n\ndef setupMiniroot(minirootObj):\n    \"\"\" Unpacking, resizing and mounting miniroot \"\"\"\n    minirootObj.unpack()\n    minirootObj.grow(200)\n    minirootObj.mount()\n    LOG.info(\"Unpacked, resized and mounted the miniroot\")\n\n\ndef cleanupMiniroot(minirootObj):\n    \"\"\" Unmounting, repacking and cleaning up miniroot \"\"\"\n    minirootObj.umount()\n    minirootObj.repack()\n    minirootObj.cleanup()\n    LOG.info(\"Umounted, repacked and cleaned up the miniroot\")\n\n\n@HandleShowErrorMessage(\"Prepare Miniroot x86\", LOG)\ndef main():\n    \"\"\" Injecting the necessary files to the install miniroot \"\"\"\n    keys = helpers.getDataStore()\n    targetServer = ThisLocalServer()\n    minirootObj = BootArchive(\n        osVersion=\"10\", log=LOG, dataStoreKeys=keys, thisLocalServer=targetServer)\n\n    setupMiniroot(minirootObj=minirootObj)\n\n    stubMountpoint = keys.disk.device_mount\n    jumpstartDir = os.path.join(stubMountpoint, \"jumpstart\")\n    injectJumpstartToMiniroot(jumpstartDir, minirootObj.mountpoint)\n    injectAgentFilesToMiniroot(\"/tmp/opt/opsware/agent\", minirootObj.mountpoint)\n    injectSmbiosToMiniroot(\"/dev/smbios\", minirootObj.mountpoint)\n\n    cleanupMiniroot(minirootObj=minirootObj)\n    print \"Prepare Miniroot x86 terminated successfully.\"\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "This program will unpack, resize and modify the Solaris miniroot to include\nall necessary files for automated installation.\n\nusage: prepare_miniroot.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Inject Required Jumpstart'", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:36:59.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:36:59.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "This program will unpack, resize and modify the Solaris miniroot to include\nall necessary files for automated installation.\n\nusage: prepare_miniroot.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Inject Required Jumpstart'", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:59.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:14.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:16.000Z", 
    "description": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/900001", 
    "modified": "2014-08-26T06:30:14.000Z", 
    "name": "Add ESXi Module", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" (c) Copyright 2009 Hewlett-Packard Development Company, L.P.\n\n    Create a new ESXi module that will be picked up by the ESXi boot configuration\n\"\"\"\n\nimport sys\nimport optparse\nimport os\nfrom osprov.osbp import logger\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError\nfrom osprov import helpers\n\nLOG = logger.getIt('esxi module')\n\n\ndef discoverTarget():\n    \"\"\" discover the target partition \"\"\"\n    target = helpers.getDataStore().disk.device_mount\n    if not target:\n        raise DiscoveryError(\"Can't determine target destination. \"\n                             \"Was the stub partition created?\")\n    return target\n\n\ndef findUnusedName():\n    \"\"\" Get a name that isn't used \"\"\"\n    start = 0\n    moduleDir = os.path.join(discoverTarget(), \"usermod\")\n    if not os.path.exists(moduleDir):\n        os.makedirs(moduleDir)\n    while os.path.exists(\"%s/mod%d\" % (moduleDir, start)):\n        start += 1\n    return \"%s/mod%d\" % (moduleDir, start)\n\n\ndef embed(opt):\n    \"\"\" Create an ESXi module from a file or directory \"\"\"\n    source = opt.source\n    target = findUnusedName()\n    modRoot = os.path.join(\"/tmp/_modroot\", os.path.basename(target))\n    alias_dir = os.path.join(modRoot, \"usr\")\n    alias_base = os.path.basename(source)\n    if opt.alias:\n        alias_base = opt.alias\n    alias = os.path.join(alias_dir, alias_base)\n    if not os.path.exists(alias_dir):\n        os.makedirs(alias_dir)\n    if os.path.exists(alias):\n        os.remove(alias)\n    os.symlink(source, alias)\n    if opt.double:\n        first = os.path.join(modRoot, alias_base + \".tar.gz\")\n        process.runIt(\"tar chzf %s usr\" % first,\n                      cwd=modRoot, quiet=True, log=LOG)\n        process.runIt(\"tar chzf %s %s\" % (target, alias_base + \".tar.gz\"),\n                      cwd=modRoot, quiet=True, log=LOG)\n        os.remove(first)\n    else:\n        process.runIt(\"tar chzf %s usr\" % target,\n                      cwd=modRoot, quiet=True, shell=True, log=LOG)\n    print \"Adding %s to ESXi module\" % (opt.source)\n\n\ndef parseArgs(args):\n    \"\"\"Parse the command line arguments\"\"\"\n    parser = optparse.OptionParser(description=__doc__)\n    parser.add_option('-s', '--source',\n                      help=\"A file or directory to create a module from\",\n                      metavar=\"SOURCE\")\n    parser.add_option('-a', '--alias',\n                      help=\"Alias the file or directory\",\n                      metavar=\"ALIAS\")\n    parser.add_option('-d', '--double',\n                      help=\"Create a tar in tar image to get arround vmware's vgz format\",\n                      action=\"store_true\", default=False)\n    opt, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional argumetns are not supported\")\n    if not opt.source:\n        parser.error(\"A source needs to be present\")\n    return opt\n\n\ndef main():\n    \"\"\" main entry point on the cmdline \"\"\"\n    opt = parseArgs(sys.argv[1:])\n    embed(opt)\n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "9", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:14.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-08-26T06:30:14.000Z", 
    "runAsSuperUser": false, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:17.000Z"
      }, 
      {
        "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:36.000Z"
      }, 
      {
        "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:57.000Z"
      }, 
      {
        "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:18.000Z"
      }, 
      {
        "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:37.000Z"
      }, 
      {
        "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "6", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:57.000Z"
      }, 
      {
        "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:14.000Z"
      }, 
      {
        "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:34.000Z"
      }, 
      {
        "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "9", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:14.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:48.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:18:48.000Z", 
    "description": "Script searches for the special embedded SD card device on ProLiant servers.  If the card is found, the custom attribute 'boot_disk' is set to the device associated with the card.  The 'boot_disk' CA is used in the \"Create Stub Partition\" step to force the creation of the initial installation OS boot partition on a specific disk.\n\nThis step will not clear boot_disk if the CA is set, but no device is found.\n\nParameters: none\n\nCustom Attributes: sets 'boot_disk'", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1690001", 
    "modified": "2014-03-28T00:18:48.000Z", 
    "name": "Find SD Card on Server", 
    "source": "#!/usr/bin/python\n# (c) Copyright 2013,2014 Hewlett-Packard Development Company, L.P.\n\nimport os\nimport sys\nimport re\n\nfrom osprov.osbp import logger\nfrom osprov.diskmgr import const\nfrom osprov.util import process\nfrom osprov.diskmgr.diskmanager import DiskManager, LinuxDiskManager\nfrom osprov.diskmgr.disk import Disk\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.parsers.proc_partitions import ProcPartitionsParser\n\nfrom osprov.server import ThisLocalServer\n\n\nfrom osprov import helpers\n\nID_BUS = re.compile(\"E: ID_BUS=*\")\nID_VENDOR = re.compile(\"E: ID_VENDOR=*\")\nID_MODEL = re.compile(\"E: ID_MODEL=Internal*\")\nBOOT_DISK_CA = \"boot_disk\"\n\nLOG = logger.getIt(\"osprov.diskmgr\")\n\ndef setBootDiskCA(targetServer, deviceName):\n    # if device name specified, then set the CA for the \n    # target server to it.  This will over ride the options in \n    # the \"Create Stub Partition\" step and force the use of the \n    # disk to be used as the target.\n    if deviceName:\n        serverRef = targetServer.getServerRef()\n        twistServer = targetServer.twistServer\n        twistServer.server.ServerService.setCustAttr(serverRef,\n            BOOT_DISK_CA, deviceName)   \n\n# Find all disks and then loop through them looking for \n# any disks that match the criteria used to designate an \n# embedded SD card.\n\ndef getAllSDDisks():\n    # Find all disks.\n    disks = []\n    print \"Finding all disks..\"\n    procPartitions = ProcPartitionsParser(open(const.PROC_PARTITIONS, \"r\")).info()\n    for deviceName,major,minor,blocs in procPartitions:\n        if \"loop\" in deviceName:\n            continue\n        if LinuxDiskManager.mod_map.has_key(major):\n            if minor % LinuxDiskManager.mod_map[major] == 0:\n                disks.append(LinuxDisk(deviceName, major, minor))\n        elif minor == 0:\n            disks.append(LinuxDisk(deviceName, major, minor))\n    \n    if not disks:\n\t# No disks found, just return.\n\tprint \"No disks found at all!!\"\n\treturn None\n\n    usbDisks = []\n    print \"Looking for matching disks..\"\n    for disk in disks:\n        hpilo = False\n        usb = False\n        sdcard = False\n        diskpath = disk.getDeviceFilePath()\n        devInfoOutput = process.getStdout([\"udevadm\", \"info\", \"-q\", \"all\", \"-n\",\n                diskpath], log=LOG)\n        for line in devInfoOutput.split('\\n'):\n            match = ID_BUS.match(line)\n            if match and \"usb\" in line:\n                # Disk is a USB disk\n                usb = True\n            match = ID_VENDOR.match(line)\n            if match and \"HP_iLO\" in line:\n                # Disk is embedded\n                hpilo = True\n            match = ID_MODEL.match(line)\n            if match and \"SD-CARD\" in line:\n                # Disk is an SD card.\n                sdcard = True\n            \n        # if criteria met, add disk to list else drop it.\n        if usb and sdcard and hpilo:\n            print \"  %s matched criteria\" % diskpath\n            usbDisks.append(diskpath)\n        else:\n            print \"  %s did not match criteria\" % diskpath\n    \n    return usbDisks\n\ndef main():\n    disks = getAllSDDisks()\n    if not disks:\n        print \"No acceptable SD disks found\"\n    else:\n        print \"Setting boot_disk to %s\" % disks[0]\n        targetServer = ThisLocalServer()\n        setBootDiskCA(targetServer, disks[0])\n        \nif __name__ == \"__main__\":\n    main()", 
    "state": null, 
    "version": {
      "usage": "Script searches for the special embedded SD card device on ProLiant servers.  If the card is found, the custom attribute 'boot_disk' is set to the device associated with the card.  The 'boot_disk' CA is used in the \"Create Stub Partition\" step to force the creation of the initial installation OS boot partition on a specific disk.\n\nThis step will not clear boot_disk if the CA is set, but no device is found.\n\nParameters: none\n\nCustom Attributes: sets 'boot_disk'", 
      "current": true, 
      "versionLabel": "19", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:48.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-28T00:18:48.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Script searches for the special embedded SD card device on ProLiant servers.  If the card is found, the custom attribute 'boot_disk' is set to the device associated with the card.  The 'boot_disk' CA is used in the \"Create Stub Partition\" step to force the creation of the initial installation OS boot partition on a specific disk.\n\nThis step will not clear boot_disk if the CA is set, but no device is found.\n\nParameters: none\n\nCustom Attributes: sets 'boot_disk'", 
        "current": true, 
        "versionLabel": "19", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:48.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:53.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:18:53.000Z", 
    "description": "Installs the Windows Hyper-V Role using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1780001", 
    "modified": "2014-03-28T00:18:53.000Z", 
    "name": "Add Windows Hyper-V Role", 
    "source": "@echo off\n\n:: (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nset wdir=%windir%\nset FEATURE=Hyper-V\nset RESULTFILE=\"%wdir%\\HVInstallResult.xml\"\n\n:: Try PowerShell if exists\nfor %%X in (powershell.exe) do (set FOUND1=%%~$PATH:X)\nif defined FOUND1 (\n   echo Import-module servermanager > \"%wdir%\\FeatureInstall.ps1\"\n   echo add-windowsfeature -Name %FEATURE% -logPath %RESULTFILE% -Restart >> \"%wdir%\\FeatureInstall.ps1\"\n   powershell.exe -ExecutionPolicy Unrestricted -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -File \"%wdir%\\FeatureInstall.ps1\"\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n)\n\n:: Try ServerManagerCmd if exists and PowerShell wasn't found\nfor %%X in (ServerManagerCmd.exe) do (set FOUND2=%%~$PATH:X)\nif defined FOUND2 (\n   ServerManagerCmd.exe -install %FEATURE% -resultPath %RESULTFILE% >> %temp%\\status.log\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n) \n\nif NOT defined rc (\n   echo PowerShell and ServerManagerCmd were not found and could not set %FEATURE%\n   set rc=99\n   goto End\n)\n\n:EndWithFailureMessage\nif NOT %rc%==0 (\n   echo PowerShell and ServerManagerCmd Add Windows Feature failed to install %FEATURE%:  error code %rc%\n   echo Refer to %RESULTFILE% log file.\n)\n\n:End\nexit /B %rc%", 
    "state": null, 
    "version": {
      "usage": "Installs the Windows Hyper-V Role using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None", 
      "current": true, 
      "versionLabel": "50", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:53.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-28T00:18:53.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs the Windows Hyper-V Role using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None", 
        "current": true, 
        "versionLabel": "50", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:53.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:24.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:24.000Z", 
    "description": "Installs Windows 2008 from OS Media. Requires full path to  setup.exe from the installation media.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1050001", 
    "modified": "2014-03-10T21:37:24.000Z", 
    "name": "Run Windows 2008 Setup", 
    "source": "@echo off\nsetlocal\nset SIG=WINPE32\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n", 
    "state": null, 
    "version": {
      "usage": "Installs Windows 2008 from OS Media. Requires full path to  setup.exe from the installation media.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:24.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-10T21:37:24.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs Windows 2008 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:24.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:39:44.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:39:44.000Z", 
    "description": "Script to clean the Oracle DbScanner on a managed server", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1440001", 
    "modified": "2014-03-10T21:39:44.000Z", 
    "name": "post-uninstall script for Database scanner for Oracle (unix)", 
    "source": "RMFOLDER=/opt/opsware/dbscanner.oracle\nif [ -d $RMFOLDER ]; then\n  rm -rf $RMFOLDER\nfi ", 
    "state": null, 
    "version": {
      "usage": "Script to clean the Oracle DbScanner on a managed server", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:39:44.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-10T21:39:44.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Script to clean the Oracle DbScanner on a managed server", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:39:44.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:41.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:54.000Z", 
    "description": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/600001", 
    "modified": "2014-08-26T06:30:41.000Z", 
    "name": "Run Windows 2012 x64 Setup", 
    "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n", 
    "state": null, 
    "version": {
      "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
      "current": true, 
      "versionLabel": "4", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:41.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-08-26T06:30:41.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:54.000Z"
      }, 
      {
        "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:49.000Z"
      }, 
      {
        "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:10.000Z"
      }, 
      {
        "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": true, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:41.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:23.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:14:51.000Z", 
    "description": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1630001", 
    "modified": "2014-08-26T06:30:23.000Z", 
    "name": "Remap Windows Drives", 
    "source": "#!/usr/bin/python\n\n############################################################################################\n# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n#\n# This script performs the following steps:\n#\n# 1. Gets the list of logical disks using \"win32com\". Network drives and WinPE (drive \"X:\")\n#    are not included in the list because they must not be remapped.\n# 2. Since the VID drives show up with an interface type of \"USB\", they are moved to the\n#    end of the list, so that they are mapped last when the new drive letters are assigned.\n# 3. Unmaps the logical disks from their associated drive letter.\n# 4. Maps the local disks to a drive letter, starting with the letter \"C\", in the same\n#    order in which they were found.  If the drive letter is being used by a network drive,\n#    or the drive letter is in the \"--reservedDriveLetters\" parameter, then the next letter\n#    will by tried, and so on.\n#\n############################################################################################\n\nimport subprocess\nfrom subprocess import Popen, PIPE, STDOUT\n\nimport sys\nimport re\nimport win32com.client \n\nfrom osprov.osbp import logger\nfrom osprov.errors import ShowErrorMessage\nfrom optparse import OptionParser\n\nDRIVE_TYPE_UNKNOWN = 0\nDRIVE_TYPE_NO_ROOT_DIRECTORY = 1\nDRIVE_TYPE_REMOVABLE_DISK = 2\nDRIVE_TYPE_LOCAL_DISK = 3\nDRIVE_TYPE_NETWORK_DRIVE = 4\nDRIVE_TYPE_COMPACT_DISC = 5\nDRIVE_TYPE_RAM_DISK = 6\n\nLOG = logger.getIt('remap_windows_drives')\n\n############################################################################################\n# Class to parse command line arguments.\n############################################################################################\n\nclass CustomParser(OptionParser):\n\t\"\"\" a custom parser \"\"\"\n\tdef __init__(self, *args, **kwargs):\n\t\tOptionParser.__init__(self, *args, **kwargs)\n\t\tself.add_option(\"--reservedDriveLetters\",\n\t\t\t\thelp=\"A space-separated list of drive letters that should not be used when remapping the drives\")\n\n############################################################################################\n# A disk class to hold some basic information about the disks.\n############################################################################################\n\nclass MyDisk:\n\tdef __init__(self):\n\t\tself.volumeName = None\n\t\tself.driveLetter = None\n\t\tself.label = None\n\t\tself.driveType = DRIVE_TYPE_UNKNOWN\n\t\tself.serialNum = None\n\t\tself.interfaceType = None\n\t\tself.size = None\n\t\n\tdef setVolumeName(self, volumeName):\n\t\tself.volumeName = volumeName\n\n\tdef setDriveLetter(self, driveLetter):\n\t\tself.driveLetter = driveLetter\n\n\tdef setLabel(self, label):\n\t\tself.label = label\n\n\tdef setDriveType(self, driveType):\n\t\tself.driveType = driveType\n\n\tdef setSerialNum(self, serialNum):\n\t\tself.serialNum = serialNum\n\n\tdef setInterfaceType(self, interfaceType):\n\t\tself.interfaceType = interfaceType\n\n\tdef setSize(self, size):\n\t\tself.size = size\n\n\tdef getVolumeName(self):\n\t\treturn self.volumeName\n\n\tdef getDriveLetter(self):\n\t\treturn self.driveLetter\n\n\tdef getLabel(self):\n\t\treturn self.label\n\n\tdef getDriveType(self):\n\t\treturn self.driveType\n\n\tdef getSerialNum(self):\n\t\treturn self.serialNum\n\n\tdef getInterfaceType(self):\n\t\treturn self.interfaceType\n\n\tdef getSize(self):\n\t\treturn self.size\n\n############################################################################################\n# Returns a different sequential drive letter each time its called, starting with \"C\".\n############################################################################################\n\ndef getNextDriveLetter():\n\tif not hasattr(getNextDriveLetter, \"letter\"):\n\t\tgetNextDriveLetter.letter = 'C'  # it doesn't exist yet, so initialize it\n\telif (getNextDriveLetter.letter is not None):\n\t\tif (getNextDriveLetter.letter == 'Z'):\n\t\t\tgetNextDriveLetter.letter = None\n\t\telse:\n\t\t\tgetNextDriveLetter.letter = chr(ord(getNextDriveLetter.letter)+1)\n\n\treturn getNextDriveLetter.letter\n\n############################################################################################\n# Returns a description for the specified drive type.\n#\n# Parameters:\n#     driveType - The numeric drive type\n#\n# Returns:\n#     The description associated with the numeric drive type.\n#\n############################################################################################\n\ndef driveTypeToDescription(driveType):\n\n\tdescription = \"Unknown\"\n\n\tif (driveType is not None):\n\t\tif (driveType == DRIVE_TYPE_UNKNOWN):\n\t\t\tdescription = \"Unknown\"\n\t\telif (driveType == DRIVE_TYPE_NO_ROOT_DIRECTORY):\n\t\t\tdescription = \"No Root Directory\"\n\t\telif (driveType == DRIVE_TYPE_REMOVABLE_DISK):\n\t\t\tdescription = \"Removable Disk\"\n\t\telif (driveType == DRIVE_TYPE_LOCAL_DISK):\n\t\t\tdescription = \"Local Disk\"\n\t\telif (driveType == DRIVE_TYPE_NETWORK_DRIVE):\n\t\t\tdescription = \"Network Drive\"\n\t\telif (driveType == DRIVE_TYPE_COMPACT_DISC):\n\t\t\tdescription = \"Compact Disc\"\n\t\telif (driveType == DRIVE_TYPE_RAM_DISK):\n\t\t\tdescription = \"RAM Disk\"\n\n\treturn description\n\n############################################################################################\n# Shows some basic information about the specified disks to assist with troubleshooting.\n#\n# Parameters:\n#     logicalDisks - The list of logical disks on the system\n#\n############################################################################################\n\ndef showLogicalDisks(logicalDisks):\n\n\tvolumeNum = 0\n\n        print \"%-8s %-3s %-15s %-15s %-10s %-15s %-10s\" % (\"\", \"\", \"\", \"Drive\", \"Interface\", \"\", \"\")\n        print \"%-8s %-3s %-15s %-15s %-10s %-15s %-10s\" % (\"Volume #\", \"Ltr\", \"Label\", \"Type\", \"Type\", \"Size\", \"Serial Number\")\n        print \"%-8s %-3s %-15s %-15s %-10s %-15s %-10s\" % (\"--------\", \"---\", \"---------------\", \"---------------\", \"----------\", \"---------------\", \"----------\")\n\n\tfor logicalDisk in logicalDisks:\n\t\tif (logicalDisk.getDriveLetter() is not None):\n\t\t\tdriveLetter = logicalDisk.getDriveLetter()\n\t\telse:\n\t\t\tdriveLetter = \"\"\n\n\t\tif (logicalDisk.getLabel() is not None):\n\t\t\tlabel = logicalDisk.getLabel()\n\t\telse:\n\t\t\tlabel = \"\"\n\n\t\tif (logicalDisk.getInterfaceType() is not None):\n\t\t\tinterfaceType = logicalDisk.getInterfaceType()\n\t\telse:\n\t\t\tinterfaceType = \"\"\n\n\t\tif (logicalDisk.getSize() is not None):\n\t\t\tsize = logicalDisk.getSize()\n\t\telse:\n\t\t\tsize = \"\"\n\n\t\tif (logicalDisk.getSerialNum() is not None):\n\t\t\tserialNum = logicalDisk.getSerialNum()\n\t\telse:\n\t\t\tserialNum = \"\"\n\n\t\tprint \"%-8s %-3s %-15s %-15s %-10s %15s %-10s\" % (volumeNum, driveLetter, label, driveTypeToDescription(logicalDisk.getDriveType()), interfaceType, size, serialNum)\n\n\t\tvolumeNum += 1\n\n############################################################################################\n# Returns a list of the logical disks on the system.  Network drives and WinPE (drive \"X:\")\n# are not included in the list because they must not be remapped.\n############################################################################################\n\ndef getLogicalDisks():\n\t\n\t# The list of logical disks that we need to remap.\n\tlogicalDisks = []\t\n\n\t# The drive letters that are in use by a network drive or WinPE.  When we remap the\t\n\t# disks to a new drive letter, these drive letters will not used during the\t\n\t# remapping, since they are already in use.\n\tdriveLettersInUse = []\t\n\n\tstrComputer = \".\" \n\tobjWMIService = win32com.client.Dispatch(\"WbemScripting.SWbemLocator\") \n\tobjSWbemServices = objWMIService.ConnectServer(strComputer,\"root\\cimv2\") \n\tcolItems= objSWbemServices.ExecQuery(\"Select * from Win32_LogicalDisk\")\t\n\n\t# Create a list of the logical drives, but skip the network drives and the \"X:\"\n\t# drive, since that is reserved for WinPE.  The drive letters for any drives\n\t# we skip will be stored in the \"driveLettersInUse\" list, so that we know\n\t# that we can't use those letters when we are remapping the drives.\n\tfor objItem in colItems:\n\t\tif (objItem.Caption is None) or (len(objItem.Caption.strip()) == 0):\n\t\t\t# We are only interested in remapping drives that are already\n\t\t\t# mapped to a drive letter. It doesn't seem that our query\n\t\t\t# to Win32_LogicalDisk returns any logical disks that don't\n\t\t\t# have a drive letter assigned anyway, but we test for it\n\t\t\t# just as a precaution.\n\t\t\tprint \"Skipping drive with label '%s' because it's not mapped to a drive letter\" % objItem.VolumeName\n\t\telif (objItem.Caption == \"X:\"):\n\t\t\tprint \"Skipping drive '%s' which is reserved for WinPE\" % objItem.Caption\n\t\t\tdriveLettersInUse.append(objItem.Caption.replace(\":\", \"\"))\n\t\telif (objItem.driveType == DRIVE_TYPE_NETWORK_DRIVE):\n\t\t\tprint \"Skipping drive '%s' which is a network drive\" % objItem.Caption\n\t\t\tdriveLettersInUse.append(objItem.Caption.replace(\":\", \"\"))\t\n\t\telse:\n\t\t\tlogicalDisk = MyDisk()\n\t\t\tlogicalDisk.setDriveLetter(objItem.Caption)\n\t\t\tlogicalDisk.setLabel(objItem.VolumeName)\n\t\t\tlogicalDisk.setDriveType(objItem.DriveType)\n\t\t\tlogicalDisk.setSize(objItem.Size)\n\t\t\tlogicalDisk.setSerialNum(objItem.VolumeSerialNumber)\n\n\t\t\t# Get the interface type as reported by the \"diskpart\"\n\t\t\t# utility. The interface type is needed to help us identify\n\t\t\t# the VID drives, which show up with an interface type of\n\t\t\t# \"USB\".\n\t\t\tinterfaceType = getInterfaceTypeFromDriveLetter(logicalDisk.getDriveLetter().replace(\":\", \"\"))\n\t\t\tlogicalDisk.setInterfaceType(interfaceType)\n\n\t\t\t# Get the volume name that's mapped to the specified\n\t\t\t# drive letter.\n\t\t\tvolumeName = getVolumeNameFromDriveLetter(logicalDisk.getDriveLetter());\n\t\t\tlogicalDisk.setVolumeName(volumeName)\n\n\t\t\tlogicalDisks.append(logicalDisk)\n\n   \treturn logicalDisks, driveLettersInUse\n\n############################################################################################\n# Returns the \"diskpart\" volume number associated with the specified drive letter.\n#\n# Parameters:\n#     driveLetter - The drive letter\n#\n############################################################################################\n\ndef getVolumeNumFromDriveLetter(driveLetter):\n\n\tvolumeNumber = None\n\n\tdiskpartCmd = \"list volume\\n\"\n\n\t# Run \"diskpart\" and list the volumes.\n\tp = subprocess.Popen(['diskpart'],stdout=PIPE,stderr=STDOUT,stdin=PIPE)\n\n\t# Get the stdout/stderr of the command.\n\tdiskpart_stdout = p.communicate(input=diskpartCmd)[0]\n\n\tretCode = p.poll()\n\n\tp.stdout.close()\n\n\t# This regular expression extracts the volume number associated with the drive\n\t# letter if there's a match. The \"(\\d+)\" is what puts the volume number for the\n\t# matching drive letter in the variable \"result.group(1)\".\n\tpattern = re.compile(r\"^\\s*Volume\\s*(\\d+)\\s*\" + driveLetter + \"\\s*.*\")\n\n\tfor line in diskpart_stdout.splitlines():\n\t\tresult = pattern.search(line)\n\n\t\tif result:\n\t\t\tvolumeNumber = result.group(1)\n\t\t\tbreak\n\n\treturn volumeNumber\n\n############################################################################################\n# Returns the volume name associated with the specified drive letter.\n#\n# Parameters:\n#     driveLetter - The drive letter\n#\n############################################################################################\n\ndef getVolumeNameFromDriveLetter(driveLetter):\n\n\tvolumeName = None\n\n\tmountPoint = driveLetter + \"\\\\\"\n\n\t# Use the \"mountvol\" command to list the volume name for the specified mount point.\n\tp = subprocess.Popen ([\"mountvol\", mountPoint, \"/L\"], stdout=subprocess.PIPE, stderr=STDOUT)\n\tmountvol_stdout = p.communicate()[0].strip()\n\n\tretCode = p.poll()\n\n\tp.stdout.close()\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing 'mountvol %s %s' : %s\" % (mountPoint, \"\\L\", mountvol_stdout))\n\telse:\n\t\tvolumeName = mountvol_stdout\n\n\treturn volumeName\n\n############################################################################################\n# Returns the interface type (e.g. \"USB\", \"FIBRE\", \"RAID\", etc) associated with the\n# specified drive letter.  We have to first map the drive letter to the volume number as\n# reported by \"diskpart\".  Once we have the volume number, we can select the volume in\n# \"diskpart\" and tell it to give us the details for the disk.  The details will report the\n# interface type in the \"Type :\" field, so we must parse the output of the details and\n# extract the value from the \"Type :\" field.\n#\n# Parameters:\n#     driveLetter - The drive letter\n#\n############################################################################################\n\ndef getInterfaceTypeFromDriveLetter(driveLetter):\n\n\tdriveType = None\n\n\t# Get the volume number, as reported by \"diskpart\", that's associated with the\n\t# drive letter.\n\tvolumeNum = getVolumeNumFromDriveLetter(driveLetter)\n\n\tif (volumeNum is not None):\n\t\t# Tell \"diskpart\" to give us the details for the disk associated with the\n\t\t# specified volume number.  The details contain a \"Type :\" field that has\n\t\t# the interface type of the disk.\n\t\tdiskpartCmd = \"select volume \" + str(volumeNum) + \"\\n\" + \"detail disk\" + \"\\n\"\n\n\t\tp = subprocess.Popen(['diskpart'],stdout=PIPE,stderr=STDOUT,stdin=PIPE)\n\n\t\t# Get the stdout/stderr of the command.\n\t\tdiskpart_stdout = p.communicate(input=diskpartCmd)[0]\n\n\t\tretCode = p.poll()\n\n\t\tp.stdout.close()\n\n\t\t# This regular expression extracts the interface type from the \"Type :\"\n\t\t# field, if there's a match. The \"(.+)\" is what puts the interface type\n\t\t# in the variable \"result.group(1)\".\n\t\tpattern = re.compile(r\"^\\s*Type\\s*:\\s*(.+)\\s*$\")\n\n\t\tfor line in diskpart_stdout.splitlines():\n\t\t\tresult = pattern.search(line)\n\n\t\t\tif result:\n\t\t\t\tdriveType = result.group(1)\n\t\t\t\tbreak\n\n\treturn driveType\n\n############################################################################################\n# Moves any USB drives to the end of the list of logical disks.\n#\n# Parameters:\n#     logicalDisks - The list of logical disks on the system\n#\n############################################################################################\n\ndef moveUsbDrivesToEndOfList(logicalDisks):\n\n        reorderedLogicalDisks = []\n\n\tusbDisks = []\n\n\t# Remove any VID disks from the logical disk list.\n        for logicalDisk in logicalDisks:\n\t\tif (logicalDisk.getInterfaceType() == \"USB\"):\n\t\t\t # Append the disk to the USB list.\n\t\t\tusbDisks.append(logicalDisk)\n\t\telse:\n\t\t\t# Append the disk to the reordered logical disk list.\n\t\t\treorderedLogicalDisks.append(logicalDisk)\n\n\t# Put back the USB disks at the end of the reordered logical disk list.\n\tfor usbDisk in usbDisks:\n\t\treorderedLogicalDisks.append(usbDisk)\n\n        return reorderedLogicalDisks\n\n############################################################################################\n# Assigns drive letters to the unmapped disks.\n#\n# Parameters:\n#    unmappedDisks - The disks that are not mapped to a drive letter.\n#    reservedDriveLetters - A list of drive letters that are in use or resevered, so that we\n#                           don't try to assign one of those drive letters to an unmapped\n#                           disk.\n############################################################################################\n\ndef assignDriveLetters(unmappedDisks, reservedDriveLetters):\n\n \tprint \"Assigning drive letters\"\n\n\tprint \"The following drive letters are reserved or in use : \" + ','.join(reservedDriveLetters)\n\n        volumeNum = 0\n\n\tfor disk in unmappedDisks:\n               # Only map a drive letter to a local disk.  Disks on a SAN should be identified\n                # as local disks.\n                if (disk.getDriveType() == DRIVE_TYPE_LOCAL_DISK):\n\t\t\t# Get a drive letter that's not reserved or is already in use by another disk.\n\t\t\tdriveLetter = getNextDriveLetter()\n\t\t\twhile ((driveLetter is not None) and (driveLetter in reservedDriveLetters)):\n\t\t\t\tprint \"Drive letter '%s' is reserved or is in use.  Trying next drive letter.\" % driveLetter\n\t\t\t\tdriveLetter = getNextDriveLetter()\n\n\t\t\t# Map the disk to the drive letter.\n\t\t\tif (driveLetter is not None):\n\t\t\t\tmountPoint = driveLetter + \":\\\\\"\n\t\t\t\tprint \"Remapping volume '%s' as drive letter '%s'\" % (disk.getVolumeName(),driveLetter)\n\n\t\t\t\tp = subprocess.Popen ([\"mountvol\", mountPoint, disk.getVolumeName()], stdout=subprocess.PIPE, stderr=STDOUT)\n\n\t\t\t\t# Get the stdout/stderr of the command.\n\t\t\t\tmountvol_stdout = p.communicate()[0]\n\n\t\t\t\tretCode = p.poll()\n\n\t\t\t\tp.stdout.close()\n\n\t\t\t\tif (retCode != 0):\n\t\t\t\t\tprint \"AN ERROR OCCURRED\"\n\t\t\t\t\traise ShowErrorMessage(\"An error occurred while executing 'mountvol %s %s' : %s\" % (mountPoint, disk.getVolumeName(), mountvol_stdout))\n\t\t\t\telse:\n\t\t\t\t\t# Update the drive letter. This is done so we\n\t\t\t\t\t# can display the new drive letter assignments\n\t\t\t\t\t# when we're done with the remapping.\n\t\t\t\t\tdisk.setDriveLetter(driveLetter)\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"No more drive letters to assign to volume '%s'\" % disk.getVolumeName())\n                else:\n\t\t\t# Clear the drive letter, since we're not going to remap this drive.\n\t\t\t# This is done so that when we display the remapped drives, we can\n\t\t\t# see that this drive wasn't mapped to a letter.\n\t\t\tdisk.setDriveLetter(None)\n\n                        print \"Not remapping volume '%s' because its drive type is '%s'\" % (disk.getVolumeName(),driveTypeToDescription(disk.getDriveType()))\n\n\t\tvolumeNum += 1\n\n############################################################################################\n# Remove the drive letters from the specified list of disks.\n#\n# Parameters:\n#     logicalDisks - The list of logical disks on the system\n#\n############################################################################################\n\ndef removeDriveLetters(logicalDisks):\n\n \tprint \"Removing drive letters\"\n\n\tfor disk in logicalDisks:\n\t\tmountPoint = disk.getDriveLetter() + \"\\\\\"\n\n\t\tprint \"Removing mount point '%s' for volume '%s'\" % (mountPoint,disk.getVolumeName())\n\n\t\t# Remove the volume mount point, effectively removing the drive letter from\n\t\t# the volume. \n\t\tp = subprocess.Popen ([\"mountvol\", mountPoint, \"/D\"], stdout=subprocess.PIPE, stderr=STDOUT)\n\t\tmountvol_stdout = p.communicate()[0].strip()\n\n\t\tretCode = p.poll()\n\n\t\tp.stdout.close()\n\n\t\tif (retCode != 0):\n\t\t\tprint \"AN ERROR OCCURRED\"\n\t\t\traise ShowErrorMessage(\"An error occurred while executing 'mountvol %s %s' : %s\" % (mountPoint, \"\\D\", mountvol_stdout))\n\n############################################################################################\n# Remaps the specific disks so that their drive letters begin with \"C:\", \"D:\", \"E:\", etc.\n#\n# Parameters:\n#    logicalDisks - The list of disks that are to be remapped.\n#    reservedDriveLetters - A list of drive letters that are in use or resevered, so that we\n#                           don't try to assign one of those drive letters to an unmapped\n#                           disk.\n############################################################################################\n\ndef remapDrives(logicalDisks, reservedDriveLetters):\n\n\tremoveDriveLetters(logicalDisks)\n\n\tassignDriveLetters(logicalDisks, reservedDriveLetters)\n\n############################################################################################\n# The main function.\n############################################################################################\n\ndef main(argv):\n\n\treservedDriveLetters = []\n\n\ttry:\n        \targs_parser = CustomParser()\n        \toptions, remaining_args = args_parser.parse_args(sys.argv[1:])\n\n\t\tif (options.reservedDriveLetters is not None):\n\t\t\t# Remove any occurrence of \":\", since the SystemDrive custom\n\t\t\t# attribute may be used in the parameter and it contains a \":\"\n\t\t\t# after the drive letter.\n\t\t\ttempDriveLetters = options.reservedDriveLetters.replace(':', '')\n\n\t\t\t# Collapse multiple spaces between the letters into a single space,\n\t\t\t# then split the string and create a list of drive letters.\n\t\t\trex = re.compile(r'\\W+')\t\n\t\t\ttempDriveLetters = rex.sub(' ', tempDriveLetters)\n\n\t\t\treservedDriveLetters = rex.sub(' ', tempDriveLetters).split(' ')\n\n\t\tlogicalDisks, driveLettersInUse = getLogicalDisks()\n\n\t\t# Add the drive letters assigned to network drives and WinPE to the list\n\t\t# of reserved letters.\n\t\treservedDriveLetters.extend(driveLettersInUse)\n\n\t\t# Convert drive letters to uppercase.\n\t\treservedDriveLetters = [x.upper() for x in reservedDriveLetters]\n\n\t\tprint \"Disks before remapping\"\n\n\t\tshowLogicalDisks(logicalDisks)\n\n\t\tlogicalDisks = moveUsbDrivesToEndOfList(logicalDisks)\n\n\t\tremapDrives(logicalDisks, reservedDriveLetters)\n\n\t\tprint \"Disks after remapping\"\n\n\t\tshowLogicalDisks(logicalDisks)\n\texcept (ShowErrorMessage), why:\n\t\tLOG.exception(why)\n\t\tsys.stderr.write(\"Failed to remap Windows drives: %s\\n\" % why)\n\t\treturn 1\n\nif __name__ == \"__main__\":\n\tsys.exit(main(sys.argv))", 
    "state": null, 
    "version": {
      "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None", 
      "current": true, 
      "versionLabel": "302", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:22.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-08-26T06:30:23.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None", 
        "current": false, 
        "versionLabel": "295", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:51.000Z"
      }, 
      {
        "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None", 
        "current": false, 
        "versionLabel": "296", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:11.000Z"
      }, 
      {
        "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None", 
        "current": false, 
        "versionLabel": "297", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:53.000Z"
      }, 
      {
        "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None", 
        "current": false, 
        "versionLabel": "298", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:14.000Z"
      }, 
      {
        "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None", 
        "current": false, 
        "versionLabel": "299", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:32.000Z"
      }, 
      {
        "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None", 
        "current": false, 
        "versionLabel": "300", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:35.000Z"
      }, 
      {
        "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None", 
        "current": false, 
        "versionLabel": "301", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:11.000Z"
      }, 
      {
        "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None", 
        "current": true, 
        "versionLabel": "302", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:22.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:50.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:18:49.000Z", 
    "description": "Installs the Windows Multipath IO Feature using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1720001", 
    "modified": "2014-03-28T00:18:50.000Z", 
    "name": "Add Windows Multipath IO Feature", 
    "source": "@echo off\n\n:: (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nset wdir=%windir%\nset FEATURE=Multipath-IO\nset RESULTFILE=\"%wdir%\\MPIOInstallResult.xml\"\n\n:: Try PowerShell if exists\nfor %%X in (powershell.exe) do (set FOUND1=%%~$PATH:X)\nif defined FOUND1 (\n   echo Import-module servermanager > \"%wdir%\\FeatureInstall.ps1\"\n   echo add-windowsfeature -Name %FEATURE% -logPath %RESULTFILE% -Restart >> \"%wdir%\\FeatureInstall.ps1\"\n   powershell.exe -ExecutionPolicy Unrestricted -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -File \"%wdir%\\FeatureInstall.ps1\"\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n)\n\n:: Try ServerManagerCmd if exists and PowerShell wasn't found\nfor %%X in (ServerManagerCmd.exe) do (set FOUND2=%%~$PATH:X)\nif defined FOUND2 (\n   ServerManagerCmd.exe -install %FEATURE% -resultPath %RESULTFILE% >> %temp%\\status.log\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n) \n\nif NOT defined rc (\n   echo PowerShell and ServerManagerCmd were not found and could not set %FEATURE%\n   set rc=99\n   goto End\n)\n\n:EndWithFailureMessage\nif NOT %rc%==0 (\n   echo PowerShell and ServerManagerCmd Add Windows Feature failed to install %FEATURE%:  error code %rc%\n   echo Refer to %RESULTFILE% log file.\n)\n\n:End\nexit /B %rc%", 
    "state": null, 
    "version": {
      "usage": "Installs the Windows Multipath IO Feature using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None", 
      "current": true, 
      "versionLabel": "19", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:50.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-28T00:18:50.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs the Windows Multipath IO Feature using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None", 
        "current": true, 
        "versionLabel": "19", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:50.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:41.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:40.000Z", 
    "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Ubuntu Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1360001", 
    "modified": "2014-03-10T21:37:41.000Z", 
    "name": "Install bootloader for Ubuntu Server", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nThis python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, NotFoundError, ShowErrorMessage\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import Netconfig\nfrom osprov.parsers.netconfig import getActiveInterface\nfrom osprov.server import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n# for easier mocking\n\n\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef readFile(filepath):\n    \"\"\"Reads from the file identified by filepath\"\"\"\n    return open(filepath).read()\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATH = \"boot/grub/menu.lst\"\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\" % (source, destination))\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATH = os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\")\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                      % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                         'bootDiskMount': bootDiskMount,\n                         'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                         'bootDisk': bootDisk}, log=LOG, quiet=True)\n        # configure the UEFI boot entries\n        osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    search -n -u %(device_uuid)s -s\n    linux  /%(kernel)s %(kernelArguments)s\n    initrd %(initrds)s\n}\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef configureKernelArguments(osdata, keys, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    os_version = osdata[\"os_version\"]\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in os_version and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    netconfig_ca = StringIO(\"\"\"@hpsa_netconfig@\"\"\")\n    parser = Netconfig.readonly(netconfig_ca)\n    try:\n        activeKey, activeIface = getActiveInterface(localServer, parser.info())\n    except NotFoundError:\n        activeIface = None\n    ip_params = \"\"\n    if activeIface and activeIface.static:\n        net_data = {\n            \"ip\": activeIface.ip[0],\n            \"mask\": activeIface.mask[0],\n            \"dns\": \"\",\n            \"gw\": \"\",\n        }\n        # Static provisioning\n        if hasattr(activeIface, \"dns\") and activeIface.dns:\n            net_data[\"dns\"] = activeIface.dns[0]\n        if hasattr(activeIface, \"gw\"):\n            net_data[\"gw\"] = activeIface.gw[0]\n        ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n    else:\n        # dhcp provisioning\n        ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if not osdata.has_key(\"initrd\"):\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = \"Ubuntu Server\"\n    osdata[\"os_version\"] = \"UBUNTU\"\n    osdata[\"install_params\"] = \"BOOTIF=%(bootif)s priority=critical\"\n    osdata[\"ip_config_static\"] = \"\"\n    osdata[\"ip_config_dhcp\"] = \"\"\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n\n    _open(os.path.join(bootDiskMount, grub.MENU_PATH), \"w\").write(menu)\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Ubuntu Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:41.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-10T21:37:41.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Ubuntu Server installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:41.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:01.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:01.000Z", 
    "description": "This program will copy the kernel and boot archive to the stub partition,\ncreating any necessary directory structure along the way.\n\nUsage: deploy_boot_files.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Modify Boot Archive'", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/690001", 
    "modified": "2014-03-10T21:37:01.000Z", 
    "name": "Deploy Solaris Boot Files", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n\"\"\"\nThis program will copy the kernel and boot archive to the stub partition,\ncreating any necessary directory structure along the way.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nimport shutil\n\nfrom osprov import helpers\nfrom osprov.osbp import logger\nfrom osprov.errors import NotSupportedError\nfrom osprov.decorators import HandleShowErrorMessage\n\n\ndef getOsStructs():\n    if os.uname()[-1].startswith(\"i86\"):\n        platform = os.uname()[-1]\n        return \"platform/%s/kernel/amd64/\" % platform, \"platform/%s/amd64/\" % platform\n    else:\n        raise NotSupportedError(\"Module not available yet on SPARC.\")\n\nLOG = logger.getIt(\"Install Boot Files\")\n\n\n@HandleShowErrorMessage(\"Install Solaris Boot Files\", LOG)\ndef main():\n    \"\"\"Main function to run when the module is executed as a script.\"\"\"\n\n    kernelDirStruct, baDirStruct = getOsStructs()\n\n    keys = helpers.getDataStore()\n    stub_path = keys.disk.device_mount\n    bootfiles_dir = os.path.join(stub_path, \"bootfiles\")\n\n    LOG.info(\"Creating directory structure for the boot files.\")\n    kernel_dir = os.path.join(stub_path, kernelDirStruct)\n    ba_dir = os.path.join(stub_path, baDirStruct)\n    helpers.makeDirs(kernel_dir)\n    helpers.makeDirs(ba_dir)\n\n    LOG.info(\"Copying the kernel and the boot archive to the stub partition.\")\n    shutil.copy2(os.path.join(bootfiles_dir, \"unix\"), kernel_dir)\n    shutil.copy2(os.path.join(bootfiles_dir, \"boot_archive\"), ba_dir)\n\n    LOG.info(\"Cleaning up the rest of the boot files.\")\n    shutil.rmtree(bootfiles_dir, ignore_errors=True)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "This program will copy the kernel and boot archive to the stub partition,\ncreating any necessary directory structure along the way.\n\nUsage: deploy_boot_files.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Modify Boot Archive'", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:01.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:01.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "This program will copy the kernel and boot archive to the stub partition,\ncreating any necessary directory structure along the way.\n\nUsage: deploy_boot_files.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Modify Boot Archive'", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:01.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:28.000Z", 
    "serverChanging": true, 
    "created": "2014-08-26T06:30:27.000Z", 
    "description": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1830001", 
    "modified": "2014-08-26T06:30:28.000Z", 
    "name": "Install Windows WBEM zack", 
    "source": "@echo off\n\n:: (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nsetlocal EnableDelayedExpansion EnableExtensions\n\n:: Drive letter to mount the media server, colon must be included\nset driveletter=z:\n\n:: ====================\n:: Determine what calling arguments\n:: ====================\nset opt=0\nset failonwarning=0\nset hpsumargs=/s /f:software cp019017.exe /continue_on_error FailedDependencies\nset log_dir=%SYSTEMDRIVE%\\cpqsystem\\hp\\log\n:OptionsLoop\n  if [%1]==[] goto DetermineSPPVersion\n\n  if \"%1\"==\"--spp_version\" (\n     set sppversion=%2\n     set opt=0\n     goto OptionsShift\n  )\n\n  if \"%1\"==\"--fail_on_warning\" (\n     set failonwarning=1\n     goto OptionsShift\n  )\n\n  if \"%opt%\"==\"1\" (\n     set hpsumargs=%hpsumargs% %1\n     set log_dir=%1\n     goto OptionsShift\n  )\n\n  if \"%1\"==\"--hpsum_options\" (\n     set opt=1\n     goto OptionsShift\n  )\n\n  :OptionsShift\n  shift\ngoto OptionsLoop\n\n\n:DetermineSPPVersion\n:: ====================\n:: Determine SPP Version to install\n:: ====================\nif \"%sppversion%\"==\"\" (\ngoto SPPVersion\n) else (\ngoto SetAssignMediaPath\n)\ngoto RunHPSUM\n\n:SPPVersion\n   %driveletter%\n   cd \\media\\spp\n   set sppdir=\n   for /f \"tokens=* delims=0\" %%i in ('dir /b /a:d') do set sppdir=%%i\n   cd \\media\\spp\\%sppdir%\n   set buildir=\n   for /f \"tokens=* delims=0\" %%i in ('dir /b /a:d') do set buildir=%%i\n   set sppversion=%buildir%\n   if \"%sppversion%\"==\"\" (\n      echo Did not find an SPP Version on the media server\n      set rc=999\n      goto End\n   )\n   cd \\media\\spp\\%sppdir%\\%sppversion%\\hp\\swpackages\n\n:SetAssignMediaPath\n   echo Enter SetAssignMediaPath\n   %driveletter%\n   cd \\media\\spp\\@SPP_VER@\\@BUILD_VER@\\hp\\swpackages\n   \n:RunHPSUM\n:: ====================\n:: Run HPSUM\n:: ====================\n\necho SPP version to be installed is %sppdir%\\%sppversion%\necho Additional hpsum arguments are %hpsumargs%\n:: Must be run as currently running directory\n\nhpsum.exe %hpsumargs%\n\nset rc=%ERRORLEVEL%\n\nif %rc% GEQ 0 (\n if %rc%==0 (\n  echo SPP hpsum ran successfully: return code %rc%\n  GOTO Success\n )\n if %rc%==1 ( \n  echo The installation was successful,but a reboot is required: return code %rc%\n  GOTO Success\n )\n if %rc%==3 (\n  echo The component was current or not required: return code %rc%\n  GOTO Success\n )\n if %rc%==253 (\n  set rc=-3\n  )\n\n if %rc%==254 (\n  set rc=-2\n )\n if %rc%==255 (\n  set rc=-1\n ) \n)\n\nif %rc% LSS 0 (\n if %rc%==-1 (\n  echo A general failure occurred. For details, see the error log.\n  GOTO Fail\n )\nif %rc%==-2 (\n  echo A bad input parameter was encountered.\n  GOTO Fail\n )\nif %rc%==-3 (\n  if %failonwarning%==1 (\n   echo ERROR - One or more components failed to install\n   echo fail_on_warning is set\n   GOTO Fail\n  )\n  if %failonwarning%==0 GOTO FinishWithWarning\n ) ELSE (\nGOTO Fail\n)  \n)\n\n\n:Success\necho hpsum logs are located at %log_dir% unless specified otherwise by hpsum /logdir option\n:: Change return code to 0 for hpsum positive return codes\nset rc=0\ngoto End\n\n:FinishWithWarning\n   echo SPP hpsum failed: error code %rc%\n   echo WARNING - One or more of the smart components failed to install. Depending on the system configuration,\n   echo this may be expected behavior. To verify the installation, check the hpsum logs are located at\n   echo %log_dir% unless specified otherwise by hpsum /logdir option.  \n   echo To fail the build plan when these warnings occur, specify the --fail_on_warning option to this step.\nset rc=0\ngoto End\n\n:Fail\n   echo SPP hpsum failed: error code %rc%\n   echo %log_dir% unless specified otherwise by hpsum /logdir option.\n   goto End\n\n\n:End\n:: Return to system drive, so can unmount media server drive\n%SYSTEMDRIVE%\nnet use %driveletter% /delete\nexit /B %rc%\n", 
    "state": null, 
    "version": {
      "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
      "current": true, 
      "versionLabel": "2", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:28.000Z"
    }, 
    "isCustomerContent": true, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-08-26T06:30:28.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": true, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:28.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:27.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:27.000Z", 
    "description": "Installs Windows 2003 from OS Media. Requires  full path to winnt32.exe from the installation media.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1110001", 
    "modified": "2014-03-10T21:37:27.000Z", 
    "name": "Run Windows 2003 Setup", 
    "source": "@echo off\nsetlocal\nset SIG=WINPE32\nset ANSWER=X:\\Windows\\Temp\\Unattend.txt\nset ARGS=/noreboot /unattend:%ANSWER% /syspart:@SystemDrive:C@: /tempdrive:@SystemDrive:C@: /debug3:%SystemDrive%\\install.log\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n", 
    "state": null, 
    "version": {
      "usage": "Installs Windows 2003 from OS Media. Requires  full path to winnt32.exe from the installation media.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:27.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-10T21:37:27.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs Windows 2003 from OS Media. Requires  full path to winnt32.exe from the installation media.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:27.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:10:10.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:10.000Z", 
    "description": "This script erases the partition table on all detected disk drives.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/760001", 
    "modified": "2014-03-28T00:10:10.000Z", 
    "name": "Erase Server Disk", 
    "source": "#!/opt/opsware/agent/bin/python\n\n\n# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\n# This script runs dd on all the devices on the server where it's run to\n# erase the partition table\n\nimport re\nimport commands\nimport subprocess\nfrom osprov.diskmgr.diskmanager import DiskManager\nfrom osprov.errors import ProcessExecutionError\nfrom osprov.osbp import logger\n\nLOG = logger.getIt(\"osprov.diskmgr\")\n\n\ndef scan():\n    '''\n    Get the list of (partitioned) hard drives on this server.\n    Uses 'parted -lm', which requires superuser permission.\n    '''\n    disks = []\n    args = [\"parted\", \"--list\", \"--machine\"]\n    # /dev/sda:36.4GB:scsi:512:512:msdos:HP LOGICAL VOLUME;\n    regex = re.compile(r\"^(/dev/[hs]d\\w+):.*:.*:\\d+:\\d+:.*:(.*);$\")\n    proc = subprocess.Popen(args, stdout=subprocess.PIPE)\n    for line in proc.stdout:\n        match = regex.match(line)\n        if match:\n            dev = match.group(1)\n            name = match.group(2)\n            if \"HP iLO LUN\" in name:\n                # print \"exclude %s [%s]\" % (dev, name)\n                continue    # skip Gaius flash media\n            # print \"include %s [%s]\" % (dev, name)\n            disks.append(dev)\n    return disks\n\n\ndef eraseDisk():\n    '''\n    Get the list of hard drives on this server and run dd on it\n    to zero out the first 1M bytes.\n    '''\n    hdList = scan()\n\n    for deviceName in hdList:\n        # For each device name returned, run dd on it\n\n        cmdStr = \"dd if=/dev/zero of=\" + deviceName + \" bs=8k count=128\"\n        # print \"Performing dd: Cmd String used: %s\" % cmdStr\n\n        status, output = commands.getstatusoutput(cmdStr)\n        if status != 0:\n            raise Exception(\"dd failed with exitcode %d: Msg:%s\" % (status, output))\n        print \"Successfully erased disk \" + deviceName\n\nif __name__ == \"__main__\":\n    dm = DiskManager(log=LOG)\n    dm.disable_automount()\n    dm.unmountOurs()\n    dm.unmountDisks(skipUsb=True)\n\n    inventory_disks = dm.get_disk_inventory()\n    disks = []\n\n    hdList = scan()\n\n    # filtering out Gaius flash media from disk inventory\n    for temp_disk in inventory_disks:\n        if temp_disk.getDeviceFilePath() in hdList:\n            disks.append(temp_disk)\n\n    for temp_disk in disks:\n        temp_disk.releaseAndUnload()\n\n    eraseDisk()\n\n    # refreshing kernel partition table\n    for temp_disk in disks:\n        try:\n            temp_disk.rescan()\n        except ProcessExecutionError, why:\n            print \"Warning : Rereading partition table for %s failed : %s. Reboot to refresh partition table.\" % (temp_disk.getDeviceFilePath(), why)\n", 
    "state": null, 
    "version": {
      "usage": "This script erases the partition table on all detected disk drives.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "2", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:10:10.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-28T00:10:10.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "This script erases the partition table on all detected disk drives.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:10.000Z"
      }, 
      {
        "usage": "This script erases the partition table on all detected disk drives.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:10:10.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:40.000Z", 
    "serverChanging": false, 
    "created": "2014-03-10T21:37:40.000Z", 
    "description": "This script injects the device name in the <partitioning><drive></drive></partitioning> needed for\nSuSE multipath installations. \n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- YaST autoinst profile present in /tmp/user.autoinst.xml\n- The \"Create Stub Partition\" step was executed\n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1350001", 
    "modified": "2014-03-10T21:37:40.000Z", 
    "name": "Inject Multipath AutoYaST Settings", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" (c) Copyright 2009 Hewlett-Packard Development Company, L.P.\n Inject multipath settings into the autoyast profile \"\"\"\n\nimport re\nimport sys\nfrom osprov.profile import AutoYaST, ProfileError\nfrom osprov.util import process\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.errors import ShowErrorMessage\nfrom osprov import helpers\n\nLOG = logger.getIt(\"inject_multipath\")\n\nBASE_AY_FILE = \"/tmp/user.autoinst.xml\"\n\ndevice_mapper_command = \"/mnt/runtime/lib/udev/scsi_id -g -u %s\"\n\n\ndef initAutoYast(baseFile):\n    \"\"\" Initializes an autoyast object\"\"\"\n    return AutoYaST(baseFile)\n\n\ndef injectMultipath(keys, ayobj):\n    \"\"\" Modifies the partitioning section by injecting the device mapper\"\"\"\n\n    partitioning = ayobj.createPath(\"profile/partitioning\")\n    partitioning.setAttribute(\"config:type\", \"list\")\n\n    # find the devices sections. If there exist devices we leave the configuration as is\n    drives = [drive for drive in partitioning.childNodes if drive.nodeName == \"drive\"]\n    devices = []\n    for drive in drives:\n        devices += [device for device in drive.childNodes if device.nodeName == \"device\"]\n    if len(devices) > 0:\n        pattern = re.compile('^/dev/mapper/[0-9a-f]+$')\n        valid = True\n        for device in devices:\n            match = pattern.match(device.childNodes[0].data)\n            if not match:\n                print \"Device %s does not have a valid format!\" % device.childNodes[0].data\n                valid = False\n                break\n        if valid:\n            print \"Devices are in the correct format\"\n        return valid\n\n    # find the drives section and configure the devices\n    # If there is just one drive use that to configure the device\n    # If there is more than one, do not do anything\n    if len(drives) > 1:\n        print \"More than one drive section found. The profile will not be modified!\"\n        return False\n    elif len(drives) == 0:\n        drive = ayobj.document.createElement(\"drive\")\n        useall = ayobj.document.createElement(\"use\")\n        ayobj.setNodeTextValue(useall, \"all\")\n        drive.appendChild(useall)\n        partitioning.appendChild(drive)\n    else:\n        drive = drives[0]\n\n    scsi_id = process.getStdout(device_mapper_command % keys.disk.device_path).split(\"\\n\")[0]\n    device = ayobj.createPath(\"profile/partitioning/drive/device\")\n    ayobj.setNodeTextValue(device, \"/dev/mapper/%s\" % scsi_id)\n    return True\n\n\ndef main():\n    \"\"\" Do the injection of the device mapper in the autoyast \"\"\"\n    try:\n        ayobj = initAutoYast(BASE_AY_FILE)\n        keys = helpers.getDataStore()\n        injectMultipath(keys, ayobj)\n        open(BASE_AY_FILE, \"w\").write(str(ayobj))\n        print \"Successfully injected required settings\"\n    except (IOError, OSError, ShowErrorMessage, ProfileError), why:\n        LOG.exception(why)\n        sys.stderr.write(\"Failed to inject multipath settings.%s\\n\" % why)\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n", 
    "state": null, 
    "version": {
      "usage": "This script injects the device name in the <partitioning><drive></drive></partitioning> needed for\nSuSE multipath installations. \n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- YaST autoinst profile present in /tmp/user.autoinst.xml\n- The \"Create Stub Partition\" step was executed\n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:40.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-10T21:37:40.000Z", 
    "runAsSuperUser": false, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "This script injects the device name in the <partitioning><drive></drive></partitioning> needed for\nSuSE multipath installations. \n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- YaST autoinst profile present in /tmp/user.autoinst.xml\n- The \"Create Stub Partition\" step was executed\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:40.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:36:56.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:56.000Z", 
    "description": "Copies a number of files needed to boot the installer environment to the stub partition.\n \n usage :\n        copy_boot_media.py\n\n\tThe script will check the installation media and figgure out the files that\n\tthe installer needs in order to boot. This script accepts no arguments.\n\nPrerequisites:\n - Must be run as part of a build plan on a Solaris Service OS\n - Must be run after 'Create Solaris Stub Partition'\n - Must be run after 'Set Media Source'", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/640001", 
    "modified": "2014-03-10T21:36:56.000Z", 
    "name": "Copy Solaris Boot Media", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\n\"\"\"\nCopy the media needed to boot the target installer.\n\nBe smart and try to figure out the media that is needed\n\"\"\"\n\nimport os\nimport sys\n\nfrom osprov.osbp import logger\nfrom osprov import media, helpers\nfrom osprov.errors import ShowErrorMessage, DiscoveryError, NotSupportedError\nfrom osprov.decorators import HandleShowErrorMessage\n\nLOG = logger.getIt(\"Copy Boot Media\")\n\n\nclass CopyBootMedia(object):\n\n    \"\"\" Do everything needed to copy the media \"\"\"\n\n    def __init__(self):\n        self.keys = helpers.getDataStore()\n        self.media = None\n\n    def discoverMediaObject(self):\n        \"\"\"Figure out the type of media used and set the appropriate object type\"\"\"\n        if self.keys.media.url:\n            self.media = media.factor(self.keys.media.url, log=LOG)\n            self.discoverOSVersion()\n        else:\n            raise DiscoveryError(\n                \"Media source not set. You might be missing the 'Set Media Source' step in your Build Plan.\")\n\n    def discoverOSVersion(self):\n        \"\"\"Figure out if multiboot is present in the media source. Based on that set OSVersion.\"\"\"\n        multibootLoc = \"boot/multiboot\"\n        if self.media.exists(multibootLoc):\n            self.osVersion = \"Solaris 10\"\n        else:\n            self.osVersion = \"Solaris 11\"\n        LOG.debug(\"Discovered OS Version : %s\" % self.osVersion)\n\n    def discoverMediaFilesX86(self):\n        \"\"\"Discover files needed for booting\"\"\"\n        if self.osVersion.endswith(\"10\"):\n            multibootPath = \"boot/multiboot\"\n            minirootPath = \"boot/x86.miniroot\"\n            return [multibootPath, minirootPath]\n        else:\n            platformName = os.uname()[-1]\n            kernelPath = \"platform/%s/kernel/amd64/unix\" % platformName\n            baPath = \"platform/%s/amd64/boot_archive\" % platformName\n            solariszPath = \"solaris.zlib\"\n            solarismisczPath = \"solarismisc.zlib\"\n            imginfoPath = \".image_info\"\n            return [kernelPath, baPath, solariszPath, solarismisczPath, imginfoPath]\n\n    def discoverMediaFilesSPARC(self):\n        raise NotSupportedError(\"Not available yet on SPARC.\")\n\n    def discoverMediaFiles(self):\n        \"\"\"Check the install media.\"\"\"\n        if os.uname()[-1].startswith(\"i86\"):\n            return self.discoverMediaFilesX86()\n        else:\n            return self.discoverMediaFilesSPARC()\n\n    def discoverTarget(self):\n        \"\"\"Discover the target partition.\"\"\"\n        target = self.keys.disk.device_mount\n        if not target:\n            raise DiscoveryError(\"Can't determine target destination. \"\n                                 \"Was the stub partition created?\")\n        if self.osVersion.endswith(\"10\"):\n            ret = os.path.join(target, \"sol-x86\")\n        else:\n            ret = os.path.join(target, \"bootfiles\")\n        helpers.makeDirs(ret)\n        LOG.debug(\"Target partition path %s\" % ret)\n        return ret\n\n    def copyFiles(self, target, files):\n        \"\"\" Copy the files onto the stub partition \"\"\"\n        for each in files:\n            print \"Copying %s to %s\" % (each, target)\n            self.media.copyTo(each, target)\n\n    @HandleShowErrorMessage(\"Copy Solaris Boot Media\", LOG)\n    def main(self):\n        \"\"\" Do the media copying.\"\"\"\n        self.discoverMediaObject()\n        print \"Will copy from %s\" % self.media\n        target = self.discoverTarget()\n        if not os.path.isdir(target):\n            raise ShowErrorMessage(\"Error: %s is not a directory. Can't copy media there.\" % target +\n                                   \"\\nThere might be an issue with the stub partition.\")\n        files = self.discoverMediaFiles()\n        self.copyFiles(target, files)\n        print \"Successfully copied all boot media\"\n\n\nif __name__ == \"__main__\":\n    sys.exit(CopyBootMedia().main())\n", 
    "state": null, 
    "version": {
      "usage": "Copies a number of files needed to boot the installer environment to the stub partition.\n \n usage :\n        copy_boot_media.py\n\n\tThe script will check the installation media and figgure out the files that\n\tthe installer needs in order to boot. This script accepts no arguments.\n\nPrerequisites:\n - Must be run as part of a build plan on a Solaris Service OS\n - Must be run after 'Create Solaris Stub Partition'\n - Must be run after 'Set Media Source'", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:36:56.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:36:56.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Copies a number of files needed to boot the installer environment to the stub partition.\n \n usage :\n        copy_boot_media.py\n\n\tThe script will check the installation media and figgure out the files that\n\tthe installer needs in order to boot. This script accepts no arguments.\n\nPrerequisites:\n - Must be run as part of a build plan on a Solaris Service OS\n - Must be run after 'Create Solaris Stub Partition'\n - Must be run after 'Set Media Source'", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:56.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:31:01.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:11.000Z", 
    "description": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/790001", 
    "modified": "2014-08-26T06:31:01.000Z", 
    "name": "Install bootloader for ESXi", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nFor legacy BIOS it installs extlinux boot loader needed by ESXi to boot off a local disk.\n\nFor UEFI it deploys the boot loader from the ESXi OS media.\n\"\"\"\nimport os\nimport shutil\nimport sys\nfrom optparse import OptionParser\n\nfrom osprov import helpers, netconfig\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.errors import DiscoveryError\nfrom osprov.util import process\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\n\nLOG = logger.getIt(\"install ESXi bootloader\")\n\n\ndef _open(filePath, mode='r'):\n    return open(filePath, mode)\n\n\nclass InstallEsxiBootloader(object):\n\n    \"\"\" Install the extlinux boot loader   \"\"\"\n\n    def __init__(self, log=LOG):\n        \"\"\" Init the class \"\"\"\n        self.log = log\n        keys = helpers.getDataStore()\n        self.target = keys.disk.device_mount\n        if not self.target:\n            raise DiscoveryError(\"Cannot discover boot disk. \"\n                                 \"Was the stub partition created?\")\n        self.bootDisk = keys.disk.device_path\n\n    def installExtlinux(self):\n        \"\"\" Install the mbr \"\"\"\n        mbr = \"/tmp/mbr.bin\"\n        if not os.path.exists(mbr):\n            raise DiscoveryError(\"Cannot find the ESXi utilities. Was the zip installed?\")\n        disko = _open(self.bootDisk, \"wb\")\n        mbro = _open(mbr, \"rb\")\n        disko.write(mbro.read())\n        disko.close()\n        mbro.close()\n        ext = \"/tmp/extlinux\"\n        os.chmod(ext, 0755)\n        process.runIt(\"/tmp/extlinux --install %s\" % self.target, log=self.log, quiet=True)\n\n    def discoverAdditionalModules(self):\n        return [os.path.join(\"/usermod\", x) for x in (os.listdir(os.path.join(self.target, \"usermod\")))]\n\n    def discoverBootCfg(self, isocfgLabel):\n        \"\"\" Returns the path to boot.cfg on the stub partition \"\"\"\n        try:\n            where = isocfgLabel[\"append\"].find(\"-c\")\n        except KeyError:\n            raise DiscoveryError(\"Failed to discover boot modules\")\n        if where >= 0:\n            bootCfg = isocfgLabel[\"append\"][where + 2:].strip().split(' ', 1)[0]\n            bootCfg = os.path.join(self.target, bootCfg)\n        else:\n            bootCfg = None\n        return bootCfg\n\n    def configureExtlinux(self, isocfgLabel, additionalModules, kernelArguments, withBootCfg):\n        \"\"\" Configure the bootloader  \"\"\"\n        extcfg = Syslinux.readwrite(\n            _open(os.path.join(self.target, \"extlinux.conf\"), \"w+b\"), writeback=True)\n        extcfg.info()[\"default\"] = \"esxi\"\n        extcfg.info()[\"prompt\"] = 0\n        extcfg.info()[\"timeout\"] = 100\n\n        kernelArguments = \" \" + kernelArguments.strip()\n\n        if not withBootCfg:\n            modules = isocfgLabel[\"append\"].split(\" --- \")\n            modules.extend(additionalModules)\n            modules[0] += kernelArguments\n            isocfgLabel[\"append\"] = \" --- \".join(modules)\n        extcfg.info()[\"label esxi\"] = isocfgLabel\n        return extcfg\n\n    def configureBootCfg(self, bootCfg, additionalModules=[], kernelopts=\"\"):\n        bootcfg = Syslinux.Bootcfg.readwrite(bootCfg, writeback=True)\n        bootcfg.info()[\"modules\"].extend(additionalModules)\n        bootcfg.info()[\"kernelopt\"] += \" \" + kernelopts\n        return bootcfg\n\n    @HandleShowErrorMessage(\"install ESXi boot loader\", log=LOG)\n    def main(self, args):\n        parser = OptionParser()\n        parser.add_option(\"-k\", \"--kernel_arguments\", dest=\"kernel_args\", default=\"\",\n                          help=\"add additional kernel arguments FILE\", metavar=\"FILE\")\n        (options, rest) = parser.parse_args(args[1:])\n        del rest\n\n        print \"Installing boot loader on %s\" % self.bootDisk\n\n        isocfg = Syslinux.readonly(_open(os.path.join(self.target, \"isolinux.cfg\")))\n        isocfgLabel = isocfg.info()[(\"label %s\" % isocfg.first_non_local_label())]\n        additionalModules = self.discoverAdditionalModules()\n\n        localServer = ThisLocalServer()\n        macAddress = netconfig.macToBootIf(localServer.getMACAddress(()))\n        # Installer configuration:\n        # - use the profile embedded in the initrd\n        # - use the network interface the server booted into the server pool\n        # - pass additional kernel arguments\n        kernelArguments = \"ks=file:///usr/ks.cfg BOOTIF=%s %s\" % (macAddress, options.kernel_args)\n\n        # ESXi5+ uses another boot loader + a boot.cfg file\n        bootCfgPath = self.discoverBootCfg(isocfgLabel)\n        if bootCfgPath:\n            self.configureBootCfg(_open(bootCfgPath), additionalModules, kernelArguments)\n\n        if \"msdos\" == LinuxDisk(self.bootDisk).partitionTableType:\n            print \"Found msdos partition table, configuring for BIOS boot\"\n            self.installExtlinux()\n            self.configureExtlinux(\n                isocfgLabel, additionalModules, kernelArguments, bootCfgPath is not None)\n        else:\n            print \"Found gpt partition table, configuring for UEFI boot\"\n            bootLoaderPath = os.path.join(self.target, \"bootx64.efi\")\n            if not bootCfgPath or not os.path.isfile(bootCfgPath) or not os.path.isfile(bootLoaderPath):\n                raise DiscoveryError(\"Failed to discover ESXi boot files.\"\n                                     \"This media is not suitable for a UEFI installation.\")\n            # deploy the files for UEFI boot\n            bootDir = os.path.join(self.target, \"efi/boot\")\n            helpers.makeDirs(bootDir)\n            shutil.copy2(bootCfgPath, bootDir)\n            shutil.copy2(bootLoaderPath, bootDir)\n            # configure the UEFI boot entries\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=self.bootDisk)\n            efibootmgr = EfiBootMgr(log=LOG)\n            efibootmgr.bootOneTime(osInstallerBootEntry)\n            print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n        print \"Successfully installed the boot loader\"\n\nif __name__ == \"__main__\":\n    sys.exit(InstallEsxiBootloader().main(sys.argv))\n", 
    "state": null, 
    "version": {
      "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "9", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:31:01.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-08-26T06:31:01.000Z", 
    "runAsSuperUser": false, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:11.000Z"
      }, 
      {
        "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:33.000Z"
      }, 
      {
        "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:54.000Z"
      }, 
      {
        "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:14.000Z"
      }, 
      {
        "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:34.000Z"
      }, 
      {
        "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "6", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:54.000Z"
      }, 
      {
        "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:16.000Z"
      }, 
      {
        "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": false, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:37.000Z"
      }, 
      {
        "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "9", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:31:01.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:06.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:46.000Z", 
    "description": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/480001", 
    "modified": "2014-03-28T00:18:06.000Z", 
    "name": "Windows Image Capture", 
    "source": "#!/usr/bin/python\r\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\r\n# ex: set tabstop=4 :\r\n# Please do not change the two lines above. See PEP 8, PEP 263.\r\n#\r\n\r\nimport sys\r\nimport os\r\nfrom optparse import OptionError\r\nfrom osprov.optparse_ext import OptionParser\r\nfrom osprov.scripts import bootmode\r\nfrom osprov.osbp import logger\r\nfrom osprov.util import process\r\nfrom osprov.decorators import HandleShowErrorMessage\r\nfrom osprov import diskmgr\r\nfrom osprov.diskmgr import const, disk, diskmanager, partition\r\nfrom osprov.server import ThisLocalServer\r\nfrom tempfile import mkstemp\r\n\r\nLOG = logger.getIt(\"windows_image_capture\")\r\n\r\nIMAGEX_CONFIG_FILE = \"\"\"\r\n[ExclusionList]\r\n\"\\\\Boot\"\r\n\"\\\\Program Files\\\\Opsware\"\r\n\"\\\\Program Files\\\\Common Files\\\\Opsware\"\r\n\"\"\"\r\n\r\n\r\nclass WindowsImageCaptureOptionParser(OptionParser):\r\n\r\n    \"\"\" Option parser for this step \"\"\"\r\n\r\n    def defineOptions(self):\r\n        self.add_option(\"--bootMode\", type=\"string\",\r\n                        help=\"boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\")\r\n        self.add_option(\"--systemDiskNumber\", type=\"int\", default=0,\r\n                        help=\"system disk number where Windows is installed (default disk number is '0').\")\r\n        self.add_option(\"--systemPartitionLabel\", type=\"string\", default=\"System\",\r\n                        help=\"label of partition where Windows is installed (default partition label is 'System').\")\r\n        self.add_option(\"--wimFilePath\", type=\"string\",\r\n                        help=\"path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\")\r\n        self.add_option(\"--wimScript\", type=\"string\",\r\n                        help=\"path to ImageX config file.\")\r\n\r\n    def validateArgs(self, opt, args):\r\n        if opt.bootMode and not opt.bootMode.lower() in [x.lower() for x in bootmode.SUPPORTED_BOOT_MODES]:\r\n            raise OptionError(\"Invalid boot mode: \" + opt.bootMode, \"bootMode\")\r\n        if not opt.wimFilePath:\r\n            raise OptionError(\"Missing parameter: --wimFilePath\", \"wimFilePath\")\r\n\r\n\r\ndef captureESP(freeLetter, wimFilePath, log=LOG):\r\n    process.runIt(\"imagex.exe /check /verify /capture %s: \\\"%s_ESP\\\" \\\"ESP\\\"\" %\r\n                  (freeLetter, wimFilePath), checkExitCode=(0,), log=log)\r\n\r\n\r\ndef capturePartition(windowsDriveLetter, wimFilePath, configFilePath=None, log=LOG):\r\n    if not configFilePath:\r\n        fd, configFilePath = mkstemp()\r\n        with os.fdopen(fd, 'w') as f:\r\n            f.write(IMAGEX_CONFIG_FILE)\r\n\r\n    process.runIt(\"imagex.exe /config %s /check /verify /capture %s: \\\"%s\\\" \\\"System\\\"\" %\r\n                  (configFilePath, windowsDriveLetter, wimFilePath), checkExitCode=(0,), log=log)\r\n\r\n@HandleShowErrorMessage(\"Windows Image Capture\", LOG)\r\ndef main():\r\n\r\n    # get and parse arguments\r\n    options, remainingArgs = WindowsImageCaptureOptionParser().parse_args()\r\n    wimFilePath = options.wimFilePath.strip()\r\n    systemDiskNumber = options.systemDiskNumber\r\n    # get bootmode (legacy bios or uefi)\r\n    if options.bootMode:\r\n        bootMode = options.bootMode\r\n    else:\r\n        bootMode = bootmode.getCurrentBootMode(ThisLocalServer(), log=LOG)\r\n\r\n    windowsDriveLetter = disk.WindowsDisk(systemDiskNumber).getPartitionWithLabel(\r\n        options.systemPartitionLabel).letter\r\n\r\n    partitionTable = diskmgr.getPartitionTable(bootMode)\r\n    if const.PARTITION_TABLE_MBR == partitionTable:\r\n        print \"Capturing Windows Image based on Legacy Windows Partitioning Schema\"\r\n        capturePartition(windowsDriveLetter, wimFilePath, configFilePath=options.wimScript)\r\n    elif const.PARTITION_TABLE_GPT == partitionTable:\r\n        print \"Capturing Windows Image based on Uefi Windows Partitioning Schema\"\r\n        freeLetter = diskmanager.WindowsDiskManager().findFirstAvailableDriveLetter()\r\n        partition.WindowsPartition(systemDiskNumber, 1).setPartitionLetter(freeLetter)\r\n        captureESP(freeLetter, wimFilePath)\r\n        capturePartition(windowsDriveLetter, wimFilePath, configFilePath=options.wimScript)\r\n\r\nif __name__ == \"__main__\":\r\n    sys.exit(main())\r\n", 
    "state": null, 
    "version": {
      "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.", 
      "current": true, 
      "versionLabel": "5", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:06.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-28T00:18:06.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:47.000Z"
      }, 
      {
        "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:06.000Z"
      }, 
      {
        "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:09.000Z"
      }, 
      {
        "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:30.000Z"
      }, 
      {
        "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.", 
        "current": true, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:06.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:37.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:34.000Z", 
    "description": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1240001", 
    "modified": "2014-08-26T06:30:37.000Z", 
    "name": "Create Stub Partition", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\nThis program will repartition the target server's boot disk and create a\n(1 GB) \"stub\" partition.\n\nThe boot disk by default is computed as the first hard drive listed in\n/proc/partitions, but can be overridden using the boot_disk custom attribute.\n\nWARNING:\nThe boot disk's partition table, master boot record, and all existing file systems\nare PERMANENTLY ERASED by this operation.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\nfrom optparse import OptionError\n\nimport sys\nimport types\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.diskmgr.diskmanager import LinuxDiskManager\nfrom osprov.diskmgr.disk import Disk\nfrom osprov import helpers\nfrom osprov import diskmgr\nfrom osprov.scripts import bootmode\nfrom osprov.server import ThisLocalServer\n\nEC_SUCCESS = 0\nEC_NO_BOOT_DISK = 10\n\nBOOT_DISK = \"@boot_disk@\"  # will be replaced with the custom attribute value at run time\n\nLOG = logger.getIt(\"osprov.diskmgr\")\n\n\nclass CreateStubPartitionOptionsParser(OptionParser):\n\n    \"\"\" An option parser for this step. \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\"--bootMode\", type=types.StringType,\n                        help=\"boot mode of the server, can be UEFI or Legacy (case insensitive);\"\n                        \"this also influences how the partition table will be created: \"\n                        \" - for UEFI, a GPT partition table with 1 fat32 formatted partition of 1GB \"\n                        \" - for Legacy, a MBR partition table with 1 ext3 formatted partition of 1GB\")\n        self.add_option(\n            \"--bootDisk\", help=\"Create the stub partition on BOOTDISK instead of auto determining\")\n\n    def validateArgs(self, opt, args):\n        if opt.bootMode and not opt.bootMode.lower() in [x.lower() for x in bootmode.SUPPORTED_BOOT_MODES]:\n            raise OptionError(\"invalid boot mode: \" + opt.bootMode, \"bootMode\")\n\n\n@HandleShowErrorMessage(\"create stub partition\", log=LOG)\ndef main():\n    options, remainingArgs = CreateStubPartitionOptionsParser().parse_args()\n\n    dm = LinuxDiskManager(log=LOG)\n    dm.disable_automount()\n    dm.unmountOurs()\n    dm.unmountDisks(skipUsb=True)\n\n    if BOOT_DISK and not \"@\" in BOOT_DISK:\n        bootDisk = Disk(BOOT_DISK)\n    elif options.bootDisk:\n        bootDisk = Disk(options.bootDisk)\n    else:\n        bootDisk = None\n    bootDisk = dm.getSystemBootDisk(bootDisk)\n\n    if options.bootMode:\n        bootMode = options.bootMode\n    else:\n        bootMode = bootmode.getCurrentBootMode(targetServer=ThisLocalServer(), log=LOG)\n\n    stubPartition = bootDisk.createStubPartition(partitionTable=diskmgr.getPartitionTable(bootMode))\n    print \"Boot disk partitioned. Stub partition filesystem is on %s.\" % stubPartition.getDeviceFilePath()\n\n    stubPartition.mount()\n    print \"Successfully mounted stub partition filesystem on %s.\" % stubPartition.getMountPoint()\n\n    keys = helpers.getDataStore()\n    keys.disk.device_path = bootDisk.getDeviceFilePath()\n    keys.disk.device_uuid = bootDisk.getDeviceUuid()\n    keys.disk.device_mount = stubPartition.getMountPoint()\n    helpers.putDataStore(keys)\n\n    return EC_SUCCESS\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
      "current": true, 
      "versionLabel": "17", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:36.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-08-26T06:30:37.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:34.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:06:39.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:00.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:20.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:39.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "6", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:07:59.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:20.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:08:40.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "9", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:16.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "10", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:59.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "11", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:24.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "12", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:12:47.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "13", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:10.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "14", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:13:33.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "15", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:00.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": false, 
        "versionLabel": "16", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:27.000Z"
      }, 
      {
        "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.", 
        "current": true, 
        "versionLabel": "17", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:36.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:10:08.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:43.000Z", 
    "description": "Executing conrep for SMBIOS modification.\n\nArguments\n$1 = capture/deploy switch (-s or -l)\n$2 = input/output filename\n$3 = template file (optional for deployment, needed for conrep capture)", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/410001", 
    "modified": "2014-03-28T00:10:08.000Z", 
    "name": "Manage System Configuration", 
    "source": "#!/bin/sh\n\n# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nUTIL=conrep\nDIR=\"/tmp/sstk\"\nMODE=$1\nFILE=$2\n\nTEMPLATEFILE=\"\"\nif [ ! -z $3 ]; then\n\tTEMPLATEFILE=\"-x$DIR/$3\"\nelse\n\tTEMPLATEFILE=\"-x$DIR/conrep.xml\"\nfi\n\nif [ ! -f \"$DIR/$UTIL\" ]; then\n\techo \"$DIR/$UTIL can not be found\" 1>&2\n\texit 1\nfi\n\nchmod +x \"$DIR/$UTIL\"\n\n##Run Conrep\n\n\"$DIR/$UTIL\" $MODE -f \"$FILE\" \"$TEMPLATEFILE\"\nrc=$?\n\ncase $rc in\n   0 )\n\t\techo \"$UTIL successful\";;\n   127 )\n\t\techo \"$UTIL failed ($rc): Missing library in automation\" 1>&2;;\n   134 )\n\t\techo \"$UTIL failed ($rc): Corrupted custom post message\" 1>&2 ;;\n   * )\n\t\techo \"$UTIL failed ($rc)\" 1>&2 ;;\nesac\nexit $rc\n", 
    "state": null, 
    "version": {
      "usage": "Executing conrep for SMBIOS modification.\n\nArguments\n$1 = capture/deploy switch (-s or -l)\n$2 = input/output filename\n$3 = template file (optional for deployment, needed for conrep capture)", 
      "current": true, 
      "versionLabel": "3", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:10:08.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-28T00:10:08.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Executing conrep for SMBIOS modification.\n\nArguments\n$1 = capture/deploy switch (-s or -l)\n$2 = input/output filename\n$3 = template file (optional for deployment, needed for conrep capture)", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:43.000Z"
      }, 
      {
        "usage": "Executing conrep for SMBIOS modification.\n\nArguments\n$1 = capture/deploy switch (-s or -l)\n$2 = input/output filename\n$3 = template file (optional for deployment, needed for conrep capture)", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:11.000Z"
      }, 
      {
        "usage": "Executing conrep for SMBIOS modification.\n\nArguments\n$1 = capture/deploy switch (-s or -l)\n$2 = input/output filename\n$3 = template file (optional for deployment, needed for conrep capture)", 
        "current": true, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:10:08.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:17.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:58.000Z", 
    "description": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/650001", 
    "modified": "2014-08-26T06:30:17.000Z", 
    "name": "Partition Disk for Windows", 
    "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\nimport sys\nimport os\nfrom optparse import OptionError\nfrom osprov.errors import FileNotFoundError\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.scripts import bootmode\nfrom osprov.diskmgr import const, disk\nfrom osprov.util import process\nfrom osprov.osbp import logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov import diskmgr\nfrom osprov import helpers\nfrom osprov.server import ThisLocalServer\n\nLOG = logger.getIt(\"partition_disk_for_windows\")\nDISKPART_LEGACY = r\"X:\\Windows\\Temp\\diskpart_legacy.txt\"\nDISKPART_UEFI = r\"X:\\Windows\\Temp\\diskpart_uefi.txt\"\n\n\nclass PartitionDiskForWindowsOptionParser(OptionParser):\n\n    \"\"\" Option parser for this step \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\"--bootMode\", type=\"string\",\n                        help=\"boot mode of the server, can be UEFI or Legacy\")\n        self.add_option(\"--systemDiskNumber\", type=\"int\", default=0,\n                        help=\"system disk number where Windows is installed (default disk number is '0').\")\n        self.add_option(\"--systemPartitionLabel\", type=\"string\", default=\"System\",\n                        help=\"label of partition where Windows will be installed\")\n\n    def validateArgs(self, opt, args):\n        if opt.bootMode and not opt.bootMode.lower() in [x.lower() for x in bootmode.SUPPORTED_BOOT_MODES]:\n            raise OptionError(\"Invalid boot mode: \" + opt.bootMode, \"bootMode\")\n\n\ndef doDiskpart(dpFile, log=LOG):\n    # check if dpFile exists\n    if False == os.path.isfile(dpFile):\n        raise FileNotFoundError(\"Diskpart configuration file not found: %s\" % dpFile)\n\n    # run diskpart\n    process.runIt(\"diskpart.exe /s %s\" % (dpFile), checkExitCode=(0,), log=log, quiet=True)\n\n\ndef savePartitionIdToDatastore(partitionId):\n    if not partitionId:\n        return\n    datastore = helpers.getDataStore()\n    datastore.windows.partition_id = partitionId\n    helpers.putDataStore(datastore)\n\n\n@HandleShowErrorMessage(\"Partition Disk for Windows\", LOG)\ndef main():\n    # get and parse arguments\n    options, remainingArgs = PartitionDiskForWindowsOptionParser().parse_args()\n\n    # get bootmode (legacy bios or uefi)\n    if options.bootMode:\n        bootMode = options.bootMode\n    else:\n        bootMode = bootmode.getCurrentBootMode(ThisLocalServer(), log=LOG)\n\n    partitionTable = diskmgr.getPartitionTable(bootMode)\n    if const.PARTITION_TABLE_MBR == partitionTable:\n        print \"Partitioning disk based on Legacy Windows Partitioning Schema\"\n        doDiskpart(DISKPART_LEGACY)\n    elif const.PARTITION_TABLE_GPT == partitionTable:\n        print \"Partitioning disk based on Uefi Windows Partitioning Schema\"\n        doDiskpart(DISKPART_UEFI)\n\n    partition = disk.WindowsDisk(\n        options.systemDiskNumber).getPartitionWithLabel(options.systemPartitionLabel)\n    partitionNr = str(partition.partitionNr)\n    savePartitionIdToDatastore(partitionNr)\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
      "current": true, 
      "versionLabel": "11", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:17.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-08-26T06:30:17.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:59.000Z"
      }, 
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:10.000Z"
      }, 
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:45.000Z"
      }, 
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:26.000Z"
      }, 
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": false, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:51.000Z"
      }, 
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": false, 
        "versionLabel": "6", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:28.000Z"
      }, 
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": false, 
        "versionLabel": "7", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:49.000Z"
      }, 
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": false, 
        "versionLabel": "8", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:11.000Z"
      }, 
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": false, 
        "versionLabel": "9", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:48.000Z"
      }, 
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": false, 
        "versionLabel": "10", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:25.000Z"
      }, 
      {
        "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\", 
        "current": true, 
        "versionLabel": "11", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:17.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:36:45.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:45.000Z", 
    "description": "This program will package the production agent for the specific machine it's running\non into a new IPS repository and injects installation instructions into the AI manifest.\n\nUsage: integrate_11_hpsa_agent.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Deploy Agent'\n- This script must be run before 'Modify Boot Archive'", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/460001", 
    "modified": "2014-03-10T21:36:45.000Z", 
    "name": "Integrate Solaris 11 HP SA Agent", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n\"\"\"\nThis program will create an IPS package containing the HPSA Agent and installer\nand inject it into the AI manifest to be installed along with the rest of the system.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nimport shutil\nimport tarfile\nimport tempfile\n\nfrom osprov import helpers\nfrom osprov.util import process\nfrom osprov.profile import AIManifest\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.server.local import ThisLocalServer, LocalServer\nfrom osprov.osbp import logger\n\nLOG = logger.getIt(\"Integrate Solaris 11 HPSA Agent\")\n\nSERVICE_MANIFEST_CONTENT = \"\"\"<?xml version=\"1.0\"?>\n<!DOCTYPE service_bundle SYSTEM \"/usr/share/lib/xml/dtd/service_bundle.dtd.1\">\n<service_bundle type='manifest' name='hpsa-agent-installer:hpsa-agent-installer-svc'>\n\n<service\n    name='hpsa-agent-installer'\n    type='service'\n    version='1'>\n    <create_default_instance enabled='true' />\n    <single_instance />\n\n<!-- Run the script late in the startup sequence after first boot. -->\n<dependency name='multi-user' grouping='require_all' restart_on='none' type='service'>\n    <service_fmri value='svc:/milestone/multi-user:default' />\n</dependency>\n<!-- Depend on network being up -->\n<dependency name='network' grouping='require_all' restart_on='none' type='service'>\n    <service_fmri value='svc:/milestone/network:default' />\n</dependency>\n\n<exec_method\n    type='method'\n    name='start'\n    exec='/opt/hpsa/hpsa-agent-installer.sh'\n    timeout_seconds='900'>\n    <method_context>\n        <method_credential user='root'/>\n    </method_context>\n</exec_method>\n\n<exec_method\n    type='method'\n    name='stop'\n    exec=':true'\n    timeout_seconds='60'\n/>\n\n<property_group name='startd' type='framework'>\n    <propval name='duration' type='astring' value='transient' />\n</property_group>\n\n</service>\n</service_bundle>\n\"\"\"\n\nINSTALLER_SCRIPT_TEMPLATE = \"\"\"#!/bin/sh\nHPSA_INSTALL_LOG=/var/log/opsware/agent/install.log\nmkdir -p `dirname $HPSA_INSTALL_LOG`\n\necho \"Installing HPSA Agent\"\n\n# Redirect messages to the log\nexec >> $HPSA_INSTALL_LOG\nexec 2>> $HPSA_INSTALL_LOG\n\nHPSA_BIN=/opt/hpsa/hpsa-agent\n\n# Print diagnostic messages\necho \"START NETWORK DIAGNOSTIC INFO\"\ngw=`echo %(gwIpPort)s | cut -d':' -f1`\nport=`echo %(gwIpPort)s | cut -d':' -f2`\nifconfig -a\nroute -n\nfor i in `seq 20` ; do\n    python -c \"import socket; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.settimeout(10); s.connect(('$gw', $port)); print 'Gateway $gw listening on port $port'\"\n    if [ $? -eq 0 ] ; then break; fi\n    sleep $i\ndone\necho \"END NETWORK DIAGNOSTIC INFO\"\n\n# Copy mid and crypto\necho \"COPYING MID & CRYPTO\"\nmkdir -p /etc/opt/opsware/agent\nmkdir -p /var/opt/opsware/crypto\ncp -p /opt/hpsa/mid /etc/opt/opsware/agent/mid\ncat /etc/opt/opsware/agent/mid\n# Use GNU tar on Solaris\ngtar -xvf /opt/hpsa/crypto.tar -C /var/opt/opsware/crypto\nls /var/opt/opsware/crypto/agent/\n\n# Run the installer\n$HPSA_BIN -s --settime --force_full_hw_reg --force_sw_reg \\\\\n    --logfile $HPSA_INSTALL_LOG    \\\\\n    --opsw_gw_addr %(gwIpPort)s\nRC=$?\n\nif [ $RC -eq 0 ] ; then\n    echo \"Agent Installation successful\"\n    # self destruct\n    svcadm disable svc:/hpsa-agent-installer:default\n    pkg uninstall pkg:/hpsa-agent-installer\n    pkg unset-publisher hpsa\n    exit $SMF_EXIT_OK\nelse\n    #  The installer also logs here, so no extra message is needed\n    echo \"Agent Installation Failed\"\n    # Don't exit with an error because SMF will keep trying to rerun this service\n    exit $SMF_EXIT_OK\nfi\n\"\"\"\n\nPACKAGE_MANIFEST_CONTENTS = \"\"\"set name=pkg.fmri value=hpsa-agent-installer@1.0,5.11\nset name=pkg.summary value=\"HPSA Agent first-boot installer\"\nfile path=lib/svc/manifest/hpsa/hpsa-agent-installer.xml mode=0444 owner=root group=sys\ndir path=opt/hpsa mode=0755 owner=root group=sys\nfile path=opt/hpsa/hpsa-agent-installer.sh mode=0555 owner=root group=sys\nfile path=opt/hpsa/hpsa-agent mode=0555 owner=root group=sys\nfile path=opt/hpsa/mid mode=0644 owner=root group=sys\nfile path=opt/hpsa/crypto.tar mode=0644 owner=root group=sys\n\"\"\"\n\nHPSA_AGENT_PATH = \"/tmp/hpsa_agent_installer\"\nAGENT_INSTALLER_REPO_PATH = \"/tmp/hpsa-repo\"\nAI_XML_PATH = \"/tmp/ai.xml\"\n\n\nclass LocalIPSRepo(object):\n\n    \"\"\"A local Solaris 11 IPS repository directory structure\"\"\"\n\n    def __init__(self, workingDir, publisherName):\n\n        self.workdir = workingDir\n        self.repodir = os.path.join(self.workdir, \"repo\")\n        self.pubName = publisherName\n\n    def create(self):\n        helpers.makeDirs(self.workdir)\n        if os.path.exists(self.repodir):\n            shutil.rmtree(self.repodir)\n        process.runIt(\"pkgrepo create %s\" % self.repodir, log=LOG)\n        process.runIt(\"pkgrepo -s %s add-publisher %s\" % (self.repodir, self.pubName), log=LOG)\n\n    def publishPackage(self, manifestPath, protoPath):\n        process.runIt(\"pkgsend publish -d %s -s %s %s\" %\n                      (protoPath, self.repodir, manifestPath), log=LOG)\n\n\ndef packageAgent(tempDir):\n    \"\"\"Packages the agent into an IPS repo\"\"\"\n\n    helpers.makeDirs(os.path.join(tempDir, \"proto/opt/hpsa\"))\n    helpers.makeDirs(os.path.join(tempDir, \"proto/lib/svc/manifest/hpsa\"))\n\n    pkgManifestFilePath = os.path.join(tempDir, \"hpsa-agent-installer.p5m\")\n    pkgManifestFile = open(pkgManifestFilePath, \"w\")\n    pkgManifestFile.write(PACKAGE_MANIFEST_CONTENTS)\n    pkgManifestFile.flush()\n    pkgManifestFile.close()\n\n    svcManifestFile = open(\n        os.path.join(tempDir, \"proto/lib/svc/manifest/hpsa/hpsa-agent-installer.xml\"), \"w\")\n    svcManifestFile.write(SERVICE_MANIFEST_CONTENT)\n    svcManifestFile.flush()\n    svcManifestFile.close()\n\n    installerScriptFile = open(os.path.join(tempDir, \"proto/opt/hpsa/hpsa-agent-installer.sh\"), \"w\")\n    installerScript = INSTALLER_SCRIPT_TEMPLATE % {\n        \"gwIpPort\": LocalServer.gateway2str(ThisLocalServer().getRandomAgentGateway())\n    }\n    installerScriptFile.write(installerScript)\n    installerScriptFile.flush()\n    installerScriptFile.close()\n\n    shutil.copy2(HPSA_AGENT_PATH, os.path.join(tempDir, \"proto/opt/hpsa/hpsa-agent\"))\n\n    copyMidCrypto(tempDir)\n\n    repo = LocalIPSRepo(AGENT_INSTALLER_REPO_PATH, \"hpsa\")\n    repo.create()\n    repo.publishPackage(pkgManifestFilePath, os.path.join(tempDir, \"proto\"))\n\n\ndef injectAIRepo():\n    \"\"\"Injects the hpsa agent installer repository into the AI manifest\"\"\"\n\n    aiFile = open(AI_XML_PATH, \"r\")\n    aiManifest = AIManifest(aiFile)\n    aiManifest.addIPSPublisher(\"hpsa\", ([\"file:///hpsa/repo\"], []))\n    aiManifest.addIPSPackage(\"pkg:/hpsa-agent-installer@latest\")\n    aiManifest.save()\n    aiFile.close()\n\n\ndef copyMidCrypto(tempDir):\n    \"\"\"Copies mid and crypto to agent packaging directory\"\"\"\n\n    server = ThisLocalServer()\n    shutil.copy2(server.MID_FILE, os.path.join(tempDir, \"proto/opt/hpsa/mid\"))\n    cryptoTar = tarfile.open(os.path.join(tempDir, \"proto/opt/hpsa/crypto.tar\"), \"w\")\n    cryptoTar.add(server.CRYPTO_DIR, arcname=\"agent\")\n    cryptoTar.close()\n\n\n@HandleShowErrorMessage(\"Integrate Solaris 11 HPSA Agent\", LOG)\ndef main():\n    if not os.path.isfile(HPSA_AGENT_PATH):\n        raise ShowErrorMessage(\"HPSA Agent not found, have you run the 'Deploy Agent' step?\")\n    tempDir = tempfile.mkdtemp()\n    LOG.info(\"Temporary directory for agent packaging created at: %s\" % tempDir)\n    packageAgent(tempDir)\n    print \"Successfully packaged HPSA Agent...\"\n    shutil.rmtree(tempDir)\n    injectAIRepo()\n    print \"Successfully integrated HPSA Agent with IPS Install...\"\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "This program will package the production agent for the specific machine it's running\non into a new IPS repository and injects installation instructions into the AI manifest.\n\nUsage: integrate_11_hpsa_agent.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Deploy Agent'\n- This script must be run before 'Modify Boot Archive'", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:36:45.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:36:45.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "This program will package the production agent for the specific machine it's running\non into a new IPS repository and injects installation instructions into the AI manifest.\n\nUsage: integrate_11_hpsa_agent.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Deploy Agent'\n- This script must be run before 'Modify Boot Archive'", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:45.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:09:04.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:55.000Z", 
    "description": "Installs Windows 2012 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/620001", 
    "modified": "2014-03-28T00:09:04.000Z", 
    "name": "Run Windows 2012 R2 x64 Setup", 
    "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n", 
    "state": null, 
    "version": {
      "usage": "Installs Windows 2012 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
      "current": true, 
      "versionLabel": "2", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:09:04.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-28T00:09:04.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs Windows 2012 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:55.000Z"
      }, 
      {
        "usage": "Installs Windows 2012 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": true, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:04.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:11.000Z", 
    "serverChanging": false, 
    "created": "2014-03-28T00:14:47.000Z", 
    "description": "Checks that the server is booted into the correct WinPE version.\n\nOption:\n   --version=n  where n is 3.1, 4.0, a list of versions (\"3.1,4.0\"), or any.  The version of the booted WinPE is checked against the parameter specified.  If no option is specified, then the option defaults to 3.1\n\nRequirements:\nServer must be booted into WinPE", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1620001", 
    "modified": "2014-08-26T06:30:11.000Z", 
    "name": "Validate WinPE Version", 
    "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(c) Copyright 2014 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nfrom optparse import OptionParser\n\nEC_SUCCESS = 0\nEC_FAILED = 1\nWINPE30 = \"6.1.7600.16385\"\nWINPE31 = \"6.1.7601.17514\"\nWINPE40 = \"6.2.9200.16384\"\nWINPEMAP = {'3.1': WINPE31, '4.0': WINPE40, '3.0': WINPE30, 'any' : 'any' }\nDIRMAP = { WINPE31: '3.1', WINPE40: '4.0', WINPE30: '3.0', 'any': 'any' }\n\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--version\", dest=\"winpeVersion\", type=\"string\", default=\"3.1\",\n                        help=\"Check for specified WinPE version (default value is '3.1').\")\n  \n    options, args = parser.parse_args(args)\n    # Create list of options and remove any spaces\n    options.winpeVersion = map(str.strip, options.winpeVersion.split(\",\"))\n\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n# Validate the supplied options\ndef validateOptions(opts):\n    for o in opts.winpeVersion:\n        if not o in WINPEMAP.keys():\n           print \"--winpeVersion must be list of %s\" % WINPEMAP.keys()\n           exit(EC_FAILED)\n\ndef main():\n    opts, remArgs = parseArgs(sys.argv[1:])\n    validateOptions(opts) \n\n    # if any value is acceptable, just return success\n    if \"any\" in opts.winpeVersion:\n        return EC_SUCCESS\n\n    # Look up the WinPE version.  There should only be one file\n    # in this directory, but check just in case.\n    for dir in os.listdir(\"x:\\\\Windows\\\\Servicing\\\\Version\"):\n        if not dir.startswith(\"6\"):\n            continue\n        foundWinpe = dir\n        break\n\n    # Make sure we know about the version of WinPE found\n    if not foundWinpe in DIRMAP.keys():\n        print \"WinPE version is for OS version %s is unknown.\" % foundWinpe\n        return EC_FAILED\n\n    # Validate that the found WinPE version is acceptable.\n    if DIRMAP[foundWinpe] in opts.winpeVersion:\n        print \"Found WinPE %s.\" % DIRMAP[foundWinpe]\n        return EC_SUCCESS\n\n    # If we're here, then we don't have a matching WinPE, so\n    # we need to fail.\n    print (\"Found WinPE %s, requesting WinPE %s\") % (DIRMAP[foundWinpe], \n               opts.winpeVersion)\n    return EC_FAILED\n\nif __name__ == \"__main__\":\n    sys.exit(main())", 
    "state": null, 
    "version": {
      "usage": "Checks that the server is booted into the correct WinPE version.\n\nOption:\n   --version=n  where n is 3.1, 4.0, a list of versions (\"3.1,4.0\"), or any.  The version of the booted WinPE is checked against the parameter specified.  If no option is specified, then the option defaults to 3.1\n\nRequirements:\nServer must be booted into WinPE", 
      "current": true, 
      "versionLabel": "3", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:11.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-08-26T06:30:11.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Checks that the server is booted into the correct WinPE version.\n\nOption:\n   --version=n  where n is 3.1, 4.0, a list of versions (\"3.1,4.0\"), or any.  The version of the booted WinPE is checked against the parameter specified.  If no option is specified, then the option defaults to 3.1\n\nRequirements:\nServer must be booted into WinPE", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:47.000Z"
      }, 
      {
        "usage": "Checks that the server is booted into the correct WinPE version.\n\nOption:\n   --version=n  where n is 3.1, 4.0, a list of versions (\"3.1,4.0\"), or any.  The version of the booted WinPE is checked against the parameter specified.  If no option is specified, then the option defaults to 3.1\n\nRequirements:\nServer must be booted into WinPE", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:52.000Z"
      }, 
      {
        "usage": "Checks that the server is booted into the correct WinPE version.\n\nOption:\n   --version=n  where n is 3.1, 4.0, a list of versions (\"3.1,4.0\"), or any.  The version of the booted WinPE is checked against the parameter specified.  If no option is specified, then the option defaults to 3.1\n\nRequirements:\nServer must be booted into WinPE", 
        "current": true, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:11.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:21.000Z", 
    "serverChanging": true, 
    "created": "2014-08-26T06:30:21.000Z", 
    "description": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1820001", 
    "modified": "2014-08-26T06:30:21.000Z", 
    "name": "Install Windows SMH_iLO-controller_IMA zack", 
    "source": "@echo off\n\n:: (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nsetlocal EnableDelayedExpansion EnableExtensions\n\n:: Drive letter to mount the media server, colon must be included\nset driveletter=z:\n\n:: ====================\n:: Determine what calling arguments\n:: ====================\nset opt=0\nset failonwarning=0\nset hpsumargs=/s /f:software cp017579.exe cp019213.exe cp017930.exe cp019271.exe\nset log_dir=%SYSTEMDRIVE%\\cpqsystem\\hp\\log\n:OptionsLoop\n  if [%1]==[] goto DetermineSPPVersion\n\n  if \"%1\"==\"--spp_version\" (\n     set sppversion=%2\n     set opt=0\n     goto OptionsShift\n  )\n\n  if \"%1\"==\"--fail_on_warning\" (\n     set failonwarning=1\n     goto OptionsShift\n  )\n\n  if \"%opt%\"==\"1\" (\n     set hpsumargs=%hpsumargs% %1\n     set log_dir=%1\n     goto OptionsShift\n  )\n\n  if \"%1\"==\"--hpsum_options\" (\n     set opt=1\n     goto OptionsShift\n  )\n\n  :OptionsShift\n  shift\ngoto OptionsLoop\n\n\n:DetermineSPPVersion\n:: ====================\n:: Determine SPP Version to install\n:: ====================\nif \"%sppversion%\"==\"\" (\ngoto SPPVersion\n) else (\ngoto SetAssignMediaPath\n)\ngoto RunHPSUM\n\n:SPPVersion\n   %driveletter%\n   cd \\media\\spp\n   set sppdir=\n   for /f \"tokens=* delims=0\" %%i in ('dir /b /a:d') do set sppdir=%%i\n   cd \\media\\spp\\%sppdir%\n   set buildir=\n   for /f \"tokens=* delims=0\" %%i in ('dir /b /a:d') do set buildir=%%i\n   set sppversion=%buildir%\n   if \"%sppversion%\"==\"\" (\n      echo Did not find an SPP Version on the media server\n      set rc=999\n      goto End\n   )\n   cd \\media\\spp\\%sppdir%\\%sppversion%\\hp\\swpackages\n\n:SetAssignMediaPath\n   echo Enter SetAssignMediaPath\n   %driveletter%\n   cd \\media\\spp\\@SPP_VER@\\@BUILD_VER@\\hp\\swpackages\n   \n:RunHPSUM\n:: ====================\n:: Run HPSUM\n:: ====================\n\necho SPP version to be installed is %sppdir%\\%sppversion%\necho Additional hpsum arguments are %hpsumargs%\n:: Must be run as currently running directory\n\nhpsum.exe %hpsumargs%\n\nset rc=%ERRORLEVEL%\n\nif %rc% GEQ 0 (\n if %rc%==0 (\n  echo SPP hpsum ran successfully: return code %rc%\n  GOTO Success\n )\n if %rc%==1 ( \n  echo The installation was successful,but a reboot is required: return code %rc%\n  GOTO Success\n )\n if %rc%==3 (\n  echo The component was current or not required: return code %rc%\n  GOTO Success\n )\n if %rc%==253 (\n  set rc=-3\n  )\n\n if %rc%==254 (\n  set rc=-2\n )\n if %rc%==255 (\n  set rc=-1\n ) \n)\n\nif %rc% LSS 0 (\n if %rc%==-1 (\n  echo A general failure occurred. For details, see the error log.\n  GOTO Fail\n )\nif %rc%==-2 (\n  echo A bad input parameter was encountered.\n  GOTO Fail\n )\nif %rc%==-3 (\n  if %failonwarning%==1 (\n   echo ERROR - One or more components failed to install\n   echo fail_on_warning is set\n   GOTO Fail\n  )\n  if %failonwarning%==0 GOTO FinishWithWarning\n ) ELSE (\nGOTO Fail\n)  \n)\n\n\n:Success\necho hpsum logs are located at %log_dir% unless specified otherwise by hpsum /logdir option\n:: Change return code to 0 for hpsum positive return codes\nset rc=0\ngoto End\n\n:FinishWithWarning\n   echo SPP hpsum failed: error code %rc%\n   echo WARNING - One or more of the smart components failed to install. Depending on the system configuration,\n   echo this may be expected behavior. To verify the installation, check the hpsum logs are located at\n   echo %log_dir% unless specified otherwise by hpsum /logdir option.  \n   echo To fail the build plan when these warnings occur, specify the --fail_on_warning option to this step.\nset rc=0\ngoto End\n\n:Fail\n   echo SPP hpsum failed: error code %rc%\n   echo %log_dir% unless specified otherwise by hpsum /logdir option.\n   goto End\n\n\n:End\n:: Return to system drive, so can unmount media server drive\n%SYSTEMDRIVE%\nnet use %driveletter% /delete\nexit /B %rc%\n", 
    "state": null, 
    "version": {
      "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
      "current": true, 
      "versionLabel": "2", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:21.000Z"
    }, 
    "isCustomerContent": true, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-08-26T06:30:21.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.", 
        "current": true, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:21.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:20.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:19.000Z", 
    "description": "This script erases the partition table on all detected disk drives.\nThe first 1 MBytes of each disk are zero-ed out.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/960001", 
    "modified": "2014-03-10T21:37:20.000Z", 
    "name": "Clean all Disks", 
    "source": "#!/opt/opsware/agent/bin/python\n\"\"\"\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\nThis script runs dd on all the devices on the server where it's run to\nerase the partition table\n\"\"\"\n\nimport re\nimport sys\nimport subprocess\nfrom osprov.diskmgr.diskmanager import DiskManager\nfrom osprov.errors import ProcessExecutionError\nfrom osprov.osbp import logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.util import process\n\nLOG = logger.getIt(\"clean_server_disks\")\n\n\ndef scan():\n    \"\"\"\n    Get the list of (partitioned) hard drives on this server.\n    Uses 'parted -lm', which requires superuser permission.\n    @return: list of disks w/o Gaius flash media.\n    \"\"\"\n    validdisks = []\n    cmd = [\"parted\", \"--list\", \"--machine\"]\n    # /dev/sda:36.4GB:scsi:512:512:msdos:HP LOGICAL VOLUME;\n    regex = re.compile(r\"^(/dev/[hs]d\\w+):.*:.*:\\d+:\\d+:.*:(.*);$\")\n    devlist = process.getStdout(cmd)\n    for line in devlist.split('\\n'):\n        match = regex.match(line)\n        if match:\n            dev = match.group(1)\n            name = match.group(2)\n            if \"HP iLO LUN\" in name:\n                continue    # skip Gaius flash media\n            validdisks.append(dev)\n    return validdisks\n\ndef erasedisk(disklist, log=LOG):\n    \"\"\"\n    Get the list of hard drives on this server and run dd on it\n    to zero out the first 1M bytes.\n    @param disklist: List of available hd devices\n    @param log: logger\n    @return: nothing.\n    \"\"\"\n    for disk in disklist:\n        # For each device name returned, run dd on it\n        cmd = \"dd if=/dev/zero of=\" + disk + \" bs=8k count=128\"\n        process.runIt(cmd, log=log, quiet=True)\n        print \"Successfully erased disk \" + disk\n\n\n\n@HandleShowErrorMessage(\"Clean server disks\", log=LOG)\ndef main():\n    \"\"\" main function:\n     scan for valid disks and remove partition info on all of them\n     \"\"\"\n\n    dm = DiskManager(log=LOG)\n    dm.disable_automount()\n    dm.unmountOurs()\n    dm.unmountDisks(skipUsb=True)\n\n    inventory_disks = dm.get_disk_inventory()\n    disks = []\n    hdlist = scan()\n\n    # filtering out Gaius flash media from disk inventory\n    for temp_disk in inventory_disks:\n        if temp_disk.getDeviceFilePath() in hdlist:\n            disks.append(temp_disk)\n\n    # un-mount disks\n    for temp_disk in disks:\n        temp_disk.releaseAndUnload()\n\n    # remove partition info\n    erasedisk(hdlist)\n\n    # refreshing kernel partition table\n    for temp_disk in disks:\n        try:\n            temp_disk.rescan()\n        except ProcessExecutionError, why:\n            print \"Warning : Rereading partition table for %s failed : %s. \" \\\n                  \"Reboot to refresh partition table.\" % (temp_disk.getDeviceFilePath(), why)\n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "This script erases the partition table on all detected disk drives.\nThe first 1 MBytes of each disk are zero-ed out.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:20.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:20.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "This script erases the partition table on all detected disk drives.\nThe first 1 MBytes of each disk are zero-ed out.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:20.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:08.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:05.000Z", 
    "description": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/730001", 
    "modified": "2014-03-28T00:18:08.000Z", 
    "name": "Prepare Windows for Image Capture", 
    "source": "@echo off\nif not exist %WINDIR%\\system32\\sysprep\\sysprep.exe (\n\techo \"Sysprep tool was not found in this Windows installation. This is only supported for Windows 2008 and newer\"\n\texit 1\n)\n\nif \"%1\"==\"\" (\n  %WINDIR%\\system32\\sysprep\\sysprep.exe /generalize /oobe /quit\n) else (\n  %WINDIR%\\system32\\sysprep\\sysprep.exe /generalize /oobe /quit /unattend:%1\n)\n", 
    "state": null, 
    "version": {
      "usage": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.", 
      "current": true, 
      "versionLabel": "5", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:07.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-28T00:18:08.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:05.000Z"
      }, 
      {
        "usage": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:07.000Z"
      }, 
      {
        "usage": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:10.000Z"
      }, 
      {
        "usage": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:31.000Z"
      }, 
      {
        "usage": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.", 
        "current": true, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:07.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:05.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:05.000Z", 
    "description": "Executing rbsureset for SMBIOS reset to factory default settings.\n\nArguments:  None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/720001", 
    "modified": "2014-03-10T21:37:05.000Z", 
    "name": "Reset System Configuration Settings", 
    "source": "#!/bin/sh\n\n# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nUTIL=rbsureset\nDIR=\"/tmp/sstk\"\n\nif [ ! -f \"$DIR/$UTIL\" ]; then\n   echo \"$DIR/$UTIL can not be found\" 1>&2\n   exit 1\nfi\n\nchmod +x \"$DIR/$UTIL\"\n\n# Run Utility\n\"$DIR/$UTIL\"\nrc=$?\n\ncase $rc in\n   0 )\n      echo \"$UTIL successful\";;\n   127 )\n      echo \"$UTIL failed ($rc): Missing library in automation\" 1>&2;;\n   * )\n      echo \"$UTIL failed ($rc)\" 1>&2 ;;\nesac\nexit $rc\n", 
    "state": null, 
    "version": {
      "usage": "Executing rbsureset for SMBIOS reset to factory default settings.\n\nArguments:  None", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:05.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-10T21:37:05.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Executing rbsureset for SMBIOS reset to factory default settings.\n\nArguments:  None", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:05.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:12.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:15:12.000Z", 
    "description": "Checks for the existence of the WIM image file.  This ensures that an existing WIM image is not accidentally overwritten if another capture build plan is run that uses the same WIM file name.  The script returns an error if the specified file name exists.  \n\nRequired Parameters:\nWIM_filename    The WIM file name and path to be checked if exists.\n\nCustom Attributes: None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1670001", 
    "modified": "2014-03-28T00:18:12.000Z", 
    "name": "Prevent WIM File Overwrite", 
    "source": "@echo off\n\n:: (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nset filename=%1\n\nREM Make sure the file name was specified.\nif [%filename%]==[] (\n    echo The WIM File Name must be specified. 1>&2\n    exit /B 1\n)\n\nREM Get the directory component of the file name.\nfor %%F in (\"%filename%\") do set dirname=%%~dpF\n\nREM Make sure the directory exists.\nif not exist %dirname% (\n    echo The directory \"%dirname%\" does not exist. 1>&2\n    exit /B 1\n)\n\nREM Check if the file already exists.\nif exist \"%filename%\" (\n    echo The file %filename% already exists. 1>&2\n    echo Please remove or rename the existing file and re-run the Build Plan. 1>&2\n    exit /B 1\n)\n", 
    "state": null, 
    "version": {
      "usage": "Checks for the existence of the WIM image file.  This ensures that an existing WIM image is not accidentally overwritten if another capture build plan is run that uses the same WIM file name.  The script returns an error if the specified file name exists.  \n\nRequired Parameters:\nWIM_filename    The WIM file name and path to be checked if exists.\n\nCustom Attributes: None", 
      "current": true, 
      "versionLabel": "35", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:12.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-28T00:18:12.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Checks for the existence of the WIM image file.  This ensures that an existing WIM image is not accidentally overwritten if another capture build plan is run that uses the same WIM file name.  The script returns an error if the specified file name exists.  \n\nRequired Parameters:\nWIM_filename    The WIM file name and path to be checked if exists.\n\nCustom Attributes: None", 
        "current": false, 
        "versionLabel": "32", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:12.000Z"
      }, 
      {
        "usage": "Checks for the existence of the WIM image file.  This ensures that an existing WIM image is not accidentally overwritten if another capture build plan is run that uses the same WIM file name.  The script returns an error if the specified file name exists.  \n\nRequired Parameters:\nWIM_filename    The WIM file name and path to be checked if exists.\n\nCustom Attributes: None", 
        "current": false, 
        "versionLabel": "33", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:14.000Z"
      }, 
      {
        "usage": "Checks for the existence of the WIM image file.  This ensures that an existing WIM image is not accidentally overwritten if another capture build plan is run that uses the same WIM file name.  The script returns an error if the specified file name exists.  \n\nRequired Parameters:\nWIM_filename    The WIM file name and path to be checked if exists.\n\nCustom Attributes: None", 
        "current": false, 
        "versionLabel": "34", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:35.000Z"
      }, 
      {
        "usage": "Checks for the existence of the WIM image file.  This ensures that an existing WIM image is not accidentally overwritten if another capture build plan is run that uses the same WIM file name.  The script returns an error if the specified file name exists.  \n\nRequired Parameters:\nWIM_filename    The WIM file name and path to be checked if exists.\n\nCustom Attributes: None", 
        "current": true, 
        "versionLabel": "35", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:12.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:36:40.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:36:40.000Z", 
    "description": "This script is used to deploy a WinPE ServiceOS on localdisk which will be booted later.\nMust NOT be part of a build plan. This step is called by step named 'Install and\nboot into local WinPE'\n\nUsage: deploy_winpe_on_localdisk.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--winpeVersion : WinPE version which will be downloaded (default value is '3.1')\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/370001", 
    "modified": "2014-03-10T21:36:40.000Z", 
    "name": "Deploy WinPE on Localdisk", 
    "source": "# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n \"\"\"\n\nimport os\nimport sys\nimport random\nfrom StringIO import StringIO\nfrom pytwist.com.opsware.search import Filter\nfrom optparse import OptionError\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.server import ThisLocalServer\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, NotFoundError\nfrom osprov.helpers import getMyServerRef\nfrom osprov.netconfig.helpers import getNetconfig\nfrom osprov.parsers.netconfig import getActiveInterface, Netconfig, NetworkInformation\n\n\n\nLOG = logger.getIt(\"Deploy WinPE on localdisk\")\n\nWINPE_VERSIONS = { \"2.1\": None,\n                   \"3.1\": \"OPSWwinpex64-ogfs-enabled.iso\",\n                   \"4.0\": None,\n                 }\nRESPONSE_FILE = \"hpsa_response_file.txt\"\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nclass DeployWinpeOptionsParser(OptionParser):\n    \"\"\" An option parser for this step. \"\"\"\n\n    def defineOptions(self):\n        \"\"\" definition of options \"\"\"\n        self.add_option(\"--systemDiskNumber\", type=\"int\", default=0,\n                        help=\"system disk number where Windows is installed (default disk number is '0').\")\n        self.add_option(\"--systemDrive\", type=\"string\", default=\"C\",\n                        help=\"system drive letter where WinPE will be copied\")\n        self.add_option(\"--winpeVersion\", type=\"string\", default=\"3.1\",\n                        help=\"WinPE version which will be downloaded (default value is '3.1').\")\n\n    def returnValidWinPEVersions():\n        validVersions = \"\"\n        for ver in WINPE_VERSIONS.keys():\n            if WINPE_VERSIONS[ver] is not None:\n                validVersions = validVersions + \" \" + ver\n        return validVersions\n\n    def validateArgs(self, opt, args):\n        \"\"\" options validation \"\"\"\n        if opt.winpeVersion not in WINPE_VERSIONS.keys():\n                raise OptionError(\"Invalid WinPE version was requested: %s. Supported WinPE version: %s\" %\n                (opt.winpeVersion, self.returnValidWinPEVersions()), \"winpeVersion\")\n        if WINPE_VERSIONS[opt.winpeVersion] is None:\n                raise OptionError(\"Requested WinPE version is not supported :\" + opt.winpeVersion, \"winpeVersion\")\n\ndef downloadIso(targetServer, isoName, destinationDrive):\n    unitFilter = Filter()\n    unitFilter.setObjectType(\"software_unit\")\n    filterExpression = \"( (PackageVO.fileName EQUAL_TO %s) & \\\n(UnitVO.unitType EQUAL_TO UNKNOWN) & \\\n(PackageVO.fileType EQUAL_TO UNKNOWN) )\"\n    unitFilter.setExpression(filterExpression % isoName)\n    twistServer = targetServer.twistServer\n    ref = twistServer.pkg.UnitService.findUnitRefs(unitFilter)\n    if not ref:\n        raise NotFoundError(\"Iso file named %s was not found\" % isoName)\n    elif len(ref) > 1:\n        raise DiscoveryError(\"More than one iso named %s was found\" % isoName)\n\n    from coglib import reconcile\n    ret = reconcile.retrieveFile(str(ref[0].id), destinationDrive+\":\\\\winpe.iso\", destinationDrive+\":\\\\\", \"theword\")\n\ndef unpackIso(destinationDrive):\n    unIsoCmdLine = \"7z.exe x %s:\\\\winpe.iso -y -o%s:\\\\\" % (destinationDrive, destinationDrive) # \"7z x c:\\\\winpe.iso -y -oc:\\\"\n    newEnv = os.environ\n    newEnv[\"PATH\"] = newEnv[\"PATH\"] + \";%s\\\\tools\" % newEnv[\"SYSTEMDRIVE\"]\n    process.runIt(unIsoCmdLine, quiet=True, checkExitCode=(0,), env=newEnv, log=LOG)\n\ndef buildRespNetInfo(interface):\n    \"\"\" pick only what's needed from the static info \"\"\"\n    respstring=\"protocol=static \\n\"\n    # the mandatory single value keys - get first value if it's a list\n    for key in [\"mac\", \"ip\", \"gw\", \"mask\"]:\n        if isinstance(interface[key], list):\n            value=interface[key][0]\n        else:\n            value=interface[key]\n        respstring += \"%s0=%s \\n\" % (key,value)\n    # optional key dns\n    if interface.has_key(\"dns\"):\n        respstring += \"%s0=%s \\n\" % (\"dns\", \", \".join(interface[\"dns\"]))\n    return respstring\n\ndef storeStaticNetworkInfo(targetSrv, destinationDrive):\n    # store core(gateway) ip:port\n    gateways = targetSrv.getAllAgentGateways()\n    agwIpPort = random.choice(gateways)\n    agwIP = str(agwIpPort[0])\n    agwPort = str(agwIpPort[1])\n    responseConf = \"agwIpPort=%s:%s\\n\" % (agwIP, agwPort)\n    responseConf += \"mid=%s\\n\" % str(getMyServerRef().id)\n    # save static info if is the case\n    netinfo = getNetconfig(HPSA_NETCONFIG, \"False\", LOG)\n    if not netinfo:\n        print \"No static network configuration present. Using DHCP configuration.\"\n        macAddr = targetSrv.getMACAddress().lower()\n        netConfDict = {0: {'mac':macAddr, 'protocol':'dhcp'}}\n        parser = Netconfig.Writable(StringIO(\"\"))\n        parser.data = NetworkInformation(netConfDict)\n        responseConf += parser.format()\n    else:\n        # check if we have a match\n        activeKey, activeInterface = getActiveInterface(targetSrv, netinfo)\n        if not activeInterface.has_key(\"index\"):\n            netinfo[activeKey][\"index\"] = activeKey\n        else:\n            netinfo[activeKey][\"index\"] = netinfo[activeKey][\"index\"][0]\n        if not hasattr(activeInterface, \"mac\"):\n            print \"Warning: Your network configuration lacks a MAC address. \"\\\n                \"Network device selection will be up to the Service OS Windows PE.\"\n        else:\n            activeInterfaceInfo=buildRespNetInfo(activeInterface)\n            print \"Will save the following network configuration to be used \\n\" \\\n                \"when booted from the stub partition:\\n%s\\n\" % activeInterfaceInfo\n            responseConf += activeInterfaceInfo\n    respfile = open(os.path.join(\"%s:\" % destinationDrive, RESPONSE_FILE), \"a\")\n    respfile.write(responseConf)\n    respfile.close()\n\n@HandleShowErrorMessage(\"Create Stub Partition\")\ndef main():\n    opt, remainingArgs = DeployWinpeOptionsParser().parse_args()\n    targetServer = ThisLocalServer()\n    downloadIso(targetServer, WINPE_VERSIONS[opt.winpeVersion], opt.systemDrive)\n    unpackIso(opt.systemDrive)\n\n    # if static provisioning -> drop hpsa_response_file.txt file\n    storeStaticNetworkInfo(targetServer, opt.systemDrive)\n\n    # set bootloader\n    process.runIt(\"bootsect.exe /nt60 %s: /force /mbr\" % opt.systemDrive, quiet=True, checkExitCode=(0,), log=LOG)\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "This script is used to deploy a WinPE ServiceOS on localdisk which will be booted later.\nMust NOT be part of a build plan. This step is called by step named 'Install and\nboot into local WinPE'\n\nUsage: deploy_winpe_on_localdisk.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--winpeVersion : WinPE version which will be downloaded (default value is '3.1')\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:36:40.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:36:40.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "This script is used to deploy a WinPE ServiceOS on localdisk which will be booted later.\nMust NOT be part of a build plan. This step is called by step named 'Install and\nboot into local WinPE'\n\nUsage: deploy_winpe_on_localdisk.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--winpeVersion : WinPE version which will be downloaded (default value is '3.1')\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:40.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:49.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:18:49.000Z", 
    "description": "Unmounts all the partitions belonging to the boot disk.\n\nBy default, the boot disk is computed as the first hard drive listed in /proc/partitions.\n\nOptional Custom Attributes:\n\nboot_disk - The absolute path to the device file for the boot disk.  For example, /dev/sda.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1710001", 
    "modified": "2014-03-28T00:18:49.000Z", 
    "name": "Unmount All Boot Disk Partitions", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\nUnmounts all the partitions belonging to the boot disk.\n\nBy default, the boot disk is computed as the first hard drive listed in\n/proc/partitions.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nimport re\n\nfrom osprov.util import process\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.osbp import logger\nfrom osprov.diskmgr.diskmanager import DiskManager\n\nEC_SUCCESS = 0\nEC_NO_BOOT_DISK = 10\nEC_FAILED_TO_MOUNT = 11\nEC_IN_USE = 12\n\nBOOT_DISK = \"@boot_disk@\" #ScriptWeaver will parametrize this data at run time\n\n# We don't need the object byt by getting it, it will get set up\nLOG = logger.getIt(\"osprov.diskmgr\")\n\n#######################################################################\n# Returns True if the specified device is mounted on the specified\n# mount point.\n#######################################################################\n\ndef isDeviceMountedOnMountPoint(deviceName, mountPoint):\n\n\tmountOutput = process.getStdout(\"mount\")\n\n\tif mountOutput is not None:\n\t\tmountRE = re.compile(\"^%s\\s+on\\s+%s\\s+.*\" % (deviceName,mountPoint))\n\n\t\tlines = mountOutput.splitlines()\n\n\t\tfor line in lines:\n\t\t\tmatch = mountRE.match(line)\n\t \t\tif match:\n\t\t\t\treturn True\n\n\treturn False\n\n#######################################################################\n# Counts the number of devices mounted on the specified mount point.\n#######################################################################\n\ndef countDevicesMountedOnMountPoint(mountPoint):\n\n\tcount = 0\n\n\tmountOutput = process.getStdout(\"mount\")\n\n\tif mountOutput is not None:\n\t\tmountRE = re.compile(\"^\\S+\\s+on\\s+%s\\s+.*\" % mountPoint)\n\n\t\tlines = mountOutput.splitlines()\n\n\t\tfor line in lines:\n\t\t\tmatch = mountRE.match(line)\n\t \t\tif match:\n\t\t\t\tcount += 1\n\n\treturn count\n\n#######################################################################\n# Unmounts all the partitions belonging to the specified disk.\n#######################################################################\n\ndef unmountAllPartitions(disk):\n\n\tprint \"Unmounting partitions for disk '%s'\" % disk.deviceName\n\n\t# Get all the partitions belonging to this disk.\n\tfor partition in disk.getPartitions():\n\n\t\tprint \"Checking if partition '%s' is mounted\" % partition.getDeviceFilePath()\n\n\t\t# Get all the mount points on which the partition is mounted.\n\t\tmountPoints = partition.getMountPoints()\n\n\t\tif (len(mountPoints) == 0):\n\t\t\tprint \"Partition '%s' is not mounted anywhere\" % partition.getDeviceFilePath()\n\t\t\tcontinue\n\t\telse:\n\t\t\tprint \"Partition '%s' has %d mount points\" % (partition.getDeviceFilePath(), len(mountPoints))\n\n\t\t# Unmount the partition from each mount point on which it is mounted.\n\t\tfor mountPoint in mountPoints:\n\t\t\ttry:\n\t\t\t\tprint \"Unmounting '%s' from '%s'\" % (partition.getDeviceFilePath(), mountPoint)\n\n\t\t\t\t# Count the number of devices that are mounted on this mount point.\n\t\t\t\tcount = countDevicesMountedOnMountPoint(mountPoint)\n\n\t\t\t\tprint \"There are %d devices mounted on %s\" % (count, mountPoint)\n\n\t\t\t\ti = 0\n\n\t\t\t\t# Since there may be other devices mounted on the same\n\t\t\t\t# mount point, we need to keep unmounting devices from the\n\t\t\t\t# mount point, until our partition is unmounted.\n\t\t\t\twhile (i < count):\n\t\t\t\t\t# Is the partition unmounted?\n\t\t\t\t\tif isDeviceMountedOnMountPoint(partition.getDeviceFilePath(), mountPoint):\n\t\t\t\t\t\tprint \"Attempt #%d\" % (i+1)\n\t\t\t\t\t\tprocess.runIt(\"umount '%s'\" % mountPoint, quiet=True, log=LOG)\n\t\t\t\t\t\ti += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\t# The partition is no longer mounted on the mount point.\n\t\t\t\t\t\tbreak\n\n\t\t\t\t# If we've tried to unmount every device mounted on the mount point,\n\t\t\t\t# but the partition is still mounted, then issue an error.\n\t\t\t\tif isDeviceMountedOnMountPoint(partition.getDeviceFilePath(), mountPoint):\n\t\t\t\t\traise ShowErrorMessage(\"Could not unmount device '%s' from '%s'\" % (partition.getDeviceFilePath(), mountPoint))\n\n\t\t\t\tprint \"Successfully unmounted '%s' from '%s'\" % (partition.getDeviceFilePath(), mountPoint)\n\n\t\t\texcept OSError:\n\t\t\t\traise ShowErrorMessage(\n\t\t\t\t\t\"Could not unmount filesystem mounted at '%s'.\"\\\n\t\t\t\t\t\" Ensure no shell sessions are using files under this\"\\\n\t\t\t\t\t\" mount point.\"\n\t\t\t\t\t% mountPoint, EC_IN_USE)\n\n#######################################################################\n# Main Routine.\n#######################################################################\n\ndef main():\n\t\"\"\"Main entry point when executed as a script from the command line\"\"\"\n\ttry:\n\t\tdm = DiskManager()\n\t\tdm.disable_automount()\n\t\tdm.unmountOurs()\n\n\t\tdisks = dm.get_disk_inventory(BOOT_DISK)\n\n\t\tbootDisks = [disk for disk in disks if disk.isBootDisk]\n\t\tif not bootDisks:\n\t\t\tprint \"Could not identify the system's boot disk\"\n\t\t\treturn EC_NO_BOOT_DISK\n\t\tbootDisk = bootDisks[0]\n\n\t\tunmountAllPartitions(bootDisk)\n\n\texcept ShowErrorMessage, info:\n\t\tprint info.args[0]\n\t\treturn info.args[1]\n\treturn EC_SUCCESS\n\nif __name__ == \"__main__\":\n\tsys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Unmounts all the partitions belonging to the boot disk.\n\nBy default, the boot disk is computed as the first hard drive listed in /proc/partitions.\n\nOptional Custom Attributes:\n\nboot_disk - The absolute path to the device file for the boot disk.  For example, /dev/sda.", 
      "current": true, 
      "versionLabel": "72", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:49.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-28T00:18:49.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Unmounts all the partitions belonging to the boot disk.\n\nBy default, the boot disk is computed as the first hard drive listed in /proc/partitions.\n\nOptional Custom Attributes:\n\nboot_disk - The absolute path to the device file for the boot disk.  For example, /dev/sda.", 
        "current": true, 
        "versionLabel": "72", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:49.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:30:54.000Z", 
    "serverChanging": true, 
    "created": "2014-08-26T06:30:52.000Z", 
    "description": "Installs the HP Service Pack for ProLiant on Linux production OS using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--fail_on_warning : When specified, the script will fail on receiving the error code 253. When absent, the script will be successful for the error code 253. \n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1840001", 
    "modified": "2014-08-26T06:30:54.000Z", 
    "name": "Install Linux SPP for CSI Test", 
    "source": "#!/bin/sh\n\n# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\n# Globals\n# Media Server mount point location\nmountpoint=/mnt/media\nif [ ! -d \"$mountpoint\" ]\nthen\n    mountpoint=/mnt/ms\nfi\n\n\nhpsumargs=\nsppversion=\nbuildver=\n\n#Flag to be used in case --fail_on_warning is specified.\nfailonwarning=0\n#Flag to be used in case -logdir is specified.\nlogdir_specified=0\n#Variable to save the new logdir specified.\nnew_logdir=\"/var/hp/log\"\n\n# ====================\n# Determine SPP Version to install\n# Globals set:  sppversion\n# ====================\nFindSPPVersion ()\n{       \n   if [ \"@SPP_VER@\" == \"\" ]; then\n   \n      sppversion=$(find \"$mountpoint/Media/spp\" -mindepth 1 -maxdepth 1 -type d -printf %f\\\\n | sort | tail -1)\n\n      if [ \"$sppversion\" == \"\" ]; then\n         echo \"Did not find an SPP Version on the media server\"\n         return 999\n      fi\n\n      if [ ! -d \"$mountpoint/Media/spp/$sppversion\" ]; then\n         echo \"$mountpoint/Media/spp/$sppversion is not a directory\"\n         return 999\n      fi  \n\n      buildver=$(find \"$mountpoint/Media/spp/$sppversion\" -mindepth 1 -maxdepth 1 -type d -printf %f\\\\n | sort | tail -1)\n      echo \"buildver is : $buildver\"\n\n      if [ \"$buildver\" == \"\" ]; then\n         echo \"Did not find an BUILD Version on the media server\"\n         return 999\n      fi\n\n      if [ ! -d \"$mountpoint/Media/spp/$sppversion/$buildver\" ]; then\n         echo \"$mountpoint/Media/spp/$sppversion/$buildver is not a directory\"\n         return 999\n      fi\n\n   else\n      \n      if [ \"@BUILD_VER@\" == \"\" ]; then\n         echo \"Please enter BUILD_VER in custom attribute\"\n         return 999\n      else\n         sppversion=@SPP_VER@\n         buildver=@BUILD_VER@         \n      fi\n      \n   fi\n   return 0\n}\n\n# ====================\n# Run HPSUM\n# Globals used:  hpsumargs, sppversion\n# ====================\nRunHPSUM ()\n{\n   if [ ! -d \"$mountpoint/Media/spp/$sppversion/$buildver\" ]; then\n      echo \"$mountpoint/Media/spp/$sppversion/$buildver does not exist\"\n      return 999\n   fi\n\n   echo \"SPP version to be installed is $sppversion\"\n   echo \"Build version to be installed is $buildver\"\n   echo \"Additional hpsum arguments are $hpsumargs\"\n   # Must be run as currently running directory\n   echo \"Enter directory $mountpoint/Media/spp/$sppversion/$buildver/hp/swpackages\"\n   cd $mountpoint/Media/spp/$sppversion/$buildver/hp/swpackages\n\n   ./hpsum /current_credential /silent /On_failed_dependency: Omit_Component\n   rc=$?\n    if [ $rc -gt 3 ] || [ $rc -lt 0 ]; then\n        echo \"SPP hpsum failed: error code $rc\"\n        if [[ $rc -lt 0 ]]; then\n            rc=$(( 256 + $rc ))\n        fi\n      \t  case \"$rc\" in\n\t      255)\n    \t\t  echo \"A general failure occurred. For details, see the error log.\";;\n\t      254)\n    \t\t  echo \"A bad input parameter was encountered.\";;\n              253)\n                  if [ $failonwarning -eq 1 ];then\n\t\t\techo \"ERROR - One or more components failed to install\"\n                        echo \"fail_on_warning is set\"\n       \t\t  else\n\t\t\techo \"WARNING - One or more of the smart components failed to install.\"\n\t\t\techo \"Depending on your system configuration, this may be expected behavior.\"\n\t\t\techo \"To verify the installation, check the hpsum logs located at $new_logdir unless specified otherwise by hpsum -logdir option.\"\n\t\t\techo \"To fail the build plan when these warnings occur, specify the --fail_on_warning option to this step.\"\n\t\t\treturn 0\n\t\t  fi\n\t\t\t;;\n\t  esac\n    \n    echo \"hpsum logs are located at $new_logdir unless specified otherwise by hpsum -logdir option.\"\n    return $rc\n    fi\n}\n\n# ====================\n# Unmount media server\n# Globals used:  mountpoint\n# ====================\nUnmountMediaServer()\n{\n   # Unmount media server drive\n   cd /\n   umount \"$mountpoint\"\n   return 0\n}\n\n# ====================\n# MAIN\n# ====================\n\n# Determine what calling arguments\n# Globals set:  hpsumargs, sppversion\n\nopt=0\nfor i in $*\ndo\n    # Get string to left of =\n    leftstr=${i%=*}\n    # Get string to right of =\n    rightstr=${i##*=}\n    case \"$leftstr\" in\n        \"--spp_version\")\n            sppversion=$rightstr;;\n    \"--hpsum_options\")\n        hpsumargs=$rightstr;;\n    \"--fail_on_warning\")\n       failonwarning=1;;\n    *)\n        if [ $i == \"-logdir\" ];then\n            logdir_specified=1\n            hpsumargs=\"$hpsumargs $i\"\n        elif [ $logdir_specified -eq 1 ]; then\n            hpsumargs=\"$hpsumargs \\\"$i\\\"\"\n            new_logdir=\"\\\"$i\\\"\"\n            logdir_specified=0\n        else\n            hpsumargs=\"$hpsumargs $i\"\n        fi\n        ;;\n    esac\ndone\n\n\nFindSPPVersion\nreturncode=$?\n\nif [ $returncode -eq 0 ]; then\n    RunHPSUM\n    returncode=$?\nfi\nUnmountMediaServer\n\nexit $returncode\n", 
    "state": null, 
    "version": {
      "usage": "Installs the HP Service Pack for ProLiant on Linux production OS using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--fail_on_warning : When specified, the script will fail on receiving the error code 253. When absent, the script will be successful for the error code 253. \n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None", 
      "current": true, 
      "versionLabel": "9", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:30:53.000Z"
    }, 
    "isCustomerContent": true, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-08-26T06:30:54.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Installs the HP Service Pack for ProLiant on Linux production OS using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--fail_on_warning : When specified, the script will fail on receiving the error code 253. When absent, the script will be successful for the error code 253. \n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None", 
        "current": true, 
        "versionLabel": "9", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:30:53.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:36:39.000Z", 
    "serverChanging": false, 
    "created": "2014-03-10T21:36:39.000Z", 
    "description": "This program will modify the Automated Installer manifest files to inject IPS source and root password info.\n\nUsage: inject_required_ai.py [options]\n\noptions:\n  -i IPS_SOURCE, --ips-source=IPS_SOURCE\n                        IPS origin used for installation\n  -m MIRROR, --mirror=MIRROR\n                        IPS mirror used for installation, can be specified multiple times\n  -p PASSWORD, --encrypted-root-password=PASSWORD\n                        Root password for the installed system, encrypted in standard /etc/shadow format\n  -x PROXY, --http-proxy=PROXY\n\t\t\tHTTP proxy used for IPS installation\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/350001", 
    "modified": "2014-03-10T21:36:39.000Z", 
    "name": "Inject Required AI Settings", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n\"\"\"\nThis program will modify the ai.xml and sc.xml manifest files to inject\nthe essential personalization settings for the final system.\n\nThis includes IPS source, an optional http proxy and root password.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\n\nfrom osprov.profile import AIManifest, SCManifest\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\n\nAI_XML_PATH = \"/tmp/ai.xml\"\nSC_XML_PATH = \"/tmp/sc.xml\"\n\nLOG = logger.getIt(\"Inject Required AI settings\")\n\n\nclass InjectOptionsParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"-i\", \"--ips-source\", help=\"IPS origin used for installation\")\n        self.add_option(\"-m\", \"--mirror\", action=\"append\", dest=\"mirrors\",\n                        help=\"IPS mirror used for installation, can specify multiple times\")\n        self.add_option(\"-p\", \"--encrypted-root-password\", dest=\"password\",\n                        help=\"Root password for the installed system, encrypted\")\n        self.add_option(\"-x\", \"--http-proxy\", dest=\"proxy\",\n                        help=\"HTTP proxy used for IPS installation\")\n\n\n@HandleShowErrorMessage(\"inject required AI\", LOG)\ndef main():\n    \"\"\"Inject required AI settings.\"\"\"\n\n    opts, args = InjectOptionsParser().parse_args()\n\n    aiFile = open(AI_XML_PATH, \"r\")\n    aiManifest = AIManifest(aiFile)\n    scFile = open(SC_XML_PATH, \"r\")\n    scManifest = SCManifest(scFile)\n\n    if opts.mirrors:\n        mirrors = opts.mirrors\n    else:\n        mirrors = []\n\n    try:\n        aiManifest.autoreboot = False\n        if opts.ips_source:\n            aiManifest.setIPSPublisherInfo(\"solaris\", ([opts.ips_source], mirrors))\n        if opts.password:\n            scManifest.rootPassword = opts.password\n        if opts.proxy:\n            aiManifest.httpProxy = opts.proxy\n\n        aiManifest.save()\n        scManifest.save()\n    finally:\n        aiFile.close()\n        scFile.close()\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "This program will modify the Automated Installer manifest files to inject IPS source and root password info.\n\nUsage: inject_required_ai.py [options]\n\noptions:\n  -i IPS_SOURCE, --ips-source=IPS_SOURCE\n                        IPS origin used for installation\n  -m MIRROR, --mirror=MIRROR\n                        IPS mirror used for installation, can be specified multiple times\n  -p PASSWORD, --encrypted-root-password=PASSWORD\n                        Root password for the installed system, encrypted in standard /etc/shadow format\n  -x PROXY, --http-proxy=PROXY\n\t\t\tHTTP proxy used for IPS installation\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:36:39.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:36:39.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "This program will modify the Automated Installer manifest files to inject IPS source and root password info.\n\nUsage: inject_required_ai.py [options]\n\noptions:\n  -i IPS_SOURCE, --ips-source=IPS_SOURCE\n                        IPS origin used for installation\n  -m MIRROR, --mirror=MIRROR\n                        IPS mirror used for installation, can be specified multiple times\n  -p PASSWORD, --encrypted-root-password=PASSWORD\n                        Root password for the installed system, encrypted in standard /etc/shadow format\n  -x PROXY, --http-proxy=PROXY\n\t\t\tHTTP proxy used for IPS installation\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:39.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:11.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:11.000Z", 
    "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Oracle Enterprise Linux installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/780001", 
    "modified": "2014-03-10T21:37:11.000Z", 
    "name": "Install bootloader for Oracle Enterprise Linux", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nThis python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, NotFoundError, ShowErrorMessage\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import Netconfig\nfrom osprov.parsers.netconfig import getActiveInterface\nfrom osprov.server import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n# for easier mocking\n\n\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef readFile(filepath):\n    \"\"\"Reads from the file identified by filepath\"\"\"\n    return open(filepath).read()\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATH = \"boot/grub/menu.lst\"\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\" % (source, destination))\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATH = os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\")\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                      % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                         'bootDiskMount': bootDiskMount,\n                         'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                         'bootDisk': bootDisk}, log=LOG, quiet=True)\n        # configure the UEFI boot entries\n        osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    search -n -u %(device_uuid)s -s\n    linux  /%(kernel)s %(kernelArguments)s\n    initrd %(initrds)s\n}\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef configureKernelArguments(osdata, keys, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    os_version = osdata[\"os_version\"]\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in os_version and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    netconfig_ca = StringIO(\"\"\"@hpsa_netconfig@\"\"\")\n    parser = Netconfig.readonly(netconfig_ca)\n    try:\n        activeKey, activeIface = getActiveInterface(localServer, parser.info())\n    except NotFoundError:\n        activeIface = None\n    ip_params = \"\"\n    if activeIface and activeIface.static:\n        net_data = {\n            \"ip\": activeIface.ip[0],\n            \"mask\": activeIface.mask[0],\n            \"dns\": \"\",\n            \"gw\": \"\",\n        }\n        # Static provisioning\n        if hasattr(activeIface, \"dns\") and activeIface.dns:\n            net_data[\"dns\"] = activeIface.dns[0]\n        if hasattr(activeIface, \"gw\"):\n            net_data[\"gw\"] = activeIface.gw[0]\n        ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n    else:\n        # dhcp provisioning\n        ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if not osdata.has_key(\"initrd\"):\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = \"Oracle Enterprise Linux\"\n    osdata[\"os_version\"] = \"OEL\"\n    osdata[\"install_params\"] = \"ks=file:/user.ks.cfg  ksdevice=%(mac)s\"\n    osdata[\"ip_config_static\"] = \"ip=%(ip)s gateway=%(gw)s netmask=%(mask)s\"\n    osdata[\"ip_config_dhcp\"] = \"ip=dhcp noipv6\"\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n\n    _open(os.path.join(bootDiskMount, grub.MENU_PATH), \"w\").write(menu)\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Oracle Enterprise Linux installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:11.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-10T21:37:11.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Oracle Enterprise Linux installation image.\n\nAny initrd files found in the \"localrds\" directory inside the mounted root directory of the stub partition will be added to the INITRD= parameter of the bootloader. \nInitrds can be build by the \"Embed to Initrd\" step or downloaded by a \"Install ZIP\" build plan step configured to place the file(s) into the \"localrds\" directory inside root directory of the stub partition.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n\tkernel_arguments\t- a string of arguments that will be passed to the build images' kernel\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:11.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:24.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:23.000Z", 
    "description": "Cleans up files which refer to MAC of source VM", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1040001", 
    "modified": "2014-03-10T21:37:24.000Z", 
    "name": "Clean up old MAC Addresses (Linux)", 
    "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(c) Copyright 2012 Hewlett-Packard Development Company, L.P.\nClean up old MAC addresses from source VM\n\"\"\"\n\nimport os\nimport sys\n\nfrom osprov.osbp import logger\nfrom osprov import constants\n\nLOG = logger.getIt(\"cleanup_old_macs\")\n\n\ndef main():\n    # clean up files with old MAC addresses while still in maintenance mode\n    net_rules_path = constants.OGFS_SYSTEM_ROOT + '/etc/udev/rules.d/70-persistent-net.rules'\n    if os.path.exists(net_rules_path):\n        LOG.debug(\"Cleaning up file with old MAC address: \" + net_rules_path)\n        os.unlink(net_rules_path)\n\nif __name__ == \"__main__\":\n    main()\n", 
    "state": null, 
    "version": {
      "usage": "Cleans up files which refer to MAC of source VM", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:23.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:24.000Z", 
    "runAsSuperUser": false, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Cleans up files which refer to MAC of source VM", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:23.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:36:51.000Z", 
    "serverChanging": false, 
    "created": "2014-03-10T21:36:50.000Z", 
    "description": "This program will unpack, resize and modify the Solaris boot_archive to include\nall necessary files for automated installation.\n\nusage: modify_boot_archive.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Copy Solaris Boot Media'", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/560001", 
    "modified": "2014-03-10T21:36:51.000Z", 
    "name": "Modify Boot Archive", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n\"\"\"\nThis program will unpack, resize and modify the Solaris boot_archive to include\nall necessary files for automated installation.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nimport shutil\n\nfrom osprov.osbp import logger\nfrom osprov import helpers\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.wrappers.boot_archive import BootArchive\n\nLOG = logger.getIt(\"Modify Boot Archive\")\n\nNET_ASSEMBLY_PATH = \"/usr/share/opsware/net-assembly-osprov\"\nMANIFEST_LOCATOR_PATH = \"/usr/share/opsware/manifest-locator-osprov\"\nAGENT_STARTER_NAME = \"hpsa-ogfs-autodl.sh\"\nSOS_AGENT_STARTER_LOCATION = os.path.join(\"/lib/svc/hpsa-ogfs\", AGENT_STARTER_NAME)\nAI_XML_PATH = \"/tmp/ai.xml\"\nSC_XML_PATH = \"/tmp/sc.xml\"\nAGENT_INSTALLER_REPO_PATH = \"/tmp/hpsa-repo/repo\"\n\nNET_ASSEMBLY_TARGET = \"lib/svc/method/net-assembly\"\nMEDIA_ASSEMBLY_TARGET = \"lib/svc/method/media-assembly\"\nMANIFEST_LOCATOR_TARGET = \"lib/svc/method/manifest-locator\"\n\nHPSA_DIR = \"hpsa\"\n\n\n@HandleShowErrorMessage(\"Modify Boot Archive\", LOG)\ndef main():\n    \"\"\"Main method, does all modifications.\"\"\"\n\n    # Temporary: check if x86, if not, fail. SPARC will be implemented in the future.\n    if not os.uname()[-1].startswith(\"i86\"):\n        raise NotImplementedError(\"Module not available yet on SPARC.\")\n\n    bootArchiveObj = BootArchive(\n        log=LOG, thisLocalServer=ThisLocalServer(), dataStoreKeys=helpers.getDataStore(), osVersion=\"11\")\n    # Check if we need to include an hpsa-agent-installer repo, and determine its size\n    if os.path.isdir(AGENT_INSTALLER_REPO_PATH):\n        extrasize = helpers.dirSize(AGENT_INSTALLER_REPO_PATH)\n    else:\n        extrasize = 0\n\n    bootArchiveObj.unpack()\n    bootArchiveObj.grow(200 + (extrasize >> 20))\n    bootArchiveObj.mount()\n\n    hpsaDir = os.path.join(bootArchiveObj.mountpoint, HPSA_DIR)\n    netAssemblyTarget = os.path.join(bootArchiveObj.mountpoint, NET_ASSEMBLY_TARGET)\n    mediaAssemblyTarget = os.path.join(bootArchiveObj.mountpoint, MEDIA_ASSEMBLY_TARGET)\n    manifestLocatorTarget = os.path.join(bootArchiveObj.mountpoint, MANIFEST_LOCATOR_TARGET)\n    helpers.makeDirs(hpsaDir)\n\n    # Modifications per-se\n    # Replace default startup methods\n    shutil.copy2(NET_ASSEMBLY_PATH, netAssemblyTarget)\n    print \"Copied %s to %s\" % (NET_ASSEMBLY_PATH, netAssemblyTarget)\n    shutil.copy2(NET_ASSEMBLY_PATH, mediaAssemblyTarget)\n    print \"Copied %s to %s\" % (NET_ASSEMBLY_PATH, mediaAssemblyTarget)\n    shutil.copy2(MANIFEST_LOCATOR_PATH, manifestLocatorTarget)\n    print \"Copied %s to %s\" % (MANIFEST_LOCATOR_PATH, manifestLocatorTarget)\n\n    # Copy boot files\n    shutil.copy2(\n        os.path.join(bootArchiveObj.bootfilesPath, \"solaris.zlib\"), bootArchiveObj.mountpoint)\n    shutil.copy2(\n        os.path.join(bootArchiveObj.bootfilesPath, \"solarismisc.zlib\"), bootArchiveObj.mountpoint)\n    shutil.copy2(\n        os.path.join(bootArchiveObj.bootfilesPath, \".image_info\"), bootArchiveObj.mountpoint)\n\n    # Copy AI manifests\n    shutil.copy2(AI_XML_PATH, hpsaDir)\n    shutil.copy2(SC_XML_PATH, hpsaDir)\n\n    # Copy mid and crypto\n    destMIDpath = os.path.join(\n        bootArchiveObj.mountpoint, bootArchiveObj.localServer.MID_FILE.lstrip(\"/\"))\n    destCryptoDir = os.path.join(\n        bootArchiveObj.mountpoint, bootArchiveObj.localServer.CRYPTO_DIR.lstrip(\"/\"))\n    helpers.makeDirs(os.path.join(bootArchiveObj.mountpoint, os.path.dirname(destMIDpath)))\n    shutil.copy2(bootArchiveObj.localServer.MID_FILE, destMIDpath)\n    shutil.rmtree(destCryptoDir, ignore_errors=True)\n\n    helpers.makeDirs(os.path.dirname(destCryptoDir))\n    shutil.copytree(bootArchiveObj.localServer.CRYPTO_DIR, destCryptoDir)\n\n    # Include agent starter\n    agentStarterDestination = os.path.join(hpsaDir, AGENT_STARTER_NAME)\n    f = open(agentStarterDestination, \"w\")\n    f.write(bootArchiveObj.localServer.getOgfsAgentStartupScript())\n    f.flush()\n    f.close()\n    shutil.copymode(SOS_AGENT_STARTER_LOCATION, agentStarterDestination)\n\n    # Include hpsa-agent-installer repo if present\n    if extrasize:\n        dest = os.path.join(bootArchiveObj.mountpoint, \"hpsa/repo\")\n        shutil.copytree(AGENT_INSTALLER_REPO_PATH, dest)\n\n    bootArchiveObj.umount()\n    bootArchiveObj.repack()\n    bootArchiveObj.cleanup()\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "This program will unpack, resize and modify the Solaris boot_archive to include\nall necessary files for automated installation.\n\nusage: modify_boot_archive.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Copy Solaris Boot Media'", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:36:51.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:36:51.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "This program will unpack, resize and modify the Solaris boot_archive to include\nall necessary files for automated installation.\n\nusage: modify_boot_archive.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Copy Solaris Boot Media'", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:36:51.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:20.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:20.000Z", 
    "description": "Will install grub on the stub partition and the MBR of its containing\ndisk. Also it will install a default menu.lst file.\n\nusage: install_grub.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -o VERSION, --os-version=VERSION\n                        The Solaris OS version, valid values are: '11.1', '11 11/11', '10'\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition'", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/970001", 
    "modified": "2014-03-10T21:37:20.000Z", 
    "name": "Install Solaris Grub", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n\"\"\"\nThis program will install grub on the stub partition and the MBR of its containing\ndisk. Also it will install a default grub.cfg file depending on the OS.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\n\nfrom osprov import helpers\nfrom osprov.util import process\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import NotSupportedError, DiscoveryError\nfrom osprov.osbp import logger\nfrom osprov.server.local import ThisLocalServer, LocalServer\n\nGRUB_CFG_DEST = \"boot/grub/grub.cfg\"\n\nSOLARIS10_GRUB_CFG_TEMPLATE = \"\"\"\nset timeout=10\nset default=\"0\"\n\nmenuentry \"HPSA assisted Oracle Solaris %(osVersion)s install\" {\n    search --no-floppy --file --set=root /@/sol-x86/multiboot\n    set mod=/@/sol-x86/x86.miniroot\n    set kern=/@/sol-x86/multiboot\n    echo -n \"Loading (${root})$kern:\"\n    multiboot $kern $kern kernel/unix - install dhcp file:///jumpstart/config.tar\n    echo -n \"Loading $mod:\"\n    module $mod $mod\n}\n\"\"\"\n\nSOLARIS11_GRUB_CFG_TEMPLATE = \"\"\"set timeout=10\nset default=\"0\"\n\nmenuentry \"HPSA assisted Oracle Solaris %(osVersion)s install\" {\n    search --no-floppy --file --set=root /@/platform/i86pc/kernel/amd64/unix\n    set kern=/@/platform/i86pc/kernel/amd64/unix\n    echo -n \"Loading (${root})$kern: \"\n    multiboot $kern $kern -B install=true,install_media=,install_service=,install_svc_address=,hpsaagw=%(gwIpPort)s,livemode=text\n    echo -n \"Loading (${root})/platform/i86pc/amd64/boot_archive: \"\n    module /@/platform/i86pc/amd64/boot_archive\n}\n\"\"\"\n\nLOG = logger.getIt(\"Install Solaris Grub\")\n\n\nclass InstallSolarisGrubOptionParser (OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"-o\", \"--os-version\", dest=\"version\",\n                        help=\"The Solaris OS version, valid values are: '10', '11.1', '11 11/11'\")\n\n    def validateArgs(self, opt, args):\n        if not opt.version:\n            raise OptionValueError(\"Must specify an OS version argument\")\n        elif not opt.version.startswith(\"11\") and not opt.version.startswith(\"10\"):\n            raise OptionValueError(\"Only Solaris 10 and Solaris 11 are supported\")\n\n\ndef getGrubTemplate(osVersion):\n    \"\"\"Return GRUB template for the specified OS Version.\"\"\"\n    if osVersion.startswith(\"10\"):\n        return SOLARIS10_GRUB_CFG_TEMPLATE\n    if osVersion.startswith(\"11\"):\n        return SOLARIS11_GRUB_CFG_TEMPLATE\n\n\ndef writeGrubCfg(opts, agw, grubCfgDest):\n    LOG.info(\"Writing final grub.cfg file.\")\n    g = open(grubCfgDest, \"w\")\n    g.write(getGrubTemplate(opts.version) % {\n            'osVersion': opts.version,\n            'gwIpPort': agw\n            })\n    g.close()\n\n\n@HandleShowErrorMessage(\"Install Solaris Grub\", LOG)\ndef main():\n    \"\"\"Installs grub on stub partition.\"\"\"\n\n    if not os.uname()[-1].startswith(\"i86\"):\n        raise NotSupportedError(\"Installing grub is not supported on SPARC.\")\n\n    opts, args = InstallSolarisGrubOptionParser().parse_args()\n\n    keys = helpers.getDataStore()\n    rawDevpath = keys.disk.device_path\n    stubMountpoint = keys.disk.device_mount\n    grubCfgDest = os.path.join(stubMountpoint, GRUB_CFG_DEST)\n    grubCfgDir = os.path.dirname(grubCfgDest)\n\n    if not os.path.isdir(grubCfgDir):\n        os.makedirs(grubCfgDir)\n\n    LOG.info(\"Determining Agent Gateway.\")\n    agw = LocalServer.gateway2str(ThisLocalServer().getRandomAgentGateway())\n    if agw is None:\n        raise DiscoveryError(\"Could not determine the agent gateway\")\n\n    grubCmd = \"/usr/lib/grub2/bios/sbin/grub-install --grub-directory=%s --recheck --force --force-mbr %s\" % (\n        grubCfgDir, rawDevpath)\n    process.runIt(grubCmd, log=LOG)\n\n    writeGrubCfg(opts, agw, grubCfgDest)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Will install grub on the stub partition and the MBR of its containing\ndisk. Also it will install a default menu.lst file.\n\nusage: install_grub.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -o VERSION, --os-version=VERSION\n                        The Solaris OS version, valid values are: '11.1', '11 11/11', '10'\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition'", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:20.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:20.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Will install grub on the stub partition and the MBR of its containing\ndisk. Also it will install a default menu.lst file.\n\nusage: install_grub.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -o VERSION, --os-version=VERSION\n                        The Solaris OS version, valid values are: '11.1', '11 11/11', '10'\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition'", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:20.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:29.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:21.000Z", 
    "description": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1000001", 
    "modified": "2014-03-28T00:18:29.000Z", 
    "name": "Windows Image Deploy", 
    "source": "#!/usr/bin/python\r\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\r\n# ex: set tabstop=4 :\r\n# Please do not change the two lines above. See PEP 8, PEP 263.\r\n#\r\n\r\nimport sys\r\nimport os\r\nimport shutil\r\nfrom optparse import OptionError\r\nfrom osprov.optparse_ext import OptionParser\r\nfrom osprov.scripts import bootmode\r\nfrom osprov.osbp import logger\r\nfrom osprov.util import process\r\nfrom osprov.decorators import HandleShowErrorMessage\r\nfrom osprov import diskmgr\r\nfrom osprov.diskmgr import const, disk, diskmanager, partition\r\nfrom osprov.server import ThisLocalServer\r\nfrom osprov.errors import ProcessExecutionError\r\n\r\nLOG = logger.getIt(\"windows_image_deploy\")\r\n\r\n\r\nclass WindowsImageDeployOptionParser(OptionParser):\r\n\r\n    \"\"\" Option parser for this step \"\"\"\r\n\r\n    def defineOptions(self):\r\n        self.add_option(\"--bootMode\", type=\"string\",\r\n                        help=\"boot mode of the server, can be UEFI or Legacy\")\r\n        self.add_option(\"--systemDiskNumber\", type=\"int\", default=0,\r\n                        help=\"system disk number where Windows will be deployed (default disk number is '0').\")\r\n        self.add_option(\"--systemPartitionLabel\", type=\"string\", default=\"System\",\r\n                        help=\"label of partition where Windows will be deployed\")\r\n        self.add_option(\"--wimFilePath\", type=\"string\",\r\n                        help=\"path where to get WIM file\")\r\n\r\n    def validateArgs(self, opt, args):\r\n        if opt.bootMode and not opt.bootMode.lower() in [x.lower() for x in bootmode.SUPPORTED_BOOT_MODES]:\r\n            raise OptionError(\"Invalid boot mode: \" + opt.bootMode, \"bootMode\")\r\n        if not opt.wimFilePath:\r\n            raise OptionError(\"Missing parameter: --wimFilePath\", \"wimFilePath\")\r\n\r\n\r\ndef deployPartition(driveLetter, wimFilePath, log=LOG):\r\n    process.runIt(\"imagex /check /verify /apply \\\"%s\\\" 1 %s:\\\\\" %\r\n                  (wimFilePath, driveLetter), checkExitCode=(0,), log=log)\r\n\r\ndef runAndIgnoreResult(cmdLine, log=LOG):\r\n    try:\r\n        process.runIt(cmdLine, checkExitCode=(0,1), log=log)\r\n    except ProcessExecutionError:\r\n        pass\r\n\r\ndef updateBCDForLegacy(windowsDriveLetter, log=LOG):\r\n    bcdbootPath = windowsDriveLetter + \":\\\\Windows\\\\System32\\\\bcdboot.exe\"\r\n    if os.path.isfile(bcdbootPath):\r\n        shutil.copyfile(bcdbootPath, \"\\\\Windows\\\\Temp\\\\bcdboot.exe\")\r\n        updateBcdLine = \"\\\\Windows\\\\Temp\\\\bcdboot.exe %s:\\\\Windows /s %s:\" % (windowsDriveLetter, windowsDriveLetter)\r\n        try:\r\n            process.runIt(updateBcdLine, checkExitCode=(0,), log=log)\r\n            runAndIgnoreResult(updateBcdLine+\" /f BIOS\", log=log)\r\n            return\r\n        except ProcessExecutionError:\r\n            print \"OS bcdboot failed to run, will retry using the WinPE bcdboot\"\r\n            pass\r\n\r\n    updateBcdLine = \"bcdboot.exe %s:\\\\Windows /s %s:\" % (windowsDriveLetter, windowsDriveLetter)\r\n    process.runIt(updateBcdLine, checkExitCode=(0,), log=log)\r\n    runAndIgnoreResult(updateBcdLine+\" /f BIOS\", log=log)\r\n\r\ndef updateBCDForUefi(espDriveLetter, windowsDriveLetter, log=LOG):\r\n    process.runIt(\"bcdedit /set {bootmgr} device partition=%s:\" %\r\n                  espDriveLetter, checkExitCode=(0,), log=log)\r\n    process.runIt(\"bcdedit /set {memdiag} device partition=%s:\" %\r\n                  espDriveLetter, checkExitCode=(0,), log=log)\r\n    process.runIt(\"bcdedit /set {default} device partition=%s:\" %\r\n                  windowsDriveLetter, checkExitCode=(0,), log=log)\r\n    process.runIt(\"bcdedit /set {default} osdevice partition=%s:\" %\r\n                  windowsDriveLetter, checkExitCode=(0,), log=log)\r\n    process.runIt(\r\n        \"bcdedit /set {FWbootmgr} displayorder {Bootmgr} /addfirst\", checkExitCode=(0,), log=log)\r\n\r\n@HandleShowErrorMessage(\"Windows Image Deploy\", LOG)\r\ndef main():\r\n\r\n    # get and parse arguments\r\n    options, remainingArgs = WindowsImageDeployOptionParser().parse_args()\r\n    wimFilePath = options.wimFilePath.strip()\r\n    systemDiskNumber = options.systemDiskNumber\r\n    # get bootmode (legacy bios or uefi)\r\n    if options.bootMode:\r\n        bootMode = options.bootMode\r\n    else:\r\n        bootMode = bootmode.getCurrentBootMode(ThisLocalServer(), log=LOG)\r\n\r\n    windowsDriveLetter = disk.WindowsDisk(systemDiskNumber).getPartitionWithLabel(\r\n        options.systemPartitionLabel).letter\r\n\r\n    partitionTable = diskmgr.getPartitionTable(bootMode)\r\n    if const.PARTITION_TABLE_MBR == partitionTable:\r\n        print \"Deploy Windows Image based on Legacy Windows Partitioning Schema\"\r\n        deployPartition(windowsDriveLetter, wimFilePath)\r\n        updateBCDForLegacy(windowsDriveLetter)\r\n\r\n    elif const.PARTITION_TABLE_GPT == partitionTable:\r\n        print \"Deploy Windows Image based on Uefi Windows Partitioning Schema\"\r\n        freeLetter = diskmanager.WindowsDiskManager().findFirstAvailableDriveLetter()\r\n        partition.WindowsPartition(systemDiskNumber, 1).setPartitionLetter(freeLetter)\r\n        deployPartition(freeLetter, wimFilePath + \"_ESP\")\r\n        deployPartition(windowsDriveLetter, wimFilePath)\r\n        updateBCDForUefi(freeLetter, windowsDriveLetter)\r\n\r\nif __name__ == \"__main__\":\r\n    sys.exit(main())\r\n", 
    "state": null, 
    "version": {
      "usage": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.", 
      "current": true, 
      "versionLabel": "5", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:29.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-28T00:18:29.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:21.000Z"
      }, 
      {
        "usage": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.", 
        "current": false, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:30.000Z"
      }, 
      {
        "usage": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.", 
        "current": false, 
        "versionLabel": "3", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:16:31.000Z"
      }, 
      {
        "usage": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.", 
        "current": false, 
        "versionLabel": "4", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:17:52.000Z"
      }, 
      {
        "usage": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.", 
        "current": true, 
        "versionLabel": "5", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:29.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:09:36.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:42.000Z", 
    "description": "Updates the target server firmware using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  All the options must be enclosed within double quotes.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--hpsum_logs_dump_dir=writable_directory_under_mounted_file_share    Copies the zipped HP SUM log files to the specified directory.  The directory must start with the mount point specified in the \"Set Media Source\" Build Plan Step.  For example, if the file share where the zipped HP SUM log file is to be copied to is mounted on \"/mnt/media\" and the destination directory is \"hpsum_logs\", then specify \"--hpsum_logs_dump_dir=/mnt/media/hpsum_logs\".\n\n--no_show_log   Don't display the \"hpsum_log.txt\" contents in the job log.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1390001", 
    "modified": "2014-03-28T00:09:36.000Z", 
    "name": "Update Firmware Using SPP", 
    "source": "#!/bin/sh\n# (c) Copyright 2013, 2014 Hewlett-Packard Development Company, L.P.\n\nif [ ! -e \"/root/compaq\" ]\nthen\n   # We're not in the Intelligent Provisioning so we can't perform this\n   # script successfully in all cases.\n   echo \"ERROR: Offline firmware updates are not supported using the PXE booted environment.\"\n   echo \"Offline firmware updates can be performed using Intelligent Provisioning.\"\n   exit 1\nfi\n\n# The \"zip\" command is only available in the PXE Linux service OS from the \n# \"/opt/opsware/agent/bin\" directory, so we must add it to the path.\n# We also need \"tr\" which is located in \"/opt/opsware/agent/osprov/bin/x86\".\nPATH=${PATH}:/opt/opsware/agent/bin:/opt/opsware/agent/osprov/bin/x86\n\n# The default HP SUM log directory.  This may be overridden with the \"/logdir\" or\n# \"-logdir\" option.\nhpSumLogDir=\"/var\"\n\n# A directory that we use as a workaround for the fact that, on the PXE\n# Linux Service OS, the \"/tmp\" filesystem is small and fills up when\n# hpsum copies files to \"/tmp/hp_sum\".\nhpSumStageDir=/hp_sum\n\n# The mount point where the file share is mounted.\n# if /mnt/media not exist fall back to /mnt/ms mount point\nmountPoint=/mnt/media\nif [ ! -d \"$mountPoint\" ]\nthen\n\tmountPoint=/mnt/ms\nfi\n\n# Any additional options to HP SUM, which may be specified as a parameter\n# to this script.\nhpSumOptions=\n\n# The SPP version we want to install, which may be specified as a parameter\n# to this script.\nsppVersion=\n\n# The directory on the file share where the SPPs are stored.\nsppDir=\"$mountPoint/Media/spp\"\n\n# The relative path to the file that contains the SPP version.\nrelativePathToSppVersionFile=\"hp/swpackages/_fwdvdver.xml\"\n\n# The subdirectory on the file share where we can dump the zipped HP SUM logs.\nhpSumLogsDumpDir=\"\"\n\n# Sets the HDU_BOOTENV_SMPJTB=yes environment variable which tells HP SUM to\n# copy the files from the file share to the local system.  This is preferred\n# in order to avoid a situation where a NIC firmware update might cause the\n# mounted share connection to drop.  This can be changed using the\n# \"--hpsum_copy_files_locally\" parameter.  One reason that we may not want\n# HP SUM to copy the files locally is if there isn't enough space on the\n# target server to copy the files.\nhpSumCopyFilesLocally=\"true\"\n\n# The zip file containing the HP SUM logs.\nhpSumLogsZipFile=/tmp/hpsum_logs.zip\n\n# Show the \"Installed Components:\" section of \"hpsum_log.txt\" by default\n# unless it's disabled by the \"--no_show_log\" option.\nshowHpSumLog=1\n\n##############################################################################\n# This function returns the version of the SPP, as contained in the\n# \"hp/swpackages/_fwdvdver.xml\" file.\n##############################################################################\n\ngetSppVersion() {\n    local sppVersionPath=$1\n    set `cat ${sppVersionPath} | sed -n -e 's@.*<version>\\([0-9a-zA-Z\\.-]*\\)</version>.*@\\1@p'`\n    ver=$1\n    echo ${ver}\n}\n\n##############################################################################\n# This function returns the server ID for the target server.  Since the PXE\n# Linux Service OS does not contain the \"tr\" command, we have to remove the\n# trailing \"\\r\\n\" from the server ID contained in \"/etc/opt/opsware/agent/mid\"\n# ourselves.\n##############################################################################\n\ngetServerId()\n{\n    # Read the server ID, which will contain a trailing CR and LF.\n    local idWithCrAndLf=$(cat /etc/opt/opsware/agent/mid)\n\n    local serverId=\"\"\n\n    # Get the length.\n    len=${#idWithCrAndLf}\n\n    # Iterate through each character and build up the server ID\n    # until we reach a non-digit (e.g. CR or LF).\n    for (( i = 0; i <= ${len}; i++ ))\n    do\n        char=\"${idWithCrAndLf:${i}:1}\"\n\n        if [[ ${char} = [[:digit:]] ]]\n        then\n            serverId=\"${serverId}${char}\"\n        else\n            break;\n        fi\n    done\n\n    echo -n \"${serverId}\"\n}\n\n##############################################################################\n# This function returns the absolute path to the HP SUM detail log.\n##############################################################################\n\ngetHpSumDetailLog()\n{\n    local logFile=${hpSumLogDir}/hp/log/localhost/hpsum_detail_log.txt\n\n    if [ -e \"${logFile}\" ]\n    then\n        echo \"${logFile}\"\n    fi\n}\n\n##############################################################################\n# This function returns the absolute path to the HP SUM log file.\n##############################################################################\n\ngetHpSumLog()\n{\n    local logFile=${hpSumLogDir}/hp/log/localhost/hpsum_log.txt\n\n    if [ -e \"${logFile}\" ]\n    then\n        echo \"${logFile}\"\n    fi\n}\n\n##############################################################################\n# This function returns the absolute path to the HP SUM trace file.\n##############################################################################\n\ngetHpSumTraceFile()\n{\n    local logFile=/tmp/hp_sum/OpMan.trace\n\n    if [ -e \"${logFile}\" ]\n    then\n        echo \"${logFile}\"\n    fi\n}\n\n##############################################################################\n# This function returns all the log files under the \"/tmp/HPSUM\" directory\n# that was first introduced in HP SUM 6.0.  The \"/tmp/HPSUM\" directory\n# replaces the \"/tmp/hp_sum\" directory from earlier versions of HP SUM.\n##############################################################################\n\ngetOtherHpSumLogs() {\n    local logFiles=\n\n    if [ -e /tmp/HPSUM ] && [ -d /tmp/HPSUM ]\n    then\n        for logFile in `find /tmp/HPSUM -name \"*\\.log\"`\n        do\n            logFiles=\"${logFiles} ${logFile}\"\n        done\n    fi\n\n    echo $logFiles\n}\n\n##############################################################################\n# This function returns the absolute path to the HP SUM log files.\n##############################################################################\n\ngetHpSumLogs()\n{\n    local hpSumDetailLog=$(getHpSumDetailLog)\n    local hpSumLog=$(getHpSumLog)\n    local hpSumTrace=$(getHpSumTraceFile)\n    local otherHpSumLogs=$(getOtherHpSumLogs)\n    local hpSumLogs=\"${hpSumDetailLog} ${hpSumLog} ${hpSumTrace} ${otherHpSumLogs}\"\n\n    echo \"${hpSumLogs}\"\n}\n\n##############################################################################\n# This function scans the user-specified HP SUM command line options for the\n# \"/logdir\" or \"-logdir\" option, which changes the directory in which HP SUM\n# places its log files.  If the option was specified, then our script makes a\n# note of it, so that we can grab the HP SUM log files from the correct \n# location when the firmware update is complete.\n##############################################################################\n\ncheckForOverrideOfHpSumLogDir()\n{\n    local hpSumOptions=\"$1\"\n\n    # This will contain \"/logdir\" or \"-logdir\" if either form was specified\n    # in the HP SUM options.  It is only used to display a message to stdout.\n    optName=\"\"\n\n    # We'll start off assuming that the \"/logdir\" or \"-logdir\" option was not\n    # specified in the HP SUM options.\n    containsLogDir=0\n\n    # Iterate through the user-specified HP SUM options and check if the\n    # \"/logdir\" or \"-logdir\" option was specified.\n    for arg in ${hpSumOptions}\n    do\n        if [ ${containsLogDir} -eq 1 ]\n        then\n            hpSumLogDir=${arg}\n\n            # Don't break out of for-loop.  Keep going in case \"-logdir\" or\n            # \"/logdir\" was specified more than once, for whatever reason.\n            # The last one specified takes precedence over the previous ones.\n            containsLogDir=0\n\n            echo \"HP SUM log directory overridden by option '${optName} ${hpSumLogDir}'\"\n        elif [ \"${arg}\" == \"/logdir\" ] || [ \"${arg}\" == \"-logdir\" ]\n        then\n            optName=${arg}\n            containsLogDir=1\n        fi\n    done\n}\n\n##############################################################################\n# This function determines which version of the SPP to install.  Unless a\n# specific SPP version is specifed, the latest SPP, as determined by the\n# sort order, is used.\n##############################################################################\n\nfindSPPVersion ()\n{\n    if [ \"$sppVersion\" == \"\" ] || [ \"$sppVersion\" == \"latest\" ]\n    then\n        sppVersion=$(find \"${sppDir}\" -mindepth 1 -maxdepth 1 -type d -printf %f\\\\n | sort | tail -1)\n\n        if [ \"$sppVersion\" == \"\" ]\n        then\n            echo \"No SPP directories were found under '${sppDir}'\" 1>&2\n            echo \"Check your media server and verify that there is at least one directory under the '/Media/spp' directory which contains the SPP files\" 1>&2\n            echo \"SPP directories are typically named using the SPP version, for example '2012.08'\" 1>&2\n            return 1\n        fi\n        if [ ! -d \"${sppDir}/${sppVersion}\" ]\n        then\n            echo \"${sppDir}/${sppVersion} is not a directory\" 1>&2\n            return 1\n        fi\n    fi\n\n    return 0\n}\n\n##############################################################################\n# This function runs the \"hpsum\" executable contained in the SPP that's\n# mounted from the media share.\n##############################################################################\n\nrunHPSUM ()\n{\n    local retCode=0\n\n    echo \"SPP version to be installed is $sppVersion\"\n\n    sppVersionDir=\"${sppDir}/$sppVersion\"\n\n    # Check if the directory containing the SPP exists.\n    if [ ! -d \"${sppVersionDir}\" ]\n    then\n        echo \"'${sppVersionDir}' does not exist\" 1>&2\n        return 1\n    fi\n\n    sppVersionFile=\"${sppVersionDir}/${relativePathToSppVersionFile}\"\n\n    if [ -e ${sppVersionFile} ]\n    then\n        sppVersionContainedInFile=$(getSppVersion ${sppVersionFile})\n\n        if [ ! -z ${sppVersionContainedInFile} ]\n        then\n            echo \"SPP version as reported in '${relativePathToSppVersionFile}' is '${sppVersionContainedInFile}'\"\n        else\n            echo \"Could not find the SPP version in '${relativePathToSppVersionFile}'\" 1>&2\n        fi\n    else\n        echo \"'${sppVersionFile}' not found\" 1>&2\n    fi\n\n    # Check if any HP SUM options were specified.\n    if [[ ! ${hpSumOptions} =~ [^[:space:]] ]] ; then\n        echo \"No additional HP SUM arguments were specified\"\n    else\n        echo \"Additional HP SUM arguments => ${hpSumOptions}\"\n    fi\n\n    # HP SUM copies some files to \"/tmp/hp_sum\".  On the PXE Linux Service OS,\n    # the \"/tmp\" filesystem is small and cannot accomdate the HP SUM files.\n    # As a workaround, we create an \"hp_sum\" directory under the root file\n    # system and create a symlink from \"/tmp/hp_sump\" to \"/hp_sum\".\n    if [ ! -d ${hpSumStageDir} ]\n    then\n        echo \"Creating directory '${hpSumStageDir}'\"\n        mkdir ${hpSumStageDir}\n\n        if [ $? -ne 0 ]\n        then\n            echo \"Failed to create the directory '${hpSumStageDir}'\" 1>&2\n            return 1\n        fi\n    fi\n\n    echo \"Creating a symlink from '/tmp/hp_sum' to '${hpSumStageDir}'\"\n\n    # Create a symlink from \"/tmp/hp_sum\" to \"/hp_sum\" to workaround the small \"/tmp\"\n    # filesystem size in the PXE Linux Service OS.\n    ln -f -s ${hpSumStageDir} /tmp/hp_sum\n\n    if [ $? -ne 0 ]\n    then\n        echo \"Failed to create symbolic link from /tmp/hp_sum to ${hpSumStageDir}\" 1>&2\n        return 1\n    fi\n\n    # HP SUM expects the \"rpm\" binary to be under \"/bin\", but on the SA Linux Service OS\n    # the \"rpm\" binary is under \"/usr/bin\".  Therefore, we'll create a symlink from\n    # \"/bin/rpm\" to \"/usr/bin/rpm\" to prevent \"hpsum\" from failing.\n    if [ ! -e /bin/rpm ]\n    then\n        if [ -e /usr/bin/rpm ]\n        then\n            echo \"Creating a symlink from '/bin/rpm' to '/usr/bin/rpm'\"\n\n            ln -f -s /usr/bin/rpm /bin/rpm\n\n            if [ $? -ne 0 ]\n            then\n                echo \"Failed to create symbolic link from '/bin/rpm' to '/usr/bin/rpm'\" 1>&2\n                return 1\n            fi\n        fi\n    fi\n\n    # The packages directory is where the \"hpsum\" executable and the firmware\n    # files reside.  Let's make sure that it exists.\n    packagesDir=\"${sppVersionDir}/hp/swpackages\"\n\n    if [ ! -e \"${packagesDir}\" ]\n    then\n        echo \"'${packagesDir}' does not exist\"\n        return 1\n    fi\n\n    # Must be run as currently running directory\n    cd ${packagesDir}\n\n    if [ $? -ne 0 ]\n    then\n        echo \"Could not change directory to '${packagesDir}'\" 1>&2\n        return 1\n    fi\n\n    # To get HPSUM to run in offline mode, we need to set the environment variable\n    # HDU_BOOTENV_SMPJTB=yes.  This will cause HPSUM to copy the files to the temp\n    # location (/tmp/hp_sum today and /var/hp/hpsum in the future) and then execute\n    # the components from there.  The reason for doing this is to avoid a situation\n    # where the NIC over which the file share is mounted goes unresponsive while\n    # its firmware is being updated, potentially dropping the connection to the\n    # file share.\n    if [ \"${hpSumCopyFilesLocally}\" == \"true\" ]\n    then\n        echo \"Setting environment variable HDU_BOOTENV_SMPJTB=yes\"\n        export HDU_BOOTENV_SMPJTB=yes\n    fi\n\n    hp_sum_cmd=\"./hpsum /romonly /silent $hpSumOptions\"\n\n    echo \"Executing => ${hp_sum_cmd}\"\n\n    # Run HP SUM.\n    ${hp_sum_cmd}\n\n    hpSumRetCode=$?\n\n    # +--------------------------------------------------------------+\n    # |       Return code        | Value | Linux |       Text        |\n    # |--------------------------+-------+-------+-------------------|\n    # | SUCCESS_NO_REBOOT        | 0     | 0     | The installation  |\n    # |                          |       |       | was successful.   |\n    # |--------------------------+-------+-------+-------------------|\n    # |                          |       |       | The installation  |\n    # | SUCCESS_REBOOT           | 1     | 1     | was successful,   |\n    # |                          |       |       | but a reboot is   |\n    # |                          |       |       | required.         |\n    # |--------------------------+-------+-------+-------------------|\n    # |                          |       |       | The component was |\n    # | SUCCESS_NOT_REQUIRED     | 3     | 3     | current or not    |\n    # |                          |       |       | required.         |\n    # |--------------------------+-------+-------+-------------------|\n    # |                          |       |       | A general failure |\n    # | FAILURE_GENERAL          | -1    | 255   | occurred. For     |\n    # |                          |       |       | details, see the  |\n    # |                          |       |       | error log.        |\n    # |--------------------------+-------+-------+-------------------|\n    # |                          |       |       | A bad input       |\n    # | FAILURE_BAD_PARM         | -2    | 254   | parameter was     |\n    # |                          |       |       | encountered.      |\n    # |--------------------------+-------+-------+-------------------|\n    # |                          |       |       | The installation  |\n    # | FAILURE_COMPONENT_FAILED | -3    | 253   | of the component  |\n    # |                          |       |       | failed.           |\n    # +--------------------------------------------------------------+\n\n    if [ ${hpSumRetCode} -gt 3 ] || [ ${hpSumRetCode} -lt 0 ]; then\n        echo \"hpsum failed with return code ${hpSumRetCode}\"\n        retCode=${hpSumRetCode}\n    else\n        echo \"hpsum successfully completed with return code ${hpSumRetCode}\"\n        retCode=0\n    fi\n\n    echo \"hpsum logs are located at /var/hp/log unless specified otherwise by hpsum -logdir option\"\n\n    return ${retCode}\n}\n\n##############################################################################\n# Main Routine\n##############################################################################\n\necho \"Parameters to script => ${*}\"\n\n# Parse the command line arguments.\nlastOpt=\n\nfor arg in $*\ndo\n    optName=`echo $arg | awk -F'=' '{print $1;}'`\n    optValue=${arg:$((${#optName}+1))}\n\n    if [ \"${optName}\" == \"--spp_version\" ]; then\n\n        if [[ ! \"${optValue}\" =~ [^[:space:]] ]]\n        then\n            echo \"Missing argument to '--spp_version'\" 1>&2\n            exit 1\n        fi\n\n        sppVersion=${optValue}\n\n        lastOpt=\n    elif [ \"${arg:0:2}\" != \"--\" ] && [ \"${lastOpt}\" == \"--hpsum_options\" ]; then\n        hpSumOptions=\"${hpSumOptions} ${arg}\"\n    elif [ \"${optName}\" == \"--hpsum_options\" ]; then\n        if [[ ! \"${optValue}\" =~ [^[:space:]] ]]\n        then\n            echo \"Missing argument to '--hpsum_options'\" 1>&2\n            exit 1\n        fi\n\n        hpSumOptions=\"${optValue}\"\n\n        lastOpt=\"--hpsum_options\"\n    elif [ \"${optName}\" == \"--hpsum_logs_dump_dir\" ]\n    then\n        if [[ ! \"${optValue}\" =~ [^[:space:]] ]]\n        then\n            echo \"Missing argument to '--hpsum_logs_dump_dir'\" 1>&2\n            exit 1\n        fi\n\n        hpSumLogsDumpDir=\"${optValue}\"\n        lastOpt=\n    elif [ \"${optName}\" == \"--hpsum_copy_files_locally\" ]\n    then\n        if [ \"${optValue}\" == \"true\" ] || [ \"${optValue}\" == \"false\" ]\n        then\n            hpSumCopyFilesLocally=\"${optValue}\"\n        else\n            echo \"Invalid value '${optValue}' specified for script parameter '--hpsum_copy_files_locally'\" 1>&2\n            echo \"Valid values are 'true' or 'false'\" 1>&2\n            exit 1\n        fi\n    elif [ \"${optName}\" == \"--no_show_log\" ]\n    then\n        showHpSumLog=0\n    else\n        echo \"invalid option '${optName}'\" 1>&2\n        exit 1\n    fi\ndone\n\n# If we have user-specified HP SUM command line options, then check if the\n# log directory has been overridden with the \"/logdir\" or \"-logdir\" option.\n# We need to know where the log files will be placed so that we can zip them\n# up when the offline firmware update is complete.\nif [ ! -z \"${hpSumOptions}\" ]\nthen\n    checkForOverrideOfHpSumLogDir \"${hpSumOptions}\"\nfi\n\n# Locates the SPP version to be used.\nfindSPPVersion\n\nif [ $? -ne 0 ]\nthen\n    exit 1\nfi\n\nrunHPSUM\nretCode=$?\n\n# This section of code displays the \"Install Components\" section of \"hpsum_log.txt\"\n# to standard output, so that it is visible in the Insight Control Server Provisioning\n# job log.  Because the job log is limited to 10K, only a small portion of \n# \"hpsum_log.txt\" is being displayed.  The code below may be edited to show more of\n# \"hpsum_log.txt\", or for more detailed information, \"hpsum_detail_log.txt\" may be\n# used instead.  To use \"hpsum_detail_log.txt\", replace \"$(getHpSumLog)\" below with\n# \"$(getHpSumDetailLog)\".\nif [ ${showHpSumLog} -eq 1 ]\nthen\n    logFileToDisplay=$(getHpSumLog)\n\n    if [ -e ${logFileToDisplay} ]\n    then\n        installedComponents=\"Installed Components:\"\n        deployedComponents=\"Deployed Components:\"\n\n        # Log file for HP SUM version < 6.0.1 will show \"Installed Components:\"\n        # Log file for HP SUM version >= 6.0.1 will show \"Deployed Components:\"\n        if grep \"^${installedComponents}\" ${logFileToDisplay} > /dev/null 2>&1\n        then\n            searchText=${installedComponents}\n        elif grep \"^${deployedComponents}\" ${logFileToDisplay} > /dev/null 2>&1\n        then\n            searchText=${deployedComponents}\n        else\n            searchText=\n        fi\n\n        if [ ! -z \"${searchText}\" ]\n        then\n            echo -e \"The '${searchText}' section of '${logFileToDisplay}' is as follows:\\n\"\n\n            hpSumInstalledComponents=$(awk \"/^${searchText}/ { SHOW = 1 }; SHOW == 1 { print }\" ${logFileToDisplay})\n\n            if [ -z \"${hpSumInstalledComponents}\" ]\n            then\n                echo \"Could not find '^${searchText}' in ${logFileToDisplay}\" 1>&2\n            else\n                echo \"${hpSumInstalledComponents}\"\n            fi\n        else\n            echo \"Could not find '${installedComponents}' or '${deployedComponents}' in ${logFileToDisplay}\" 1>&2\n        fi\n    else\n        echo \"'${logFileToDisplay}' not found\" 1>&2\n    fi\nfi\n\necho \"Placing HP SUM log files into '${hpSumLogsZipFile}'\"\n\n# Zip up the HP SUM log files.\nzip -r ${hpSumLogsZipFile} $(getHpSumLogs) > /dev/null\n\nif [ $? -ne 0 ]\nthen\n    echo \"Failed to create HP SUM logs zip file '${hpSumLogsZipFile}'\" 1>&2\n    exit 1\nfi\n\n# If the \"--hpsum_logs_dump_dir\" parameter was specified, then zip up the\n# HP SUM log files and place them in the specified directory.\nif [[ ${hpSumLogsDumpDir} =~ [^[:space:]] ]]\nthen\n    # If the directory where the zipped HP SUM log files is to be placed does not\n    # exist, then create it.\n    if [ ! -d ${hpSumLogsDumpDir} ]\n    then\n        echo \"The directory '${hpSumLogsDumpDir}' does not exist on file share.  Creating it.\"\n        mkdir -p ${hpSumLogsDumpDir}\n\n        if [ $? -ne 0 ]\n        then\n            echo \"Failed to create directory '${hpSumLogsDumpDir}' on file share\" 1>&2\n            echo \"Verify that the directory is writable\" 1>&2\n        fi\n    fi\n\n    serverId=$(getServerId)\n\n    timeStamp=$(date +%Y%m%d-%H%M%S)\n\n    hpSumLogsZipFileWithServerId=hpsum_logs_${serverId}_${timeStamp}.zip\n\n    pathToZipFileOnFileShare=\"${hpSumLogsDumpDir}/${hpSumLogsZipFileWithServerId}\"\n\n    echo \"Copying '${hpSumLogsZipFile}' to '${pathToZipFileOnFileShare}'\"\n\n    cp ${hpSumLogsZipFile} ${pathToZipFileOnFileShare}\n\n    if [ $? -eq 0 ]\n    then\n        echo \"Successfuly copied '${hpSumLogsZipFile}' to '${pathToZipFileOnFileShare}'\"\n    else\n        echo \"Failed to copy '${hpSumLogsZipFile}' to '${pathToZipFileOnFileShare}'\" 1>&2\n    fi\nelse\n    echo \"Since the '--hpsum_logs_dump_dir' option was not specified, the zipped HP SUM log files were not copied to the file share\"\nfi \n\nexit $retCode\n", 
    "state": null, 
    "version": {
      "usage": "Updates the target server firmware using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  All the options must be enclosed within double quotes.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--hpsum_logs_dump_dir=writable_directory_under_mounted_file_share    Copies the zipped HP SUM log files to the specified directory.  The directory must start with the mount point specified in the \"Set Media Source\" Build Plan Step.  For example, if the file share where the zipped HP SUM log file is to be copied to is mounted on \"/mnt/media\" and the destination directory is \"hpsum_logs\", then specify \"--hpsum_logs_dump_dir=/mnt/media/hpsum_logs\".\n\n--no_show_log   Don't display the \"hpsum_log.txt\" contents in the job log.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None", 
      "current": true, 
      "versionLabel": "2", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:09:36.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-28T00:09:36.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Updates the target server firmware using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The\t name of the directory containing the SPP to be installed, such as \"2012.06\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  All the options must be enclosed within double quotes.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--hpsum_logs_dump_dir=writable_directory_under_mounted_file_share    Copies the zipped HP SUM log files to the specified directory.  The directory must start with the mount point specified in the \"Set Media Source\" Build Plan Step.  For example, if the file share where the zipped HP SUM log file is to be copied to is mounted on \"/mnt/media\" and the destination directory is \"hpsum_logs\", then specify \n\"--hpsum_logs_dump_dir=/mnt/media/hpsum_logs\".\n\n--no_show_log   Don't display the \"hpsum_log.txt\" contents in the job log.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the share under the directory passed to \"Set Media Source\" script.", 
        "current": false, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:42.000Z"
      }, 
      {
        "usage": "Updates the target server firmware using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  All the options must be enclosed within double quotes.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--hpsum_logs_dump_dir=writable_directory_under_mounted_file_share    Copies the zipped HP SUM log files to the specified directory.  The directory must start with the mount point specified in the \"Set Media Source\" Build Plan Step.  For example, if the file share where the zipped HP SUM log file is to be copied to is mounted on \"/mnt/media\" and the destination directory is \"hpsum_logs\", then specify \"--hpsum_logs_dump_dir=/mnt/media/hpsum_logs\".\n\n--no_show_log   Don't display the \"hpsum_log.txt\" contents in the job log.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None", 
        "current": true, 
        "versionLabel": "2", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:36.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-08-26T06:31:05.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:14:46.000Z", 
    "description": "Unmounts the drives containing the Intelligent Provisioning WinPE drivers for ProLiant Gen8 servers .This will ensure the Windows setup utility to use the drivers in the ProLiant Drivers zip package during the Windows installation\n\n\nParameters: None\n\nCustom Attributes: None\n", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1610001", 
    "modified": "2014-08-26T06:31:05.000Z", 
    "name": "Unmount Intelligent Provisioning WinPE Drive", 
    "source": "@echo off\n\n:: (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n:: Unmount the drives containing Intelligent Provisioning WinPE drivers \necho Checking for existence of Intelligent Provisioning WinPE driver Volume to unmount\nset flag=0\nfor %%d in (c d e f g h i j k l m n o p q r s t u v w y ) do (\nif exist %%d:\\$WinPEdriver$\\ (\n    echo Found drive %%d that contains Intelligent Provisioning WinPE drivers\n    set flag=1\n    mountvol %%d: /p\n    if NOT %errorlevel%==0 (\n        echo Failed to unmount the drive %%d that contains Intelligent Provisioning WinPE drivers\n\t\n    )else  (\n\techo Successfully unmounted the drive %%d that contains Intelligent Provisioning WinPE drivers\n\t\n    )\n  )\n)\n\n\nif %flag%==0 (\n    echo No drive found that contains Intelligent Provisioning WinPE drivers,skipping unmounting\n)", 
    "state": null, 
    "version": {
      "usage": "Unmounts the drives containing the Intelligent Provisioning WinPE drivers for ProLiant Gen8 servers .This will ensure the Windows setup utility to use the drivers in the ProLiant Drivers zip package during the Windows installation\n\n\nParameters: None\n\nCustom Attributes: None\n", 
      "current": true, 
      "versionLabel": "50", 
      "createdBy": "opsware", 
      "createdDate": "2014-08-26T06:31:05.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-08-26T06:31:05.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Unmounts the drives containing the Intelligent Provisioning WinPE drivers for ProLiant Gen8 servers .This will ensure the Windows setup utility to use the drivers in the ProLiant Drivers zip package during the Windows installation\n\n\nParameters: None\n\nCustom Attributes: None\n", 
        "current": false, 
        "versionLabel": "48", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:14:47.000Z"
      }, 
      {
        "usage": "Unmounts the drives containing the Intelligent Provisioning WinPE drivers for ProLiant Gen8 servers .This will ensure the Windows setup utility to use the drivers in the ProLiant Drivers zip package during the Windows installation\n\n\nParameters: None\n\nCustom Attributes: None\n", 
        "current": false, 
        "versionLabel": "49", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:15:52.000Z"
      }, 
      {
        "usage": "Unmounts the drives containing the Intelligent Provisioning WinPE drivers for ProLiant Gen8 servers .This will ensure the Windows setup utility to use the drivers in the ProLiant Drivers zip package during the Windows installation\n\n\nParameters: None\n\nCustom Attributes: None\n", 
        "current": true, 
        "versionLabel": "50", 
        "createdBy": "opsware", 
        "createdDate": "2014-08-26T06:31:05.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:11:19.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:09:06.000Z", 
    "description": "Installs the HP Service Pack for ProLiant on Linux production OS using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--fail_on_warning : When specified, the script will fail on receiving the error code 253. When absent, the script will be successful for the error code 253. \n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1490001", 
    "modified": "2014-03-28T00:11:19.000Z", 
    "name": "Install Linux SPP", 
    "source": "#!/bin/sh\n\n# (c) Copyright 2013, 2014 Hewlett-Packard Development Company, L.P.\n\n# Globals\n# Media Server mount point location\n# if /mnt/media not exist fall back to /mnt/ms mount point\nmountpoint=/mnt/media\nif [ ! -d \"$mountpoint\" ]\nthen\n\tmountpoint=/mnt/ms\nfi\n\nhpsumargs=\nsppversion=\n\n#Flag to be used in case --fail_on_warning is specified.\nfailonwarning=0\n#Flag to be used in case -logdir is specified.\nlogdir_specified=0\n#Variable to save the new logdir specified.\nnew_logdir=\"/var/hp/log\"\n\n# ====================\n# Determine SPP Version to install\n# Globals set:  sppversion\n# ====================\nFindSPPVersion ()\n{       \n   if [ \"$sppversion\" == \"\" ] || [ \"$sppversion\" == \"latest\" ]; then\n\n      sppversion=$(find \"$mountpoint/Media/spp\" -mindepth 1 -maxdepth 1 -type d -printf %f\\\\n | sort | tail -1)\n\n      if [ \"$sppversion\" == \"\" ]; then\n         echo \"Did not find an SPP Version on the media server\"\n         return 999\n      fi\n      if [ ! -d \"$mountpoint/Media/spp/$sppversion\" ]; then\n         echo \"$mountpoint/Media/spp/$sppversion is not a directory\"\n         return 999\n      fi\n   fi\n   return 0\n}\n\n# ====================\n# Run HPSUM\n# Globals used:  hpsumargs, sppversion\n# ====================\nRunHPSUM ()\n{\n   if [ ! -d \"$mountpoint/Media/spp/$sppversion\" ]; then\n      echo \"$mountpoint/Media/spp/$sppversion does not exist\"\n      return 999\n   fi\n\n   echo \"SPP version to be installed is $sppversion\"\n   echo \"Additional hpsum arguments are $hpsumargs\"\n   # Must be run as currently running directory\n   cd $mountpoint/Media/spp/$sppversion/hp/swpackages\n\n   ./hpsum --silent $hpsumargs\n   rc=$?\n    if [ $rc -gt 3 ] || [ $rc -lt 0 ]; then\n        echo \"SPP hpsum failed: error code $rc\"\n        if [[ $rc -lt 0 ]]; then\n            rc=$(( 256 + $rc ))\n        fi\n      \t  case \"$rc\" in\n\t      255)\n    \t\t  echo \"A general failure occurred. For details, see the error log.\";;\n\t      254)\n    \t\t  echo \"A bad input parameter was encountered.\";;\n              253)\n                  if [ $failonwarning -eq 1 ];then\n\t\t\techo \"ERROR - One or more components failed to install\"\n                        echo \"fail_on_warning is set\"\n       \t\t  else\n\t\t\techo \"WARNING - One or more of the smart components failed to install.\"\n\t\t\techo \"Depending on your system configuration, this may be expected behavior.\"\n\t\t\techo \"To verify the installation, check the hpsum logs located at $new_logdir unless specified otherwise by hpsum -logdir option.\"\n\t\t\techo \"To fail the build plan when these warnings occur, specify the --fail_on_warning option to this step.\"\n\t\t\treturn 0\n\t\t  fi\n\t\t\t;;\n\t  esac\n    \n    echo \"hpsum logs are located at $new_logdir unless specified otherwise by hpsum -logdir option.\"\n    return $rc\n    fi\n    if [ $rc -ge 0 ] || [ $rc -le 3 ]; then\n        case \"$rc\" in\n\t      0)\n    \t\t  echo \"SPP hpsum ran successfully: return code $rc\";;\n\t      1)\n    \t\t  echo \"The installation was successful,but a reboot is required: return code $rc\";;\n              3)\n    \t\t  echo \"The component was current or not required: return code $rc\";;\n\tesac\n    \n    echo \"hpsum logs are located at $new_logdir unless specified otherwise by hpsum -logdir option.\"\n    return 0\n    fi\n}\n\n# ====================\n# Unmount media server\n# Globals used:  mountpoint\n# ====================\nUnmountMediaServer()\n{\n   # Unmount media server drive\n   cd /\n   umount \"$mountpoint\"\n   return 0\n}\n\n# ====================\n# MAIN\n# ====================\n\n# Determine what calling arguments\n# Globals set:  hpsumargs, sppversion\n\nopt=0\nfor i in $*\ndo\n    # Get string to left of =\n    leftstr=${i%=*}\n    # Get string to right of =\n    rightstr=${i##*=}\n    case \"$leftstr\" in\n        \"--spp_version\")\n            sppversion=$rightstr;;\n    \"--hpsum_options\")\n        hpsumargs=$rightstr;;\n    \"--fail_on_warning\")\n       failonwarning=1;;\n    *)\n        if [ $i == \"-logdir\" ];then\n            logdir_specified=1\n            hpsumargs=\"$hpsumargs $i\"\n        elif [ $logdir_specified -eq 1 ]; then\n            hpsumargs=\"$hpsumargs \\\"$i\\\"\"\n            new_logdir=\"\\\"$i\\\"\"\n            logdir_specified=0\n        else\n            hpsumargs=\"$hpsumargs $i\"\n        fi\n        ;;\n    esac\ndone\n\n\nFindSPPVersion\nreturncode=$?\n\nif [ $returncode -eq 0 ]; then\n    RunHPSUM\n    returncode=$?\nfi\nUnmountMediaServer\n\nexit $returncode\n", 
    "state": null, 
    "version": {
      "usage": "Installs the HP Service Pack for ProLiant on Linux production OS using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--fail_on_warning : When specified, the script will fail on receiving the error code 253. When absent, the script will be successful for the error code 253. \n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None", 
      "current": true, 
      "versionLabel": "77", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:11:19.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "SH", 
    "currentVersionChangedDate": "2014-03-28T00:11:19.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Unix", 
    "allVersions": [
      {
        "usage": "Installs the HP Service Pack for ProLiant on Linux production OS using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--fail_on_warning : When specified, the script will fail on receiving the error code 253. When absent, the script will be successful for the error code 253. \n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None", 
        "current": false, 
        "versionLabel": "76", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:06.000Z"
      }, 
      {
        "usage": "Installs the HP Service Pack for ProLiant on Linux production OS using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--fail_on_warning : When specified, the script will fail on receiving the error code 253. When absent, the script will be successful for the error code 253. \n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None", 
        "current": true, 
        "versionLabel": "77", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:19.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:10:07.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:10:07.000Z", 
    "description": "Deletes any custom boot options that were created in the UEFI boot menu by OSs that have been previously installed or manually by the user.  Boot options that were created by the ROM for devices that were discovered on the system are not deleted.  This script can only be run on a Linux OS that has the efibootmgr utility.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1550001", 
    "modified": "2014-03-28T00:10:07.000Z", 
    "name": "Delete UEFI Custom Boot Options", 
    "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(c) Copyright 2014 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport re\nimport subprocess\nimport os.path\nfrom sys import platform as _platform\nfrom subprocess import Popen, PIPE, STDOUT\nfrom osprov import ilo\nfrom osprov.osbp import logger\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.server import ThisLocalServer\n\nDEBUG=@Debug:0@\n\nlog = logger.getIt(\"Delete UEFI Custom Boot Options\")\n\n# Writes an debug message to stdout and the logger.\ndef writeDebugMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    if (DEBUG):\n        print msg\n\n    # Write the message to the logger so that it shows up in the log files.\n    log.debug(msg);\n\n# Writes an info message to stdout and the logger.\ndef writeInfoMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    print msg\n\n    # Write the message to the logger so that it shows up in the log files.\n    log.info(msg);\n\n# Writes an error message to stderr and the logger.\ndef writeErrorMessage(msg):\n\n    # Write the message to stderr so that it shows up in the job output.\n    sys.stderr.write(msg)\n\n    # Write the message to the logger so that it shows up in the log files.\n    log.error(msg);\n\n# Converts the specified list to a string that is delimited by the specified\n# delimiter character (default = ' ').\ndef listToString(list, delimeter=' '):\n\n    str = delimeter.join(list)\n\n    return str\n\n# Executes the specified command, which must be a list contaning the \n# executable name and its arguments.\ndef executeCommand(cmdArgs):\n\n    cmdAsString = listToString(cmdArgs)\n\n    writeDebugMessage(\"Executing => %s\" % cmdAsString)\n\n    p = subprocess.Popen(cmdArgs, stdout=subprocess.PIPE, stderr=STDOUT)\n\n    output = p.communicate()[0].strip()\n\n    retCode = p.poll()\n\n    p.stdout.close()\n\n    return retCode, output\n\n# Adds a boot option for ESXi to the top of the UEFI Boot Order.\ndef getBootOptions():\n\n    cmdArgs = [\"efibootmgr\", \"-v\"]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        writeErrorMessage(\"Failed to get the list of boot options\")\n        raise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n    return output.splitlines()\n\n# Returns the list of custom boot options.\ndef getCustomBootOptions():\n\n    # Initialize custom boot options list.\n    customBootOptions = []\n\n    bootOptions = getBootOptions();\n\n    if (len(bootOptions) > 0):\n        customBootOptionPattern = re.compile(r\"^Boot[0-9A-Za-z]{4}.*File\\(.+\\).*$\")\n\n        for bootOption in bootOptions:\n            result = customBootOptionPattern.search(bootOption)\n\n            if result:\n                writeDebugMessage(\"customBootOption = %s\" % bootOption)\n                customBootOptions.append(bootOption)\n    else:\n        writeErrorMessage(\"No boot options found\")\n        raise ShowErrorMessage(\"No boot options found\");\n\n    return customBootOptions\n\n# Deletes the boot option that corresponds to the specified boot option ID.\ndef deleteBootOption(bootOptionID):\n\n    cmdArgs = [\"efibootmgr\", \"--inactive\", \"--bootnum\", bootOptionID]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode == 0):\n        writeDebugMessage(\"Successfully inactivated boot option ID '%s'\" % bootOptionID)\n    else:\n        writeErrorMessage(\"Failed to inactivate boot option ID '%s'\" % bootOptionID)\n        raise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n    cmdArgs = [\"efibootmgr\", \"--delete-bootnum\", \"--bootnum\", bootOptionID]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode == 0):\n        writeDebugMessage(\"Successfully deleted boot option ID '%s'\" % bootOptionID)\n    else:\n        writeErrorMessage(\"Failed to deleted boot option ID '%s'\" % bootOptionID)\n        raise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n# Deletes the custom boot options.\ndef deleteCustomBootOptions():\n\n    # Get the list of custom boot options.\n    customBootOptions = getCustomBootOptions();\n\n    if (len(customBootOptions) == 0):\n        writeInfoMessage(\"No custom boot options found\")\n        return 0\n\n    # Extract the \"####\" ID from \"Boot####\".\n    bootOptionIdPattern = re.compile(r\"^[Bb][Oo][Oo][Tt]([0-9A-Za-z]{4}).*\")\n\n    # Delete all the custom boot options using their \"####\" ID.\n    for customBootOption in customBootOptions:\n        result = bootOptionIdPattern.search(customBootOption)\n\n        if result:\n            writeInfoMessage(\"Deleting custom boot option => %s\" % customBootOption)\n\n            bootOptionID = result.group(1)\n\n            deleteBootOption(bootOptionID)\n\n# Returns \"True\" if the server is in UEFI mode; \"False\" otherwise.\ndef isServerInUefiMode():\n\n    targetServer = ThisLocalServer()\n\n    iloServer = ilo.getIlo(targetServer, log=log)\n\n    currentBootMode = iloServer.getCurrentBootMode()\n\n    uefiPattern = re.compile(r\".*UEFI.*\")\n\n    result = uefiPattern.search(currentBootMode)\n\n    if result:\n        uefiMode = True\n    else:\n        uefiMode = False\n\n    return uefiMode\n\n# Returns \"True\" if the OS is supported; \"False\" otherwise.  Currently this script can\n# only be run on Linux OSs which provide the \"efibootmgr\" utility.\ndef checkIfOsIsSupported():\n\n    if (DEBUG):\n        print \"_platform = %s\" % _platform\n\n    if _platform == \"linux\" or _platform == \"linux2\" or _platform == \"linux-x86_64\":\n        return True\n    else:\n        return False\n\n# Main Routine\ndef main():\n\n    if (checkIfOsIsSupported()):\n        if (isServerInUefiMode()):\n            writeDebugMessage(\"Boot Mode is UEFI\")\n            deleteCustomBootOptions()\n        else:\n            print \"Boot Mode is not UEFI.  Skipping this step.\"\n    else:\n        writeErrorMessage(\"This script can only be run on Linux\\n\")\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Deletes any custom boot options that were created in the UEFI boot menu by OSs that have been previously installed or manually by the user.  Boot options that were created by the ROM for devices that were discovered on the system are not deleted.  This script can only be run on a Linux OS that has the efibootmgr utility.", 
      "current": true, 
      "versionLabel": "14", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:10:07.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-28T00:10:07.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Deletes any custom boot options that were created in the UEFI boot menu by OSs that have been previously installed or manually by the user.  Boot options that were created by the ROM for devices that were discovered on the system are not deleted.  This script can only be run on a Linux OS that has the efibootmgr utility.", 
        "current": true, 
        "versionLabel": "14", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:10:07.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:18:49.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:18:48.000Z", 
    "description": "Configure NIC Teaming for Windows 2012 or later.\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nRequirements:\n* Minimum  2 members required for NIC Teaming.\n* Member should not be part of any other Team.\n\nRequired Parameters:\n* Field Name \u2013 lists the NIC characteristic that will be specified in the other parameters.  \n   Valid field names are:\n  \u2022 Name\n  \u2022 InterfaceDescription\n  \u2022 ifIndex\n  \u2022 Status\n  \u2022 MacAddress\n  \u2022 LinkSpeed\n\n* Values - The value(s) to be checked for that corresponds to the specified Field Name parameter.  \n* Note that no extra spaces should be used when specifying parameters.\n\nSample parameters values:\nStatus,Up         \t :  Teams all NICs that are active\nName,Ethernet,Ethernet 3 :  Teams the first and third NIC\n\nCustom Attributes:  None", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1700001", 
    "modified": "2014-03-28T00:18:49.000Z", 
    "name": "Configure NIC Teaming for Windows", 
    "source": "set  SEARCHFIELD=%1\nset  SEARCHPATTERN=%*\n\n;@Findstr -bv ;@F \"%~f0\" |powershell.exe -ExecutionPolicy Unrestricted -NoLogo -NonInteractive -NoProfile -Command  - & goto:eof\n\n## -------------------------------------------------------------------------------\n## Create-NICTeam\n## -------------------------------------------------------------------------------\n\nFunction Create-NicTeam ([string[]] $Members, [string]$TeamName)\n{\n$ListofTeams = Get-NetLbfoTeam\nif ($ListofTeams)\n{\nforeach ( $Team in $ListofTeams)\n{\nif ($Team.Name -eq $TeamName)\n{\nwrite-host \"Team $TeamName already exists - No action needed\"\nreturn\n}\n}\n}\nif ( $ListofNetworkNames.Count -gt 1)\n{\nwrite-host \" Creating new team $TeamName\"\n\nNew-NetLBfoTeam -AsJob -Name $TeamName -TeamMembers $Members -TeamingMode SwitchIndependent -LoadBalancingAlgorithm TransportPorts -confirm:$false\nreturn\n}\nelse\n{\nwrite-host \" There is less than 2 members in the Team list for $TeamName. Cannot create team\"\n}\n}\n## -------------------------------------------------------------------------------\n## Main Entry\n## -------------------------------------------------------------------------------\n\n$field=$env:SEARCHFIELD\nif ( $field -gt 0){write-host \"Parameter value found.\"}else{write-host \"Parameter value Not found. Exiting\"}\n \n$value=$env:SEARCHPATTERN\nif ( $value -gt 0){$valueSplit = $value.split(\",\")}else{write-host \"Parameter value Not found. Exiting\"}\n\nif ( $valueSplit.count -gt 1){$NetArray=$valueSplit[1..($valueSplit.count-1)]}else{write-host \" Network Adapter input Not found. Exiting\"}\n\n\nwrite-host \"Field used: $field\"\nwrite-host \"Network Adapter used: $NetArray\"\n\n$TeamMembers = @()\n$TeamName = \"Team-by-\"+\"$field\"\n$value=\"*\"+\"$value\"+\"*\"\n$NetAdapters = @()\n$ListofNetworkNames = @()\n\n\n$(ForEach($Element in $NetArray) {Get-NetAdapter | where $field -like $Element}) | set-variable NetAdapters\necho $NetAdapters\n\nif ( $NetAdapters.Count -gt 0){write-host \" Network Adapter found.\"}else{write-host \" Network Adapter Not found. Exiting\"}\nForeach ($Net in $NetAdapters){$ListofNetworkNames += $Net.Name}\nif ($ListofNetworkNames.Count -gt 0){Create-NicTeam -Members $ListofNetworkNames -TeamName $TeamName}\n", 
    "state": null, 
    "version": {
      "usage": "Configure NIC Teaming for Windows 2012 or later.\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nRequirements:\n* Minimum  2 members required for NIC Teaming.\n* Member should not be part of any other Team.\n\nRequired Parameters:\n* Field Name \u2013 lists the NIC characteristic that will be specified in the other parameters.  \n   Valid field names are:\n  \u2022 Name\n  \u2022 InterfaceDescription\n  \u2022 ifIndex\n  \u2022 Status\n  \u2022 MacAddress\n  \u2022 LinkSpeed\n\n* Values - The value(s) to be checked for that corresponds to the specified Field Name parameter.  \n* Note that no extra spaces should be used when specifying parameters.\n\nSample parameters values:\nStatus,Up         \t :  Teams all NICs that are active\nName,Ethernet,Ethernet 3 :  Teams the first and third NIC\n\nCustom Attributes:  None", 
      "current": true, 
      "versionLabel": "24", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:18:49.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-28T00:18:49.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "Configure NIC Teaming for Windows 2012 or later.\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nRequirements:\n* Minimum  2 members required for NIC Teaming.\n* Member should not be part of any other Team.\n\nRequired Parameters:\n* Field Name \u2013 lists the NIC characteristic that will be specified in the other parameters.  \n   Valid field names are:\n  \u2022 Name\n  \u2022 InterfaceDescription\n  \u2022 ifIndex\n  \u2022 Status\n  \u2022 MacAddress\n  \u2022 LinkSpeed\n\n* Values - The value(s) to be checked for that corresponds to the specified Field Name parameter.  \n* Note that no extra spaces should be used when specifying parameters.\n\nSample parameters values:\nStatus,Up         \t :  Teams all NICs that are active\nName,Ethernet,Ethernet 3 :  Teams the first and third NIC\n\nCustom Attributes:  None", 
        "current": true, 
        "versionLabel": "24", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:18:49.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:10:31.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:10:31.000Z", 
    "description": "Configures the boot device by applying the configuration specified in the HBA_Config multi-line custom attribute to the Emulex CNA, Emulex HBA or Qlogic HBA.\n\nOptional Parameters:\n\n--displayHbaOnly - Show the HBAs on the target server, but don't apply the configuration.\n", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1590001", 
    "modified": "2014-03-28T00:10:31.000Z", 
    "name": "Configure Fibre Channel HBA Boot Device", 
    "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n############################################################################################\n# Configures the boot device by applying the configuration specified in the HBA_Config \n# multi-line custom attribute to the QLogic or Emulex HBA.\n#\n# The HBA_Config custom attribute should contain the following tag/value pairs; one per line.\n#\n# BootWWPN-HBA0 - Target Controller's WWPN. This is required.\n# BootLUN-HBA0 - The LUN.  This is required.\n# WWPN-HBA0 - The HBA's WWPN.  This is optional.  If not specified, the configuration will\n#             be applied to first HBA.\n# SelectBootEnable-HBA0 - Set to \"1\" to enable selectable boot on QLogic or disable AutoScan\n#                         on Emulex. Set to \"0\" to disable selectable boot on QLogic and\n#                         enable AutoScan on Emulex. This is optional.  The default value\n#                         is \"1\".\n# HostAdapterBiosEnable-HBA0 - Set to \"1\" to enable the host adapter BIOS or \"0\" to disable.\n#                              This is optional. The default value is \"1\".\n#\n# To configure a second HBA, use \"-HBA1\" in the tag names.\n#\n# Optional Parameters:\n#\n# --displayHbaOnly - Show the HBAs on the target server, but don't apply the configuration.\n#\n############################################################################################\n\nimport sys\nimport re\nimport subprocess\nimport os.path\nfrom subprocess import Popen, PIPE, STDOUT\nfrom optparse import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.errors import ShowErrorMessage\n\n# The QLogic and Emulex utilities.\nQLOGIC_CMD = \"/opt/hba/qlogic/sbin/QConvergeConsoleCLI/qaucli\"\nEMULEX_CMD = \"/opt/hba/emulex/sbin/ocmanager/hbacmd\"\n\nHBA_CONFIG_CA_NAME = \"HBA_Config\"\nHBA_CONFIG_CA_VALUE = \"\"\"@HBA_Config@\"\"\"\n\n# These are the tags that appear in the \"HBA_Config\" custom attribute.\nBOOT_WWPN_HBA_TAG = \"BootWWPN-HBA\"\nBOOT_WWNN_HBA_TAG = \"BootWWNN-HBA\"\nBOOT_LUN_HBA_TAG = \"BootLUN-HBA\"\nWWPN_HBA_TAG = \"WWPN-HBA\"\nSELECT_BOOT_ENABLE_TAG = \"SelectBootEnable-HBA\"\nHOST_ADAPTER_BIOS_ENABLE_TAG = \"HostAdapterBiosEnable-HBA\"\n\nQLOGIC_DEFAULT_SELECTABLE_BOOT_ENABLE = \"1\"\nEMULEX_DEFAULT_AUTOSCAN_ENABLE = \"0\"\nDEFAULT_HOST_ADAPTER_BIOS_ENABLE = \"1\"\n\nEMULEX = 0\nQLOGIC = 1\n\nDEBUG=@Debug:0@\n\nLOG = logger.getIt('manage_hba_qlogic_configuration')\n\n############################################################################################\n# Class to parse command line arguments.\n############################################################################################\n\ndef parseArgs(args):\n\t\"\"\" parse and normalise arguments for the script \"\"\"\n\tparser = OptionParser()\n\tparser.add_option(\"--displayHbaOnly\",\n\t\t\taction = \"store_true\",\n\t\t\tdest = \"displayHbaOnly\",\n\t\t\thelp = \"Only display the HBAs, but don't apply configuration.\")\n\toptions, args = parser.parse_args(args)\n\tif args:\n\t\tparser.error(\"Additional positional arguments are not supported\")\n\treturn options, args\n\n############################################################################################\n# Class to hold some basic information about the target SAN controller that the HBA is\n# connected to.\n############################################################################################\n\nclass TargetSanInfo:\n\n\tdef __init__(self):\n\t\tself.targetWWNN = None\n\t\tself.targetWWPN = None\n\t\tself.linkStatus = None\n\t\tself.numLuns = None\n\n\tdef setTargetWWNN(self, targetWWNN):\n\t\tself.targetWWNN = targetWWNN.upper().replace(\"-\", \":\")\n\n\tdef setTargetWWPN(self, targetWWPN):\n\t\tself.targetWWPN = targetWWPN.upper().replace(\"-\", \":\")\n\n\tdef setNumLuns(self, numLuns):\n\t\tself.numLuns = numLuns\n\n\tdef getTargetWWNN(self):\n\t\treturn self.targetWWNN\n\n\tdef getTargetWWPN(self):\n\t\treturn self.targetWWPN\n\n\tdef getNumLuns(self):\n\t\treturn self.numLuns\n\n###########################################################################\n# A class to hold some basic information about the boot device that the\n# HBA is configured to boot from.\n###########################################################################\n\nclass BootDevice:\n\n\tdef __init__(self, targetWWPN, lun):\n\t\tself.targetWWPN = targetWWPN.upper().replace(\"-\",\":\")\n\t\tself.lun = lun\n\n\tdef setTargetWWPN(self, targetWWPN):\n\t\tself.targetWWPN = targetWWPN.upper().replace(\"-\",\":\")\n\n\tdef setLun(self, lun):\n\t\tself.lun = lun\n\n\tdef getTargetWWPN(self):\n\t\treturn self.targetWWPN\n\n\tdef getLun(self):\n\t\treturn self.lun\n\n###########################################################################\n# A class to hold some basic QLogic HBA information.\n#\n# Set setter methods for the WWPN will convert the WWPN to uppercase and\n# change the delimiter to a \":\".  QLogic WWPNs use a \"-\" delimeter and\n# the Emulex WWPNs use a \":\" delimeter.  So, for comparison purposes we\n# will use upper case characters and a \":\" delimeter, but when running\n# a QLogic command that requires the WWPN, we will change the delimeter\n# back to \"-\", as the QLogic utility does not accept a \":\".\n###########################################################################\n\nclass HBAInfo:\n\n\tdef __init__(self):\n\t\tself.model = None\n\t\tself.portNum = None\n\t\tself.hbaInstance = None\n\t\tself.hbaWWPN = None\n\t\tself.linkStatus = None\n\t\tself.targetSanInfoList = None\n\t\tself.selectableBootEnable = None\n\t\tself.hostAdapterEnableBios = None\n\t\tself.primaryBootDevice = None\n\n\tdef setModel(self, model):\n\t\tself.model = model\n\n\tdef setInstance(self, hbaInstance):\n\t\tself.hbaInstance = hbaInstance\n\n\tdef setPortNum(self, portNum):\n\t\tself.portNum = portNum\n\n\tdef setHbaWWPN(self, hbaWWPN):\n\t\tself.hbaWWPN = hbaWWPN.upper().upper().replace(\"-\",\":\")\n\n\tdef setLinkStatus(self, linkStatus):\n\t\tself.linkStatus = linkStatus\n\n\tdef addTargetSanInfo(self, targetSanInfo):\n\t\tif (self.targetSanInfoList is None):\n\t\t\tself.targetSanInfoList = []\n\n\t\tself.targetSanInfoList.append(targetSanInfo)\n\n\tdef setTargetSanInfoList(self, targetSanInfoList):\n\t\tself.targetSanInfoList = targetSanInfoList\n\n\tdef setSelectableBootEnable(self, selectableBootEnable):\n\t\tself.selectableBootEnable = selectableBootEnable\n\n\tdef setHostAdapterEnableBios(self, hostAdapterEnableBios):\n\t\tself.hostAdapterEnableBios = hostAdapterEnableBios\n\n\tdef setPrimaryBootDevice(self, primaryBootDevice):\n\t\tself.primaryBootDevice = primaryBootDevice\n\n\tdef getModel(self):\n\t\treturn self.model\n\n\tdef getHbaInstance(self):\n\t\treturn self.hbaInstance\n\n\tdef getPortNum(self):\n\t\treturn self.portNum\n\n\tdef getHbaWWPN(self):\n\t\treturn self.hbaWWPN\n\n\tdef getLinkStatus(self):\n\t\treturn self.linkStatus\n\n\tdef getTargetSanInfoList(self):\n\t\treturn self.targetSanInfoList\n\n\tdef getSelectableBootEnable(self):\n\t\treturn self.selectableBootEnable\n\n\tdef getHostAdapterEnableBios(self):\n\t\treturn self.hostAdapterEnableBios\n\n\tdef getPrimaryBootDevice(self):\n\t\treturn self.primaryBootDevice\n\n###########################################################################\n# A class to hold the user-specified settings that are to be applied to\n# the HBA.\n###########################################################################\n\nclass UserHBA:\n\n\tdef __init__(self):\n\t\tself.tagNum = None\n\t\tself.hbaWWPN = None\n\t\tself.targetWWPN = None\n\t\tself.targetWWNN = None\n\t\tself.lun = None\n\t\tself.selectableBootEnable = None\n\t\tself.hostAdapterBiosEnable = None\n\n\tdef setTagNum(self, tagNum):\n\t\tself.tagNum = tagNum\n\n\tdef setHbaWWPN(self, hbaWWPN):\n\t\tself.hbaWWPN = hbaWWPN.upper().replace(\"-\",\":\")\n\n\tdef setTargetWWPN(self, targetWWPN):\n\t\tself.targetWWPN = targetWWPN.upper().replace(\"-\",\":\")\n\n\tdef setTargetWWNN(self, targetWWNN):\n\t\tself.targetWWNN = targetWWNN.upper().replace(\"-\",\":\")\n\n\tdef setLun(self, lun):\n\t\tself.lun = lun\n\n\tdef setSelectableBootEnable(self, selectableBootEnable):\n\t\tself.selectableBootEnable = selectableBootEnable\n\n\tdef setHostAdapterEnableBios(self, hostAdapterBiosEnable):\n\t\tself.hostAdapterBiosEnable = hostAdapterBiosEnable\n\n\tdef getTagNum(self):\n\t\treturn self.tagNum\n\n\tdef getHbaWWPN(self):\n\t\treturn self.hbaWWPN\n\n\tdef getTargetWWPN(self):\n\t\treturn self.targetWWPN\n\n\tdef getTargetWWNN(self):\n\t\treturn self.targetWWNN\n\n\tdef getLun(self):\n\t\treturn self.lun\n\n\tdef getSelectableBootEnable(self):\n\t\treturn self.selectableBootEnable\n\n\tdef getHostAdapterEnableBios(self):\n\t\treturn self.hostAdapterBiosEnable\n\n###########################################################################\n# Returns a string representation of the list.\n#\n# Parameters:\n#    list - The list to be converted to a string.\n#    delimeter - The character to use as the delimeter (default = ' ').\n###########################################################################\n\ndef listToString(list, delimeter=' '):\n\n\tstr = delimeter.join(list)\n\n\treturn str\n\n###########################################################################\n# Executes the specified command.\n#\n# Parameters:\n#    cmdArgs - The command to be executed, specified as a list.\n#\n###########################################################################\n\ndef executeCommand(cmdArgs):\n\n\tcmdAsString = listToString(cmdArgs)\n\n\tif (DEBUG):\n\t\tprint \"Executing => \", cmdAsString\n\n\tp = subprocess.Popen(cmdArgs, stdout=subprocess.PIPE, stderr=STDOUT)\n\n\toutput = p.communicate()[0].strip()\n\n\tretCode = p.poll()\n\n\tp.stdout.close()\n\n\treturn retCode, output\n\n###########################################################################\n# Returns the string \"as-is\", if it's value is not \"None\", otherwise\n# it returns an empty string so that when it gets displayed, we don't\n# see \"None\" in the output.  The keyword \"None\" means that the variable\n# has no value (e.g. null) in Python.\n###########################################################################\n\ndef toDisplayValue(str):\n\n\tdisplayStr = \"\"\n\n\tif (str is not None):\n\t\tdisplayStr = str\n\n\treturn displayStr\n\n###########################################################################\n# Displays the HBAs found on the system.\n###########################################################################\n\ndef showHBAs(hbaList):\n\n\tfmtStrHdr  = \"%-4s %-4s %-23s %-12s %-7s %-10s %-23s %-3s\"\n\tfmtStrBody = \"%4s %4s %-23s %-12s %7s %10s %-23s %3s\"\n\n\tprint fmtStrHdr % (\"\", \"\", \"\", \"Link\", \"Enable\", \"Selectable\", \"Primary Boot\", \"\")\n\tprint fmtStrHdr % (\"HBA#\", \"Port\", \"HBA WWPN\", \"Status\", \"BIOS\", \"Boot\", \"Port Name\", \"LUN\")\n\tprint fmtStrHdr % (\"----\", \"----\", \"-----------------------\", \"------------\", \"-------\", \"----------\", \"-----------------------\", \"---\")\n\n\tif (hbaList is None):\n\t\treturn\n\n\thbaNum = 0\n\n\tfor hba in hbaList:\n\n\t\tportNum = toDisplayValue(hba.getPortNum())\n\n\t\thbaWWPN = toDisplayValue(hba.getHbaWWPN())\n\n\t\tlinkStatus = toDisplayValue(hba.getLinkStatus())\n\n\t\tenableBios = toDisplayValue(hba.getHostAdapterEnableBios())\n\n\t\tselectableBoot = toDisplayValue(hba.getSelectableBootEnable())\n\n\t\tif (hba.getPrimaryBootDevice() is not None):\n\t\t\tprimaryBootDevice = hba.getPrimaryBootDevice()\n\n\t\t\tprimaryBootPortName = toDisplayValue(primaryBootDevice.getTargetWWPN())\n\n\t\t\tlun = toDisplayValue(primaryBootDevice.getLun())\n\t\telse:\n\t\t\tprimaryBootPortName = \"\"\n\t\t\tlun = \"\"\n\n\t\tprint fmtStrBody % (hbaNum, portNum, hbaWWPN, linkStatus, enableBios, selectableBoot, primaryBootPortName, lun)\n\n\t\thbaNum += 1\n\n##################################################################################\n#\n# BEGIN QLOGIC-SPECIFIC CODE\n#\n##################################################################################\n\n##################################################################################\n# Enables/Disables the BIOS on the QLogic HBA.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which to enable/disable the BIOS.\n#    enable - Set to \"1\" to enable or \"0\" to disable.\n##################################################################################\n\ndef qlogicSetEnableBios(hbaWWPN, enable):\n\n\t# Since the \"HostAdapterBiosEnable-HBA\" tag is optional, we'll default\n\t# it to enabled if the user didn't specify it in the \"HBA_Config\" C.A.\n\tif (enable is None):\n\t\tenable = DEFAULT_HOST_ADAPTER_BIOS_ENABLE\n\n\tif (DEBUG):\n\t\tif (enable):\n\t\t\tprint \"Enabling BIOS on QLogic HBA ...\"\n\t\telse:\n\t\t\tprint \"Disabling BIOS on QLogic HBA ...\"\n\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-n\", hbaWWPN.replace(\":\",\"-\"), \"EB\", enable]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Returns the value of the Enables Host HBA BIOS setting on the QLogic HBA.\n##################################################################################\n\ndef qlogicGetEnableBios(hbaWWPN):\n\n\tcmdArgs = [QLOGIC_CMD, \"-c\", hbaWWPN.replace(\":\",\"-\")]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\tenableBiosPattern = re.compile(r\"^Enable Host HBA BIOS\\s*:\\s+([\\S]+)\\s*$\")\n\n\tenableBios = None\n\n\tfor line in output.splitlines():\n\t\tresult = enableBiosPattern.search(line)\n\n\t\tif result:\n\t\t\tenableBios = result.group(1)\n\n\t\t\tif (enableBios.lower() == \"enabled\"):\n\t\t\t\tenableBios = \"1\"\n\t\t\telse:\n\t\t\t\tenableBios = \"0\"\n\n\t\t\tbreak\n\n\treturn enableBios\n\n##################################################################################\n# Enables/Disables the Selectable Boot on the QLogic HBA.\n#\n# +--------------------------------------------------------------------------+\n# | Enable |    WWPN/LUN    | Device Boot                                    |\n# |--------------------------------------------------------------------------|\n# |   No   |        X       | BIOS configures the first disk drive it finds  |\n# |        |                | as boot device.                                |\n# |--------------------------------------------------------------------------|\n# |   Yes  | None specified | BIOS configures the first disk drive it finds  |\n# |        |                | that is also a LUN 0 as boot device.           |\n# |--------------------------------------------------------------------------|\n# |   Yes  |    Specified   | BIOS scans through the specified Boot WWPN/LUN |\n# |        |                | list until it finds a disk drive.  This is     |\n# |        |                | configured as boot device.                     |\n# +--------------------------------------------------------------------------+\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which to set the selectable boot.\n#    enable - Set to \"1\" to enable or \"0\" to disable.\n##################################################################################\n\ndef qlogicSetSelectableBootEnable(hbaWWPN, enable):\n\n\t# Since the \"SelectBootEnable-HBA\" tag is optional, we'll default\n\t# it to enabled if the user didn't specify it in the \"HBA_Config\" C.A.\n\tif (enable is None):\n\t\tenable = QLOGIC_DEFAULT_SELECTABLE_BOOT_ENABLE\n\n\tif (enable == \"0\"):\n\t\tif (DEBUG):\n\t\t\tprint \"Disabling Selectable Boot on QLogic HBA ...\"\n\t\tenableArg = \"disable\"\n\telse:\n\t\tif (DEBUG):\n\t\t\tprint \"Enabling Selectable Boot on QLogic HBA ...\"\n\t\tenableArg = \"enable\"\n\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-e\", hbaWWPN.replace(\":\",\"-\"), enableArg]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Sets the primary boot device (Target WWPN/LUN) on the QLogic HBA.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which the primary boot device is to be set.\n#    targetWWNN - The target's World Wide Node Name (The ID of the SAN).\n#    targetWWPN - The target's World Wide Port Name (The ID of the Controller)\n#                 that is to be set as the primary boot device.\n#    lunId - The LUN ID on the Target WWPN that is to be set as the primary boot\n#            device.\n##################################################################################\n\ndef qlogicSetPrimaryBootDevice(hbaWWPN, targetWWNN, targetWWPN, lunId):\n\n\t# The QLogic utility requires the target WWNN parameter for some reason.\n\t# If the user didn't specify it in the \"BootWWNN-HBA\" tag, then default\n\t# it to all zeroes and hope it works.\n\tif (targetWWNN is None):\n\t\ttargetWWNN = \"00-00-00-00-00-00-00-00\"\n\n\t\tif (DEBUG):\n\t\t\tprint \"No targetWWNN was specified for targetWWPN '%s'.  Defaulting to '%s'.\" % (targetWWPN,targetWWNN) \n\n\t# Set first boot device (primary) to the specified target WWPN and LUN.\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-e\", hbaWWPN.replace(\":\",\"-\"), targetWWNN.replace(\":\",\"-\"), targetWWPN.replace(\":\",\"-\"), lunId, \"prim\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Returns the primary boot device (Target WWPN/LUN) for the QLogic HBA with the\n# specified WWPN.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA that we want the primary boot device for.\n##################################################################################\n\ndef qlogicGetPrimaryBootDevice(hbaWWPN):\n\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-e\", hbaWWPN.replace(\":\",\"-\"), \"view\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\tselectableBootPattern = re.compile(r\"^Selectable Boot\\s*:\\s+([\\S]+)\\s*$\")\n\tbootDevicePattern = re.compile(r\"^([\\S]{2}-[\\S]{2}-[\\S]{2}-[\\S]{2}-[\\S]{2}-[\\S]{2}-[\\S]{2}-[\\S]{2})\\s+([\\d]+)\\s*$\")\n\n\tselectableBoot = None\n\ttargetWWPN = None\n\tlun = None\n\n\tfor line in output.splitlines():\n\t\tresult = selectableBootPattern.search(line)\n\n\t\tif result:\n\t\t\tselectableBoot = result.group(1)\n\n\t\t\tif (selectableBoot.lower() == \"enabled\"):\n\t\t\t\tselectableBoot = \"1\"\n\t\t\telse:\n\t\t\t\tselectableBoot = \"0\"\n\n\t\t# The first boot device we find is the primary one,\n\t\t# so if there's a match, then break out of the loop.\n\t\tresult = bootDevicePattern.search(line)\n\n\t\tif result:\n\t\t\ttargetWWPN = result.group(1)\n\t\t\tlun = result.group(2)\n\t\t\tbreak\n\n\tprimaryBootDevice = BootDevice(targetWWPN, lun)\n\n\treturn selectableBoot, primaryBootDevice\n\n##################################################################################\n# Configures the Emulex HBA specified by \"hba\" with the user-supplied HBA\n# configuration specified by \"userHba\".\n#\n# Parameters:\n#    userHba - The user-supplied HBA configuration from the \"HBA_Config\" custom\n#              attribute.\n#    hba - The QLogic HBA to which the user-supplied HBA configuration is to be\n#          applied.\n##################################################################################\n\ndef qlogicConfigureHBA(userHba, hba):\n\n\t# When this setting is disabled, the ROM BIOS on the HBA is disabled,\n\t# freeing space in upper memory.  This setting must be enabled if you\n\t# are booting from an FC disk drive attached to the HBA.\n\tqlogicSetEnableBios(hba.getHbaWWPN(), userHba.getHostAdapterEnableBios())\n\n\t# Enable the Boot From SAN.\n\tqlogicSetSelectableBootEnable(hba.getHbaWWPN(), userHba.getSelectableBootEnable())\n\n\t# Tell the HBA what the primary target WWPN and LUN it should boot from.\n\tqlogicSetPrimaryBootDevice(hba.getHbaWWPN(), userHba.getTargetWWNN(), userHba.getTargetWWPN(), userHba.getLun())\n\n##################################################################################\n# Returns a list of the QLogic HBAs found on the system.\n##################################################################################\n\ndef qlogicGetHBAs():\n\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-t\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\thbaInstancePattern = re.compile(r\"^HBA\\s+Instance\\s+([\\d]+)\\s*:\\s+([\\S]+)\\s+Port\\s+([\\d]+)\\s+WWPN\\s+([\\S]+)\\s+.*$\")\n\tlinkStatusPattern = re.compile(r\"^Link\\s*:\\s+(\\S{1}.*\\S*)\\s*$\")\n\ttargetPathPattern = re.compile(r\"^Path\\s*:\\s+([\\S]+)\\s*$\")\n\ttargetWWNNPattern = re.compile(r\"^Node Name\\s*:\\s+([\\S]+)\\s*$\")\n\ttargetWWPNPattern = re.compile(r\"^Port Name\\s*:\\s+([\\S]+)\\s*$\")\n\tnumLunsPattern = re.compile(r\"^LUN Count\\(s\\)\\s*:\\s+([\\S]+)\\s*$\")\n\n\thbaList = []\n\n\thba = None\n\ttargetSanInfo = None\n\n\tfor line in output.splitlines():\n\t\tresult = hbaInstancePattern.search(line)\n\n\t\tif result:\n\t\t\tif (hba is not None):\n\t\t\t\tif (targetSanInfo is not None):\n\t\t\t\t\thba.addTargetSanInfo(targetSanInfo)\n\t\t\t\t\ttargetSanInfo = None\n\t\t\t\thbaList.append(hba)\n\n\t\t\thbaInstance = result.group(1)\n\t\t\tmodel = result.group(2)\n\t\t\tportNum = result.group(3)\n\t\t\thbaWWPN = result.group(4)\n\n\t\t\thba = HBAInfo()\n\t\t\thba.setInstance(hbaInstance)\n\t\t\thba.setModel(model)\n\t\t\thba.setPortNum(portNum)\n\t\t\thba.setHbaWWPN(hbaWWPN)\n\n\t\t\tenableBios = qlogicGetEnableBios(hbaWWPN)\n\n\t\t\tselectableBoot, primaryBootDevice = qlogicGetPrimaryBootDevice(hbaWWPN)\n\n\t\t\thba.setSelectableBootEnable(selectableBoot)\n\t\t\thba.setHostAdapterEnableBios(enableBios)\n\t\t\thba.setPrimaryBootDevice(primaryBootDevice)\n\n\t\t\tcontinue\n\n\t\tresult = linkStatusPattern.search(line)\n\n\t\tif result:\n\t\t\tlinkStatus = result.group(1)\n\n\t\t\tif (hba is not None):\n\t\t\t\thba.setLinkStatus(linkStatus)\n\t\t\tcontinue\n\n\t\t# When we see \"Path\", that signals the start of the\n\t\t# target information.  Each HBA port may show one or\n\t\t# more targets, so we must collect each target\n\t\t# information and add it to the HBA record.\n\t\tresult = targetPathPattern.search(line)\n\n\t\tif result:\n\t\t\tif (hba is not None):\n\t\t\t\tif (targetSanInfo is not None):\n\t\t\t\t\thba.addTargetSanInfo(targetSanInfo)\n\t\t\t\ttargetSanInfo = TargetSanInfo()\n\t\t\tcontinue\n\n\t\t# Check if the line contains the target WWNN (Node Name).\n\t\tresult = targetWWNNPattern.search(line)\n\n\t\tif result:\n\t\t\ttargetWWNN = result.group(1)\n\n\t\t\tif (targetSanInfo is not None):\n\t\t\t\ttargetSanInfo.setTargetWWNN(targetWWNN)\n\t\t\tcontinue\n\n\t\t# Check if the line contains the target WWPN (Port Name).\n\t\tresult = targetWWPNPattern.search(line)\n\n\t\tif result:\n\t\t\ttargetWWPN = result.group(1)\n\n\t\t\tif (targetSanInfo is not None):\n\t\t\t\ttargetSanInfo.setTargetWWPN(targetWWPN)\n\t\t\tcontinue\n\n\t\t# Check if the line contains the number of LUNs on target.\n\t\tresult = numLunsPattern.search(line)\n\n\t\tif result:\n\t\t\tnumLuns = result.group(1)\n\n\t\t\tif (targetSanInfo is not None):\n\t\t\t\ttargetSanInfo.setNumLuns(numLuns)\n\t\t\tcontinue\n\n\tif (hba is not None):\n\t\tif (targetSanInfo is not None):\n\t\t\thba.addTargetSanInfo(targetSanInfo)\n\n\t\thbaList.append(hba)\n\n\treturn hbaList\n\n##################################################################################\n# Performs a simple test to check if there's a QLogic HBA card installed.  Returns\n# True if there is, false otherwise.  This is needed because the \"qaucli\" command\n# will report an error if there are no HBAs.\n##################################################################################\n\ndef qlogicTestForHBA():\n\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-g\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode == 0):\n\t\treturn True\n\telse:\n\t\tif (DEBUG):\n\t\t\tprint \"retCode => \", retCode\n\t\t\tprint \"output => \", output\n\n\t\treturn False\n\n##################################################################################\n#\n# END QLOGIC-SPECIFIC CODE\n#\n##################################################################################\n\n##################################################################################\n#\n# BEGIN EMULEX-SPECIFIC CODE\n#\n##################################################################################\n\n##################################################################################\n# Enables/Disables the BIOS on the Emulex HBA.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which to enable/disable the BIOS.\n#    enable - Set to \"1\" to enable or \"0\" to disable.\n##################################################################################\n\ndef emulexSetEnableBios(hbaWWPN, enable, hbaModel):\n\n\t# Since the \"HostAdapterBiosEnable-HBA\" tag is optional, we'll default\n\t# it to enabled if the user didn't specify it in the \"HBA_Config\" C.A.\n\tif (enable is None):\n\t\tenable = DEFAULT_HOST_ADAPTER_BIOS_ENABLE\n\n\tif (enable == \"0\"):\n\t\tif (DEBUG):\n\t\t\tprint \"Disabling BIOS on Emulex HBA ...\"\n\t\tenableArg = \"D\"\n\telse:\n\t\tif (DEBUG):\n\t\t\tprint \"Enabling BIOS on Emulex HBA ...\"\n\t\tenableArg = \"E\"\n\n\tcmdArgs = [EMULEX_CMD, \"EnableBootCode\", hbaWWPN, enableArg]\n\n\tretCode, output = executeCommand(cmdArgs)\n\t\n\tif (retCode == 251):\n\t\t \n\t\tprint \"Could not enable the boot code on HBA with model %s.\" % hbaModel\n\t\tprint \"This is expected if the HBA is an Emulex OneConnect-based adapter, as the boot code will always be enabled on these adapters.\"\n\telse:\n\t    if (retCode != 0):\n\t\t    raise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Enables/Disables the Boot From SAN on the Emulex HBA.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which to enable the Boot From SAN.\n#    enable - Set to \"1\" to enable or \"0\" to disable.\n##################################################################################\n\ndef emulexSetEnableBootFromSan(hbaWWPN, enable):\n\n\t# We do not have a tag on the \"HBA_Config\" custom attribute to\n\t# specifically set the boot from SAN, so we use the value of the\n\t# \"HostAdapterBiosEnable-HBA\" tag.  If it is not set, then we\n\t# use its default value.\n\tif (enable is None):\n\t\tenable = DEFAULT_HOST_ADAPTER_BIOS_ENABLE\n\n\tif (DEBUG):\n\t\tif (enable == \"0\"):\n\t\t\tprint \"Disabling Boot From SAN on Emulex HBA ...\"\n\t\telse:\n\t\t\tprint \"Enabling Boot From SAN on Emulex HBA ...\"\n\n\t# Set first boot device to the specified target WWPN.\n\tcmdArgs = [EMULEX_CMD, \"SetBootParams\", hbaWWPN, \"X86\", \"EnableBootFromSAN\", enable]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Sets the primary boot device (Target WWPN/LUN) on the Emulex HBA.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which the primary boot device is to be set.\n#    targetWWPN - The target's World Wide Port Name (The ID of the Controller)\n#                 that is to be set as the primary boot device.\n#    lunId - The LUN ID on the Target WWPN that is to be set as the primary boot\n#            device.\n##################################################################################\n\ndef emulexSetPrimaryBootDevice(hbaWWPN, targetWWPN, lun):\n\n\tif (DEBUG):\n\t\tprint \"Setting Primary Boot Device on Emulex HBA ...\"\n\n\t# Set first boot device (primary) to the specified target WWPN and LUN.\n\tcmdArgs = [EMULEX_CMD, \"SetBootParams\", hbaWWPN, \"X86\", \"targetwwpn\", targetWWPN, \"bootdev\", \"0\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\t# Set first boot device to the specified target WWPN.\n\tcmdArgs = [EMULEX_CMD, \"SetBootParams\", hbaWWPN, \"X86\", \"lun\", lun, \"bootdev\", \"0\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Returns values of the \"EnableAdapterBoot\", \"EnableBootFromSAN\" parameters,\n# along with the primary boot device (TargetWWPN/LUN).\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA whose boot parameters we wish to retrieve.\n##################################################################################\n\ndef emulexGetBootParams(hbaWWPN):\n\n\tcmdArgs = [EMULEX_CMD, \"GetBootParams\", hbaWWPN, \"X86\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\tif (DEBUG):\n\t\t\tprint \"No boot parameters found for HBA WWPN '%s'\" % hbaWWPN\n\t\treturn None, None, None, None\n\n\tenableAdapterBootPattern = re.compile(r\"^\\s*EnableAdapterBoot\\s+(\\d+)\\s+(\\S{1}.*\\S*)\\s*$\")\n\tenableBootFromSanPattern = re.compile(r\"^\\s*EnableBootFromSAN\\s+(\\d+)\\s+(\\S{1}.*\\S*)\\s*$\")\n\tautoScanPattern = re.compile(r\"^\\s*AutoScan\\s+(\\d+)\\s+(\\S{1}.*\\S*)\\s*$\")\n\tbootDevicePattern = re.compile(r\"^\\s*\\d+\\s+(\\d+)\\s+\\S+\\s+([\\S]{2}:[\\S]{2}:[\\S]{2}:[\\S]{2}:[\\S]{2}:[\\S]{2}:[\\S]{2}:[\\S]{2})\\s*$\")\n\n\tenableAdapterBoot = None\n\tenableBootFromSan = None\n\tautoScan = None\n\ttargetWWPN = None\n\tlun = None\n\n\tfor line in output.splitlines():\n\n\t\tresult = enableAdapterBootPattern.search(line)\n\n\t\tif result:\n\t\t\tenableAdapterBoot = result.group(1)\n\t\t\tcontinue\n\n\t\tresult = enableBootFromSanPattern.search(line)\n\n\t\tif result:\n\t\t\tenableBootFromSan = result.group(1)\n\t\t\tcontinue\n\n\t\tresult = autoScanPattern.search(line)\n\n\t\tif result:\n\t\t\tautoScan = result.group(1)\n\t\t\tcontinue\n\n\t\t# Once we find the primary boot device (targetWWPN/LUN)\n\t\t# for this HBA then we're done, since it is one of the\n\t\t# last pieces of data in the output.\n\t\tresult = bootDevicePattern.search(line)\n\n\t\tif result:\n\t\t\tlun = result.group(1)\n\t\t\ttargetWWPN = result.group(2)\n\t\t\tbreak\n\n\tprimaryBootDevice = BootDevice(targetWWPN,lun)\n\n\treturn enableAdapterBoot, enableBootFromSan, autoScan, primaryBootDevice\n\n###########################################################################\n# Enables/Disable the AutoScan.  If being enabled, we only implement the\n# first option, which is \"Any first device\".\n#\n# Auto scan options:\n#    Autoscan disabled - default\n#    Any first device - The first adapter issues a Name Server Inquiry and\n#                       the first D_ID from the inquiry becomes the boot\n#                       device.  The adapter attempts to log in to a public\n#                       loop first.  If it fails, it logs in to a private\n#                       loop.  The first successfully scanned device\n#                       becomes the boot device.  This device only is\n#                       exported to the multi-boot menu.\n#    First LUN 0 device\n#    First NOT LUN 0 device (device other than LUN 0)\n#\n###########################################################################\n\ndef emulexSetAutoScanEnable(hbaWWPN, enable):\n\n\t# Since the \"SelectBootEnable-HBA\" tag is optional, we'll default\n\t# AutoScan to disabled if the user didn't specify it in the\n\t# \"HBA_Config\" C.A.\n\tif (enable is None):\n\t\tenable = EMULEX_DEFAULT_AUTO_SCAN_ENABLE\n\n\tif (DEBUG):\n\t\tif (enable == \"0\"):\n\t\t\tprint \"Disabling AutoScan on Emulex HBA ...\"\n\t\telse:\n\t\t\tprint \"Enabling AutoScan on Emulex HBA ...\"\n\n\t# Set Auto Scan value.\n\tcmdArgs = [EMULEX_CMD, \"SetBootParams\", hbaWWPN, \"X86\", \"AutoScan\", enable]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n###########################################################################\n# Returns the state of the HBA port (e.g. \"Operational\", \"Link Down\", etc).\n###########################################################################\n\ndef emulexGetPortState(hbaWWPN):\n\n\tportState = None\n\n\tcmd = [EMULEX_CMD, \"PortAttrib\", hbaWWPN]\n\n\tretCode, output = executeCommand(cmd)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\tportStatePattern = re.compile(r\"^Port State\\s*:\\s+(\\S{1}.*\\S*)\\s*$\")\n\n\tfor line in output.splitlines():\n\t\tresult = portStatePattern.search(line)\n\n\t\tif result:\n\t\t\tportState = result.group(1)\n\n\treturn portState\n\n##################################################################################\n# Returns a list of the Emulex HBAs found on the system.\n##################################################################################\n\ndef emulexGetHBAs():\n\n\tcmd = [EMULEX_CMD, \"ListHBAs\", \"local\"]\n\n\tretCode, output = executeCommand(cmd)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\tportWWNPattern = re.compile(r\"^Port WWN\\s*:\\s+([\\S]+)\\s*$\")\n\tportMACPattern = re.compile(r\"^Permanent MAC\\s*:\\s+([\\S]+)\\s*$\")\n\tportTypePattern = re.compile(r\"^Port Type\\s*:\\s+([\\S]+)\\s*$\")\n\tportNumberPattern = re.compile(r\"^Port Number\\s*:\\s+([\\S]+)\\s*$\")\n\tmodelPattern = re.compile(r\"^Model\\s*:\\s+([\\S]+)\\s*$\")\n\n\thbaList = []\n\n\thba = None\n\n\tignoreHba = False\n\n\tfor line in output.splitlines():\n\t\t# The line containing the WWPN will usually mark the beginning of a\n\t\t# new Emulex adapter record.  Not all Emulex adapters are HBAs or CNAs,\n\t\t# however.  Some Emulex adapters are NICs, which will start with the\n\t\t# MAC address line.  We'll check for NICs further down.\n\t\tresult = portWWNPattern.search(line)\n\n\t\tif result:\n\t\t\t# Ok, so we've encountered the start of an HBA record.\n\t\t\t# This code checks if we have a pending HBA record that\n\t\t\t# needs to be added to the list of HBAs before we create\n\t\t\t# the new HBA record.\n\t\t\tif (hba is not None):\n\t\t\t\tif (not ignoreHba):\n\t\t\t\t\thbaList.append(hba)\n\n\t\t\tignoreHba = False\n\n\t\t\thbaWWPN = result.group(1)\n\n\t\t\tif (DEBUG):\n\t\t\t\tprint \"Found HBA with WWPN '%s'\" % hbaWWPN\n\n\t\t\thba = HBAInfo()\n\t\t\thba.setHbaWWPN(hbaWWPN)\n\n\t\t\tportState = emulexGetPortState(hbaWWPN)\n\n\t\t\thba.setLinkStatus(portState)\n\n\t\t\tenableAdapterBoot, enableBootFromSan, autoScan, primaryBootDevice = emulexGetBootParams(hbaWWPN)\n\n\t\t\t# If an HBA does not have any boot parameters, then we\n\t\t\t# ignore it.  Perhaps it is not a Fibre Channel HBA.\n\t\t\tif (enableAdapterBoot is not None):\n\t\t\t\t# In Emulex, having AutoScan disabled, is equivalent\n\t\t\t\t# of having SelectableBoot enabled in QLogic, and\n\t\t\t\t# vice versa.  Although, when enabled, AutoScan may\n\t\t\t\t# have 3 different values, we only implement the\n\t\t\t\t# first value, which is to boot from any first device.\n\t\t\t\tif (autoScan == \"0\"):\n\t\t\t\t\tselectableBootEnable = \"1\"\n\t\t\t\telse:\n\t\t\t\t\tselectableBootEnable = \"0\"\n\n\t\t\t\thba.setSelectableBootEnable(selectableBootEnable)\n\t\t\t\thba.setHostAdapterEnableBios(enableAdapterBoot)\n\t\t\t\thba.setPrimaryBootDevice(primaryBootDevice)\n\t\t\telse:\n\t\t\t\tif (DEBUG):\n\t\t\t\t\tprint \"Ignoring HBA '%s' because it has no boot parameters\" % hbaWWPN\n\t\t\t\tignoreHba = True\n\t\telse:\n\t\t\t# Is this a MAC address instead of a WWPN?\n\t\t\tresult = portMACPattern.search(line)\n\n\t\t\t# Skip over Emulex adapters which are NICs, not HBAs, such as the \"554FLB\".\n\t\t\tif result:\n\t\t\t\t# Ok, so we've encountered the start of a NIC record,\n\t\t\t\t# which we don't care about. This code checks if we \n\t\t\t\t# have a pending HBA record that needs to be added to\n\t\t\t\t# the list of HBAs.\n\t\t\t\tif (hba is not None):\n\t\t\t\t\tif (not ignoreHba):\n\t\t\t\t\t\thbaList.append(hba)\n\n\t\t\t\tportMAC = result.group(1)\n\n\t\t\t\t# This is a NIC, not an HBA, so ignore all the remaining\n\t\t\t\t# lines until we hit the start of the next record.\n\t\t\t\tignoreHba = True\n\n\t\t\t\t# We're not creating a new HBA record, because this\n\t\t\t\t# is a NIC, not an HBA.\n\t\t\t\thba = None\n\n\t\t\t\tif (DEBUG):\n\t\t\t\t\tprint \"Ignoring NIC with MAC address '%s'\" % portMAC\n\n\t\tif (not ignoreHba):\n\t\t\tresult = portTypePattern.search(line)\n\n\t\t\tif result:\n\t\t\t\tportType = result.group(1)\n\n                                # This is an Emulex NIC, not an HBA.\n\t\t\t\tif (portType == \"NIC\"):\n\t\t\t\t\tif (DEBUG):\n\t\t\t\t\t\tprint \"Ignoring NIC device\"\n\n\t\t\t\t\tignoreHba = True\n\n\t\tif (not ignoreHba) and (hba is not None):\n\t\t\tresult = portNumberPattern.search(line)\n\n\t\t\tif result:\n\t\t\t\tportNum = result.group(1)\n\n\t\t\t\thba.setPortNum(portNum)\n\n\t\t\tresult = modelPattern.search(line)\n\n\t\t\tif result:\n\t\t\t\tmodel = result.group(1)\n\n\t\t\t\thba.setModel(model)\n\n\tif (hba is not None):\n\t\tif (not ignoreHba):\n\t\t\thbaList.append(hba)\n\n\treturn hbaList\n\n##################################################################################\n# Configures the Emulex HBA specified by \"hba\" with the user-supplied HBA\n# configuration specified by \"userHba\".\n#\n# Parameters:\n#    userHba - The user-supplied HBA configuration from the \"HBA_Config\" custom\n#              attribute.\n#    hba - The Emulex HBA to which the user-supplied HBA configuration is to be\n#          applied.\n##################################################################################\n\ndef emulexConfigureHBA(userHba, hba):\n\n\t# Enables/disables the boot code on the adapter.  If the boot code is\n\t# disabled, the adapter will not boot from SAN, regardless of the value\n\t# for the EnableBootFromSan boot param.  If it is enabled, the adapter\n\t# boot from the SAN if the EnableBootFromSan parameter is also enabled.\n\temulexSetEnableBios(hba.getHbaWWPN(), userHba.getHostAdapterEnableBios(), hba.getModel())\n\n\t# Enable the Boot From SAN if the Host Adapter Enable BIOS is set.\n\temulexSetEnableBootFromSan(hba.getHbaWWPN(), userHba.getHostAdapterEnableBios())\n\n\t# Set the \"AutoScan\" option in Emulex does the opposite of what the\n\t# \"SelectableBoot\" option does in QLogic, we have to enable \"AutoScan\"\n\t# if \"SelectableBoot\" is disabled and vice versa.\n\tif (userHba.getSelectableBootEnable() == \"0\"):\n\t\tautoScan = \"1\"  # Boot from first successfully scanned device.\n\telse:\n\t\tautoScan = \"0\"  # Boot from primary target WWPN/LUN in device list.\t\t\n\n\temulexSetAutoScanEnable(hba.getHbaWWPN(), autoScan)\n\n\t# Tell the HBA what the primary target WWPN and LUN it should boot from.\n\temulexSetPrimaryBootDevice(hba.getHbaWWPN(), userHba.getTargetWWPN(), userHba.getLun())\n\n##################################################################################\n# Performs a simple test to check if there's a Emulex HBA card installed.  Returns\n# True if there is, false otherwise.  This is needed because the \"hbacmd\" command\n# will report an error if there are no HBAs.\n##################################################################################\n\ndef emulexTestForHBA():\n\n\tcmdArgs = [EMULEX_CMD, \"ListHBAs\", \"local\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode == 0):\n\t\treturn True\n\telse:\n\t\tif (DEBUG):\n\t\t\tprint \"retCode => \", retCode\n\t\t\tprint \"output => \", output\n\n\t\treturn False\n\n##################################################################################\n#\n# END EMULEX-SPECIFIC CODE\n#\n##################################################################################\n\n##################################################################################\n# Searches the list of user-specified HBA configuration settings and returns the\n# record, if any, that matches the specified tag number.\n#\n# For example, tags with the same tag number, such as \"BootWWPN-HBA0\", \n# \"BootLUN-HBA0\", \"WWPN-HBA0\", etc, are all stored in the same record, so that if\n# we encounter \"SelectBootEnable-HBA0\" as we're parsing the \"HBA_Config\" custom\n# attribute, it can be added to the same record.\n##################################################################################\n\ndef findUserHbaByTagNumber(userHbaList, tagNum):\n\n\tuserHbaToReturn = None\n\n\tfor userHba in userHbaList:\n\t\tif (userHba.getTagNum() == tagNum):\n\t\t\tuserHbaToReturn = userHba\n\t\t\tbreak\n\n\treturn userHbaToReturn\n\n##################################################################################\n# Searches the list of HBAs and returns the one whose WWPN matches the specified\n# WWPN.\n##################################################################################\n\ndef getHbaByWWPN(hbaList, hbaWWPN):\n\n\tfor hba in hbaList:\n\t\tif (hba.getHbaWWPN() is not None):\n\t\t\tif (hba.getHbaWWPN() == hbaWWPN):\n\t\t\t\treturn hba\n\n\treturn None\n\n##################################################################################\n# Returns the HBA whose order in the list matches the specified HBA number.\n#\n# For example, if \"hbaNumber\" is 0, it returns the first HBA in the list. If\n# \"hbaNumber\" is 1, then it returns the second HBA in the list, and so on.\n##################################################################################\n\ndef getHbaByHbaNumber(hbaList, hbaNumber):\n\n\tcount = 0\n\n\tfor hba in hbaList:\n\t\tif (count == hbaNumber):\n\t\t\treturn hba\n\t\telse:\n\t\t\tcount += 1\n\n\treturn None\n\n##################################################################################\n# Returns True if the specified WWPN or WWNN is in one of the two acceptable\n# formats, False otherwise.\n##################################################################################\n\ndef validateWWN(value):\n\t# The WWPN and WWNN can be in only one of these two formats:\n\t#\n\t#     XX:XX:XX:XX:XX:XX:XX:XX\n\t#\n\t#     or\n\t#\n\t#     XX-XX-XX-XX-XX-XX-XX-XX\n\twwnPattern = re.compile(r\"^[0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}$\")\n\n\tisValid = False\n\n\tresult = wwnPattern.search(value)\n\n\tif result:\n\t\tisValid = True\n\n\treturn isValid\n\n##################################################################################\n# Parses the \"HBA_Config\" custom attribute and returns a list of user-specified\n# HBA configuration settings.\n##################################################################################\n\ndef getUserHbaListFromCustomAttribute():\n\n\tcommentPattern = re.compile(r\"^#.*\")\n\ttagPattern = re.compile(r\"^([\\S-]+)(\\d)+$\")\n\n\tuserHbaList = []\n\n\t# Parse the custom attribute by line.\n\tfor line in HBA_CONFIG_CA_VALUE.splitlines():\n\n\t\t# Skip comment line.\n\t\tresult = commentPattern.search(line)\n\n\t\tif result:\n\t\t\tcontinue\n\n\t\t# Skip empty lines.\n\t\tif len(line.strip()) == 0:\n\t\t\tcontinue\n\n\t\t# Get the tag/value pair.\n\t\ttagVal = line.split(\"=\")\n\n\t\t# The left-hand side of the \"=\" sign will contain the tag name and tag number.\n\t\ttag = tagVal[0].strip()\n\n\t\t# Verify that the value is not empty.\n\t\tif (len(tagVal) > 1) and (len(tagVal[1].strip())) > 0:\n\t\t\tvalue = tagVal[1].strip()\n\t\telse:\n\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has tag '%s' with no value\" % (HBA_CONFIG_CA_NAME,tag))\n\n\t\t# The tag name must end in a number.\n\t\tresult = tagPattern.search(tag)\n\n\t\tif result:\n\t\t\t# Get the tag name.\n\t\t\ttagName = result.group(1)\n\n\t\t\t# Get the tag number, which represents the HBA #.\n\t\t\ttagNum = int(result.group(2))\n\t\telse:\n\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\n\t\t# Only tags numbers from \"0\" to \"4\" are supported.\n\t\tif (tagNum < 0) or (tagNum > 3):\n\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\n\t\tfoundHba = True\n\n\t\t# Check if we have already created a record to hold the\n\t\t# user-specified configuration for this HBA number.\n\t\tuserHba = findUserHbaByTagNumber(userHbaList, tagNum)\n\n\t\t# We don't have a record to store this HBA's configuration,\n\t\t# so create one.\n\t\tif (userHba is None):\n\t\t\tuserHba = UserHBA()\n\t\t\tfoundHba = False\n\n\t\t# Validate the tag names. Issue an error if it's not one\n\t\t# of the valid tag names or if we encounter a duplicate\n\t\t# tag name.\n\t\tif (tagName == BOOT_WWPN_HBA_TAG):\n\t\t\tif (userHba.getTargetWWPN() is None):\n\t\t\t\tif (validateWWN(value)):\n\t\t\t\t\tuserHba.setTargetWWPN(value)\n\t\t\t\telse:\n\t\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid value '%s' for tag '%s'\" % (HBA_CONFIG_CA_NAME,value,tag))\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telif (tagName == BOOT_WWNN_HBA_TAG):\n\t\t\tif (userHba.getTargetWWNN() is None):\n\t\t\t\tif (validateWWN(value)):\n\t\t\t\t\tuserHba.setTargetWWNN(value)\n\t\t\t\telse:\n\t\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid value '%s' for tag '%s'\" % (HBA_CONFIG_CA_NAME,value,tag))\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telif (tagName == BOOT_LUN_HBA_TAG):\n\t\t\tif (userHba.getLun() is None):\n\t\t\t\tuserHba.setLun(value)\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telif (tagName == WWPN_HBA_TAG):\n\t\t\tif (userHba.getHbaWWPN() is None):\n\t\t\t\tif (validateWWN(value)):\n\t\t\t\t\tuserHba.setHbaWWPN(value)\n\t\t\t\telse:\n\t\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid value '%s' for tag '%s'\" % (HBA_CONFIG_CA_NAME,value,tag))\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telif (tagName == SELECT_BOOT_ENABLE_TAG):\n\t\t\tif (userHba.getSelectableBootEnable() is None):\n\t\t\t\tif (value == \"0\") or (value == \"1\"):\n\t\t\t\t\tuserHba.setSelectableBootEnable(value)\n\t\t\t\telse:\n\t\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has tag '%s' with invalid value '%s'\" % (HBA_CONFIG_CA_NAME,tag, value))\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telif (tagName == HOST_ADAPTER_BIOS_ENABLE_TAG):\n\t\t\tif (userHba.getHostAdapterEnableBios() is None):\n\t\t\t\tif (value == \"0\") or (value == \"1\"):\n\t\t\t\t\tuserHba.setHostAdapterEnableBios(value)\n\t\t\t\telse:\n\t\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has tag '%s' with invalid value '%s'\" % (HBA_CONFIG_CA_NAME,tag, value))\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telse:\n\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\n\t\t# If we didn't already have an entry for this HBA in the list\n\t\t# then add it.\n\t\tif (not foundHba):\n\t\t\tuserHba.setTagNum(tagNum)\n\t\t\tuserHbaList.append(userHba)\n\n\tif (len(userHbaList) > 0):\n\t\t# Verify that the \"BootWWPN-HBA\" and \"BootLUN-HBA\" tags were specified\n\t\t# for each user-supplied HBA configuration in the \"HBA_Config\"\n\t\t# custom attribute.\n\t\tfor hba in userHbaList:\n\t\t\tif (hba.getTargetWWPN() is None):\n\t\t\t\tmissingTag = BOOT_WWPN_HBA + str(hba.getTagNum())\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' is missing tag '%s'\" % (HBA_CONFIG_CA_NAME, missingTag))\n\t\t\telif (hba.getLun() is None):\n\t\t\t\tmissingTag = BOOT_LUN_HBA + str(hba.getTagNum())\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' is missing tag '%s'\" % (HBA_CONFIG_CA_NAME, missingTag))\n\telse:\n\t\traise ShowErrorMessage(\"Custom attribute '%s' does not contain any HBAs to configure\" % HBA_CONFIG_CA_NAME)\n\n\treturn userHbaList\n\n##################################################################################\n# Configures the HBAs specified by \"hbaList\" with the user-supplied HBA\n# configuration specified by \"userHbaList\".\n#\n# For each user-supplied HBA configuration, if the user specified the\n# \"WWPN-HBA\" tag in the \"HBA_Config\" custom attribute, then the configuration\n# parameters will be applied to the HBA whose WWPN matches the value specified\n# in the \"WWPN-HBA\" tag.  If the \"WWPN-HBA\" tag was not specified, then the\n# configuration parameters will be applied to the HBA whose order in the HBA list\n# matches the tag number of the \"BOOT-WWPN\" tag, which can be \"0\" or \"1\". For\n# example, if the tag number is \"0\", then the configuration parameters will be\n# applied to the first HBA in the list.  If the tag number is \"1\", then the\n# configuration parameters will be applied to the second HBA in the list.\n#\n# Parameters:\n#    adapterId - Used to identify the manufacturer of the HBA.  Can be either\n#                EMULEX or QLOGIC.\n#    userHbaList - The user-supplied list of HBA configurations from the\n#                  \"HBA_Config\" custom attribute.\n#    hbaList - The Emulex or QLogic HBAs to which the user-supplied HBA\n#              configuration is to be applied.\n##################################################################################\n\ndef configureHBAs(adapterId, userHbaList, hbaList):\n\n\tfor userHba in userHbaList:\n\t\t# If the user provided the HBA's WWPN, then we'll apply the\n\t\t# boot settings to that HBA.  Otherwise, we'll apply it to\n\t\t# the adapter whose order in the list matches the number of\n\t\t# the tag.  In other words, BootWWPN-HBA0 will get applied\n\t\t# to the first adapter and BootWWPN-HBA1 will get applied\n\t\t# to the second adapter.\n\t\tif (userHba.getHbaWWPN() is not None):\n\t\t\thba = getHbaByWWPN(hbaList, userHba.getHbaWWPN())\n\n\t\t\tif (hba is None):\n\t\t\t\traise ShowErrorMessage(\"Cannot configure HBA #%s because the server does not have an HBA with WWPN '%s'\" % (userHba.getTagNum(), userHba.getHbaWWPN()))\n\t\telse:\n\t\t\tif (DEBUG):\n\t\t\t\tprint \"No WWPN-HBA tag was specified for HBA #%s\" % userHba.getTagNum()\n\n\t\t\thba = getHbaByHbaNumber(hbaList, userHba.getTagNum());\n\n\t\t\tif (hba is None):\n\t\t\t\traise ShowErrorMessage(\"Cannot configure HBA #%s because the server has %s HBA(s)\" % (userHba.getTagNum(), len(hbaList)))\n\n\t\t\tif (DEBUG):\n\t\t\t\tprint \"HBA #%s has WWPN '%s'\" % (userHba.getTagNum(), hba.getHbaWWPN())\n\n\t\tif (adapterId == EMULEX):\n\t\t\temulexConfigureHBA(userHba, hba)\n\t\telif (adapterId == QLOGIC):\n\t\t\tqlogicConfigureHBA(userHba, hba)\n\t\telse:\n\t\t\traise ShowErrorMessage(\"Invalid adapter ID '%d' passed to configureHBAs()\" % adapterId)\n\n##################################################################################\n# Main Routine\n##################################################################################\n\ndef main():\n\n\toptions, remaining_args = parseArgs(sys.argv[1:])\n\n\t# Both the Emulex and QLogic packages must be installed on the\n\t# system, regardless of whether the HBA exists or not.\n\tif (not os.path.exists(EMULEX_CMD)):\n\t\tmsg  = \"'%s' does not exist\" % EMULEX_CMD\n\t\tmsg += \"\\n\"\n\t\tmsg += \"Please verify that the package containing the Emulex utilities is in your Build Plan.\"\n\t\tLOG.exception(msg)\n\t\tsys.stderr.write(\"%s\\n\" % msg)\n\t\treturn 1\n\telif (not os.path.exists(QLOGIC_CMD)):\n\t\tmsg  = \"'%s' does not exist\" % QLOGIC_CMD\n\t\tmsg += \"\\n\"\n\t\tmsg += \"Please verify that the package containing the QLogic utilities is in your Build Plan.\"\n\t\tLOG.exception(msg)\n\t\tsys.stderr.write(\"%s\\n\" % msg)\n\t\treturn 1\n\n\t# Count the number of HBAs we find on the system.  If we don't find\n\t# at least one HBA, then we will issue an error.\n\thbaCount = 0\n\n\ttry:\n\t\t# Test if there's an Emulex HBA card on the system.\n\t\tif (emulexTestForHBA()):\n\t\t\t# Fetch the Emulex HBAs.\n\t\t\temulexHbaList = emulexGetHBAs()\n\t\telse:\n\t\t\temulexHbaList = None\n\n\t\tif (emulexHbaList is not None) and (len(emulexHbaList) != 0):\n\t\t\tprint \"Emulex HBAs:\\n\"\n\t\t\tshowHBAs(emulexHbaList)\n\t\t\tprint \"\\n\"\n\n\t\t\tif (not options.displayHbaOnly):\n\t\t\t\t# Parse the \"HBA_Config\" custom attribute and extract\n\t\t\t\t# the HBA configuration information.\n\t\t\t\tuserHbaList = getUserHbaListFromCustomAttribute()\n\n\t\t\t\t# Configure the Emulex HBAs with the user-specified\n\t\t\t\t# HBA configuration settings.\n\t\t\t\tconfigureHBAs(EMULEX, userHbaList, emulexHbaList)\n\n\t\t\t\t# Fetch the Emulex HBAs again.\n\t\t\t\temulexHbaList = emulexGetHBAs()\n\n\t\t\t\tprint \"Emulex HBAs After Applying Configuration:\\n\"\n\t\t\t\tshowHBAs(emulexHbaList)\n\t\t\t\tprint \"\\n\"\n\n\t\t\thbaCount += 1\n\n\t\t# Test if there's an QLogic HBA card on the system.\n\t\tif (qlogicTestForHBA()):\n\t\t\t# Fetch the QLogic HBAs.\n\t\t\tqlogicHbaList = qlogicGetHBAs()\n\t\telse:\n\t\t\tqlogicHbaList = None\n\n\t\tif (qlogicHbaList is not None) and (len(qlogicHbaList) != 0):\n\t\t\tprint \"QLogic HBAs:\\n\"\n\t\t\tshowHBAs(qlogicHbaList)\n\t\t\tprint \"\\n\"\n\n\t\t\tif (not options.displayHbaOnly):\n\t\t\t\t# Parse the \"HBA_Config\" custom attribute and extract\n\t\t\t\t# the HBA configuration information.\n\t\t\t\tuserHbaList = getUserHbaListFromCustomAttribute()\n\n\t\t\t\t# Configure the QLogic HBAs with the user-specified\n\t\t\t\t# HBA configuration settings.\n\t\t\t\tconfigureHBAs(QLOGIC, userHbaList, qlogicHbaList)\n\n\t\t\t\t# Fetch the QLogic HBAs again.\n\t\t\t\tqlogicHbaList = qlogicGetHBAs()\n\n\t\t\t\tprint \"QLogic HBAs After Applying Configuration:\\n\"\n\t\t\t\tshowHBAs(qlogicHbaList)\n\t\t\t\tprint \"\\n\"\n\n\t\t\thbaCount += 1\n\n\t\t# Issue an error if no HBAs are installed on the system.\n\t\tif (hbaCount == 0):\n\t\t\tmsg = \"No Emulex or QLogic HBAs found\"\n\t\t\tLOG.exception(msg)\n\t\t\tsys.stderr.write(\"%s\\n\" % msg)\n\t\t\treturn 1\n\n\texcept (ShowErrorMessage), why:\n\t\tLOG.exception(why)\n\t\tsys.stderr.write(\"%s\\n\" % why)\n\t\treturn 1\n\nif __name__ == \"__main__\":\n\tsys.exit(main())", 
    "state": null, 
    "version": {
      "usage": "Configures the boot device by applying the configuration specified in the HBA_Config multi-line custom attribute to the Emulex CNA, Emulex HBA or Qlogic HBA.\n\nOptional Parameters:\n\n--displayHbaOnly - Show the HBAs on the target server, but don't apply the configuration.\n", 
      "current": true, 
      "versionLabel": "17", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:10:31.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-28T00:10:31.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Configures the boot device by applying the configuration specified in the HBA_Config multi-line custom attribute to the Emulex CNA, Emulex HBA or Qlogic HBA.\n\nOptional Parameters:\n\n--displayHbaOnly - Show the HBAs on the target server, but don't apply the configuration.\n", 
        "current": true, 
        "versionLabel": "17", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:10:31.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:35.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:34.000Z", 
    "description": "Creates a small stub partition so we can load the Solaris build image from local disk.\nBy default the boot disk is identified as the first disk in lshal.\nA single 2 GB partition will be created with a ZFS filesystem on slice 0.\n\nThe partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py\n\nThis script expects no command line arguments.\nBoot drive selection can be overridden using the 'boot_disk' custom attribute, valid values are Solaris whole-disk device names, such as c3t0d0p0.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- No additional filesystems must be mounted on the target drive", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1250001", 
    "modified": "2014-03-10T21:37:35.000Z", 
    "name": "Create Solaris Stub Partition", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\nThis program will repartition the target server's boot disk and create a\nsmall (2 GB) \"stub\" ZFS filesystem.\n\nThe boot disk by default is the first hard drive as listed in lshal.\n\nWARNING!\n\nThe disk's partition table, master boot record, and all existing file systems\nare PERMANENTLY ERASED by this operation.\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\n\nfrom osprov.osbp import logger\nfrom osprov.diskmgr.diskmanager import DiskManager\nfrom osprov.diskmgr.disk import Disk\nfrom osprov import helpers\nfrom osprov.decorators import HandleShowErrorMessage\n\n\nBOOT_DISK = \"@boot_disk@\"  # ScriptWeaver will parametrize this data at run time\n\nLOG = logger.getIt(\"Create Solaris Stub Partition\")\n\n\n@HandleShowErrorMessage(\"Create Solaris Stub Partition\", LOG)\ndef main():\n    \"\"\"Main entry point when executed as a script from the command line\"\"\"\n\n    dm = DiskManager(log=LOG)\n    dm.disable_automount()\n    dm.unmountOurs()\n\n    if BOOT_DISK and \"@\" not in BOOT_DISK:\n        bootDisk = Disk(BOOT_DISK)\n    else:\n        bootDisk = None\n\n    bootDisk = dm.getSystemBootDisk(bootDisk)\n\n    stubPartition = bootDisk.createStubPartition()\n    print \"Boot disk partitioned. Stub filesystem is on %s\" % \\\n        stubPartition.getDeviceFilePath()\n\n    # ZFS auto-mounts filesystems, so just setting the mount point suffices\n    stubPartition.setMountPoint(\"/mnt/root\")\n\n    # Save relevant information in the datastore\n    keys = helpers.getDataStore()\n    keys.disk.device_path = stubPartition.getRawFilePath()\n    keys.disk.device_mount = \"/mnt/root\"\n    helpers.putDataStore(keys)\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Creates a small stub partition so we can load the Solaris build image from local disk.\nBy default the boot disk is identified as the first disk in lshal.\nA single 2 GB partition will be created with a ZFS filesystem on slice 0.\n\nThe partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py\n\nThis script expects no command line arguments.\nBoot drive selection can be overridden using the 'boot_disk' custom attribute, valid values are Solaris whole-disk device names, such as c3t0d0p0.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- No additional filesystems must be mounted on the target drive", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:35.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:35.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Creates a small stub partition so we can load the Solaris build image from local disk.\nBy default the boot disk is identified as the first disk in lshal.\nA single 2 GB partition will be created with a ZFS filesystem on slice 0.\n\nThe partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py\n\nThis script expects no command line arguments.\nBoot drive selection can be overridden using the 'boot_disk' custom attribute, valid values are Solaris whole-disk device names, such as c3t0d0p0.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- No additional filesystems must be mounted on the target drive", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:35.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-28T00:11:20.000Z", 
    "serverChanging": true, 
    "created": "2014-03-28T00:09:14.000Z", 
    "description": "Creates and executes a BAT script on the target server that installs the SPP, but does not wait for it to complete.  The BAT script stops the HP SA agent prior to installing the SPP, and starts the HP SA agent after the SPP installation is complete.  The HP SA agent is stopped while the SPP is being installed, because when the NIC firmware is updated, it may cause connection problems between the HP SA agent and the SA core.\n\nOptions:\n    --spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2012.06.0\" or \"2013.09.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n    --hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\nRequirements:\n* Media Server must be mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1520001", 
    "modified": "2014-03-28T00:11:20.000Z", 
    "name": "Install Windows SPP In Background", 
    "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(c) Copyright 2014 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport os\nimport subprocess\n\nfrom subprocess import Popen, PIPE, STDOUT\nfrom optparse import OptionParser\n\nDEBUG=@Debug:0@\n\n# The drive letter on which the media server file share is mounted.\nmediaServerDriveLetter = None\n\n# Get the Windows \"Temp\" directory.\nwindowsSystemDrive = os.getenv(\"SystemDrive\")\nwindowsTempDir = windowsSystemDrive + \"\\\\Windows\\\\Temp\"\n\n# This is where we will copy the HP SUM applications to, so we can run\n# HP SUM from the target server instead of the remote media server\n# file share.\nlocalHpSumDir = windowsTempDir + \"\\\\LocalHpSum\"\n\n# The directory where we will stage our SPP installation scripts and\n# output files.\nicspTempDir = windowsTempDir + \"\\\\icsp\"\nhpSumScript = icspTempDir + \"\\\\hpsum_script.bat\"\nhpSumOutputFile = icspTempDir + \"\\\\hpsum_output.txt\"\nhpSumExitCodeFile = icspTempDir + \"\\\\hpsum_exit_code.txt\"\nsppInstallScript = icspTempDir + \"\\\\spp_install.bat\"\nsppOutputFile = icspTempDir + \"\\\\spp_output.txt\"\n\nsppDir = None\nsppVersionDir = None\nremoteHpSumDir= None\n\n# HP SUM 5.X uses \"hpsum.exe\", while HP SUM 6.X uses \"hpsum.bat\".\nhpSumExe = \"hpsum.exe\"\nhpSumBat = \"hpsum.bat\"\nmasterDependencyXml = \"masterdependency.xml\"\nhpSumApp = None\n\n# The options we will pass to HP SUM.  The \"/silent\" option is required.\n# Additional options may be passed in to this script using the \n# \"--hpsum_options\" parameter.\nhpSumOptions=\"/silent\"\n\n# Parses the command line arguments.\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--spp_version\",\n            default = \"latest\",\n            dest = \"sppVersion\",\n            help = \"The SPP version to install.\")\n    parser.add_option(\"--hpsum_options\",\n            default = \"\",\n            dest = \"hpSumOptions\",\n            help = \"Additional options to pass to hpsum.\")\n    parser.add_option(\"--media_server_drive_letter\",\n            default = \"z\",\n            dest = \"mediaServerDriveLetter\",\n            help = \"The drive letter on which the media server file share is mounted.\")\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n##############################################################################\n# Writes an debug message to stdout.\n##############################################################################\n\ndef writeDebugMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    if (DEBUG):\n        print msg\n\n##############################################################################\n# Writes an info message to stdout.\n##############################################################################\n\ndef writeInfoMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    print msg\n\n##############################################################################\n# Writes an error message to stderr.\n##############################################################################\n\ndef writeErrorMessage(msg):\n\n    # Write the message to stderr so that it shows up in the job output.\n    sys.stderr.write(msg)\n\n##############################################################################\n# Returns the latest SPP version, which is determined by the directory name\n# who comes first in descending sort order.\n##############################################################################\n\ndef getLatestSppVersion():\n\n    writeDebugMessage(\"Searching for the latest SPP\")\n\n    # Get the subdirectories under the \"Media/spp\" directory.\n    sppVersions = [name for name in os.listdir(sppDir) if os.path.isdir(os.path.join(sppDir, name))]\n\n    # Sort the directories in descending order.\n    sortedSppVersions = sorted(sppVersions, reverse=True)\n\n    if (len(sortedSppVersions) == 0):\n        raise Exception(\"No SPP versions were found under the '%s' directory.\" % sppDir)\n\n    writeDebugMessage(\"Found %d SPP versions under '%s'\" % (len(sortedSppVersions),sppDir))\n    writeDebugMessage(\"Selected '%s' as latest SPP\" % sortedSppVersions[0])\n\n    # Return the first directory, which should represent the latest SPP based\n    # on sort order, assuming the name convention is \"YYYY.MM\".\n    return sortedSppVersions[0]\n\n##############################################################################\n# Creates our temporary ICSP directory on which we will land our scripts that\n# run HP SUM.\n##############################################################################\n\ndef createIcspTempDir():\n\n    writeDebugMessage(\"Creating %s\" % icspTempDir)\n\n    dirExists = False;\n\n    # Check if \"icsp\" already exists, and is a directory, not a file.  If it's\n    # a file, remove it.\n    if (os.path.exists(icspTempDir)):\n        if (os.path.isdir(icspTempDir)):\n            dirExists = True\n        else:          \n            removeFile(icspTempDir)\n\n    # If the directory didn't already exist, then create it.\n    if (not dirExists):\n        cmdArgs = [\"mkdir\", icspTempDir]\n\n        retCode, output = executeCommand(cmdArgs)\n\n        if (retCode != 0):\n            raise Exception(\"An error occurred while creating directory '%s': %s\" % (icspTempDir, output))\n\n##############################################################################\n# Create the \"LocalHpSum\" directory where we are going to copy the necessesary\n# HPSUM application files.  The firmware files and software packages will\n# remain on the media server.  The reason why we copy the HP SUM application\n# files locally, is because, otherwise, HP SUM might get a segmentation fault\n# when the NIC firmware is updated, due to loss of network connectivity with\n# the media server.  It's possible that not all pages are loaded into memory,\n# which is a problem if the NIC goes down and another page is requested.\n##############################################################################\n\ndef createLocalHpSumDir():\n\n    writeDebugMessage(\"Creating %s\" % localHpSumDir)\n\n    if (os.path.exists(localHpSumDir)):\n        if not (os.path.isdir(localHpSumDir)):\n            raise Exception(\"'%s' exists, but is not a directory.\" % localHpSumDir)\n    else:\n        cmdArgs = [\"mkdir\", localHpSumDir]\n\n        retCode, output = executeCommand(cmdArgs)\n\n        if (retCode != 0):\n            raise Exception(\"An error occurred while creating directory '%s': %s\" % (localHpSumDir, output))\n\n##############################################################################\n# Copies the HP SUM 6.X application files locally to the target server.  The\n# reason for copying the files locally, is because HP SUM will core dump if\n# it's run remotely from the media server and the NIC firmware is updated,\n# causing the network connection to be lost.\n##############################################################################\n \ndef copyHpSum6AppsToTargetServer():\n\n    global hpSumApp\n\n    createLocalHpSumDir()\n\n    fullPathToMasterDependency = remoteHpSumDir + \"\\\\\" + masterDependencyXml\n\n    # Copy the \"masterdependency.xml\" file locally to the target server.\n    cmdArgs = [\"copy\", \"/Y\", fullPathToMasterDependency, localHpSumDir]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occured while copying '%s' to '%s': %s\" % (fullPathToMasterDependency, localHpSumDir, output))\n\n    fullPathToHpSumBat = remoteHpSumDir + \"\\\\\" + hpSumBat\n\n    writeDebugMessage(\"Copying HP SUM 6.X files locally to target server\")\n\n    # Copy the \"hpsum.bat\" file locally to the target server.\n    cmdArgs = [\"copy\", \"/Y\", fullPathToHpSumBat, localHpSumDir]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occured while copying '%s' to '%s': %s\" % (fullPathToHpSumBat, localHpSumDir, output))\n\n    # These are the subdirectories needed by HP SUM to run locally to the target server.\n    subDirs = [ \"x64\", \"x86\", \"cygwin\", \"assets\"]\n\n    # Copy the subdirectories needed by HP SUM locally to the target server.\n    for dirName in subDirs:\n        fullPathToRemoteSubDir = remoteHpSumDir + \"\\\\\" + dirName\n        fullPathToLocalSubDir = localHpSumDir + \"\\\\\" + dirName\n\n        cmdArgs = [\"xcopy\", \"/s\", \"/y\", \"/i\", \"/q\", fullPathToRemoteSubDir, fullPathToLocalSubDir]\n\n        retCode, output = executeCommand(cmdArgs)\n\n        if (retCode != 0):\n            raise Exception(\"An error occured while copying '%s' to '%s': %s\" % (fullPathToRemoteSubDir, fullPathToLocalSubDir, output))\n\n##############################################################################\n# Gets the HP SUM application to call, which is different, depending on\n# whether HP SUM 6.X is being used or HP SUM 5.X is being used.\n##############################################################################\n\ndef getHpSumApp():\n\n    hpSumAppToCall = None\n\n    # HP SUM 6.X uses \"hpsum.bat\".\n    fullPathToHpSumBat = remoteHpSumDir + \"\\\\\" + hpSumBat\n\n    # HP SUM 5.X uses \"hpsum.exe\".\n    fullPathToHpSumExe = remoteHpSumDir + \"\\\\\" + hpSumExe\n\n    # HP SUM 6.X uses \"hpsum.bat\", whereas HP SUM 5.X uses \"hpsum.exe\".\n    if (os.path.exists(fullPathToHpSumBat)):\n        writeDebugMessage(\"Found %s\" % fullPathToHpSumBat)\n\n        # This is the executable that we'll call to install HP SUM 6.X.\n        hpSumAppToCall = hpSumBat\n    elif (os.path.exists(fullPathToHpSumExe)):\n        writeDebugMessage(\"Found %s\" % fullPathToHpSumExe)\n\n        # This is the executable that we'll call to install HP SUM 5.X.\n        hpSumAppToCall = hpSumExe\n    else:\n        raise Exception(\"Could not find '%s' or '%s'\" % (fullPathToHpSumBat, fullPathToHpSumExe))\n\n    return hpSumAppToCall\n\n##############################################################################\n# Removes the specified file.\n##############################################################################\n\ndef removeFile(filePath):\n\n    writeDebugMessage(\"Removing file %s\" % filePath)\n\n    cmdArgs = [\"del\", \"/q\", \"/s\", filePath]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occurred while removing file '%s': %s\" % (filePath, output))\n\n##############################################################################\n# Removes the specified directory.\n##############################################################################\n\ndef removeDir(dirPath):\n\n    writeDebugMessage(\"Removing directory %s\" % dirPath)\n\n    cmdArgs = [\"rmdir\", \"/q\", \"/s\", dirPath]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occurred while removing directory '%s': %s\" % (dirPath, output))\n\n##############################################################################\n# Removes the HP SUM temporary directory.\n##############################################################################\n\ndef removeHpSumTempDir():\n    writeDebugMessage(\"Removing HP SUM temporary directory\")\n\n    # HP SUM 5.X and HP SUM 6.X used different temporary directory, so lets\n    # check for both.\n    hpSum5TempDir = windowsTempDir + \"\\\\hp_sum\"\n    hpSum6TempDir = windowsTempDir + \"\\\\HPSUM\"\n\n    for tempDir in [ hpSum5TempDir, hpSum6TempDir]:\n        if (os.path.exists(tempDir)):\n            if (os.path.isdir(tempDir)):\n                removeDir(tempDir)\n            else:\n                removeFile(tempDir)\n\n##############################################################################\n# delimiter character (default = ' ').\n##############################################################################\n\ndef listToString(list, delimeter=' '):\n\n    str = delimeter.join(list)\n\n    return str\n\n##############################################################################\n# Executes the specified command, which must be a list contaning the \n# executable name and its arguments.\n##############################################################################\n\ndef executeCommand(cmdArgs):\n\n    cmdAsString = listToString(cmdArgs)\n\n    writeDebugMessage(\"Executing => \" + cmdAsString)\n\n    p = subprocess.Popen(cmdArgs, stdout=subprocess.PIPE, stderr=STDOUT, shell=True)\n\n    output = p.communicate()[0].strip()\n\n    retCode = p.poll()\n\n    p.stdout.close()\n\n    return retCode, output\n\n##############################################################################\n# Executes the specified command, which must be a list contaning the \n# executable name and its arguments, and returns immediately, without\n# waiting for the process to finish.\n##############################################################################\n\ndef executeCommandAndDetach(cmdArgs):\n\n    cmdAsString = listToString(cmdArgs)\n\n    writeDebugMessage(\"Executing => \" + cmdAsString)\n\n    retCode = 0\n\n    try:\n        CREATE_NO_WINDOW=0x08000000\n        CREATE_NEW_PROCESS_GROUP=0x00000200\n        CREATE_BREAKAWAY_FROM_JOB=0x01000000\n\n        p = subprocess.Popen(cmdArgs, close_fds = True, creationflags=CREATE_NO_WINDOW|CREATE_NEW_PROCESS_GROUP|CREATE_BREAKAWAY_FROM_JOB)\n\n        retCode = p.poll()\n    except (Exception), why:\n        retCode = 1\n        sys.stderr.write(\"An error occured while executing '%s': %s\" % (cmdAsString,str(why)))\n\n    return retCode\n\n##############################################################################\n# Checks if the specified directory is accessible.\n##############################################################################\n\ndef checkIfDirIsAccessible(dirPath):\n\n    if (os.path.exists(dirPath)):\n        if not (os.path.isdir(dirPath)):\n            raise Exception(\"'%s' is not a directory.\" % dirPath)\n    else:\n        raise Exception(\"The directory '%s' does not exist or the file share is not mounted.\" % dirPath)\n\n##############################################################################\n# Checks if the SPP directory is accessible.\n##############################################################################\n\ndef checkIfSppDirIsAccessible():\n\n    global sppDir\n\n    if (sppDir is not None):\n        try:\n            checkIfDirIsAccessible(sppDir)\n        except (Exception), why:\n            raise Exception(\"The SPP directory is not accessible: %s\" % why)\n    else:\n        raise Exception(\"The sppDir variable is not set\")\n\n##############################################################################\n# Checks if the SPP version directory is accessible.\n##############################################################################\n\ndef checkIfSppVersionDirIsAccessible():\n\n    global sppVersionDir\n\n    if (sppVersionDir is not None):\n        try:\n            checkIfDirIsAccessible(sppVersionDir)\n        except (Exception), why:\n            raise Exception(\"The SPP version directory is not accessible: %s\" % why)\n    else:\n        raise Exception(\"The sppVersionDir variable is not set\")\n\n##############################################################################\n# Creates the SPP installation script that runs the HP SUM installation\n# script and captures its output to a file.\n##############################################################################\n\ndef createSppInstallScript():\n\n    global hpSumScript\n    global hpSumOutputFile\n    global sppInstallScript\n\n    writeDebugMessage(\"Creating %s\" % sppInstallScript)\n\n    # This is a Python here document containing the contents of the SPP \n    # installation script.  All this script does is call the HP SUM installation\n    # script and capture its output to a file.\n    scriptContents = \"\"\"\ncall %s > %s\n\"\"\" % (hpSumScript,hpSumOutputFile)\n\n    # Write the file.\n    f = open( sppInstallScript, 'w')\n    f.write( scriptContents )\n    f.close()\n\n##############################################################################\n# Creates the HP SUM installation script that stops the SA agent, runs\n# HP SUM, and starts the SA agent again.\n##############################################################################\n\ndef createHpSumScript():\n\n    global hpSumOptions\n    global localHpSumDir\n    global remoteHpSumDir\n    global mediaServerDriveLetter\n    global hpSumApp\n    global hpSumBat\n\n    writeDebugMessage(\"Creating %s\" % hpSumScript)\n\n    # The 'hpSumApp' variable should have been set in the function that copies\n    # the HP SUM applications locally to the target server.\n    if (hpSumApp is None):\n        raise Exception(\"hpSumApp is not set\")\n\n    # The HP SUM command we're going to run.\n    hpSumCommand = hpSumApp + \" \" + \"/use_location\" + \" \" + remoteHpSumDir + \" \" + hpSumOptions\n\n    # HP SUM 6.X uses \"hpsum.bat\" and must be run from a directory on the target server\n    # to prevent the application from crashing when the NIC firmware is updated and\n    # the media server is no longer accessible.\n    #\n    # HP SUM 5.X uses \"hpsum.exe\" and is not susceptible to crashing when the NIC\n    # firmware is updated.  We always ran it from the remote directory on the media\n    # server, so we will continue to run it that way.\n    if (hpSumApp == hpSumBat):\n        dirToExecuteHpSumFrom = localHpSumDir\n    else:\n        dirToExecuteHpSumFrom = remoteHpSumDir\n\n    # This is a Python here document containing the contents of the script that is\n    # going to stop the SA agent, run HP SUM, and start the SA agent.  The DOS\n    # variables use \"%%\", which is to escape the second \"%\", so that Python doesn't\n    # interpret it as a format character.\n    scriptContents = \"\"\"\n@echo off\n\necho TIME: %%DATE%% %%TIME%%\n\necho Sleeping for 10 seconds to ensure that the build plan step has completed before stopping the SA agent\n\nping -n 10 127.0.0.1 >nul\n\necho TIME: %%DATE%% %%TIME%%\n\necho Stopping Opsware Agent\n\nsc stop OpswareAgent\n\nif %%ERRORLEVEL%% NEQ 0 (\n    echo Failed to stop Opware Agent\n    exit 1\n)\n\nset dirToExecuteHpSumFrom=%s\n\necho Changing directory to '%%dirToExecuteHpSumFrom%%'\n\ncd /D %%dirToExecuteHpSumFrom%%\n\nif %%ERRORLEVEL%% NEQ 0 (\n    echo Could not change directory to '%%dirToExecuteHpSumFrom%%'\n    exit 1\n)\n\necho TIME: %%DATE%% %%TIME%%\n\necho Starting hpsum\n\ncall %s\n\nset hpSumRetCode=%%ERRORLEVEL%%\n\necho hpsum exited with return code '%%hpSumRetCode%%'\n\necho TIME: %%DATE%% %%TIME%%\n\necho %%hpSumRetCode%% > %s\n\necho Starting Opsware Agent\n\nsc start OpswareAgent\n\nif %%ERRORLEVEL%% NEQ 0 (\n    echo Failed to start Opware Agent\n    exit 1\n)\n\necho TIME: %%DATE%% %%TIME%%\n\necho Changing directory to SystemDrive\n\nREM Make sure we're not on the media server drive when we exit, in order\nREM to prevent any potential problem later on if the media server drive\nREM is attempted to be unmounted.  You can't unmount a drive if a process\nREM is using it.\ncd /D %%SYSTEMDRIVE%%\\\\\n\n\"\"\" % (dirToExecuteHpSumFrom,hpSumCommand,hpSumExitCodeFile)\n\n    # Write the file.\n    f = open( hpSumScript, 'w')\n    f.write( scriptContents )\n    f.close()\n\n##############################################################################\n# Runs the HP SUM installation.\n##############################################################################\n\ndef runHpSum():\n\n    # Create the temporary directory that will contain our scripts and the\n    # output files produced by our scripts.\n    createIcspTempDir()\n\n    # Create our HP SUM script that stops the SA agent, runs HP SUM, and \n    # starts the SA agent.\n    createHpSumScript()\n\n    # Create that script that calls our HP SUM script and captures its output\n    # to a file, for debugging purposes.\n    createSppInstallScript()\n\n    cmdArgs = [sppInstallScript]\n\n    retCode = executeCommandAndDetach(cmdArgs)\n    \n    return retCode\n\n##############################################################################\n# Main Routine.\n##############################################################################\n\ndef main():\n\n    global hpSumApp\n    global hpSumBat\n    global hpSumOptions\n    global sppDir\n    global sppVersionDir\n    global remoteHpSumDir\n    global mediaServerDriveLetter\n\n    retCode = 0\n\n    options, remaining_args = parseArgs(sys.argv[1:])\n\n    try:\n        # Get the drive letter that the meda server file share is mounted on.\n        mediaServerDriveLetter = options.mediaServerDriveLetter.strip()\n\n        writeDebugMessage(\"Media Server Drive Letter => %s\" % mediaServerDriveLetter)\n\n        # The directory on the media server where the SPPs are stored.\n        sppDir = mediaServerDriveLetter + \":\" + \"\\\\Media\\\\spp\"\n\n        # Verify that the directory is accessible.  If the media server file share\n        # was manually mounted by the user, it may not be accessible to the build plan,\n        # even though you can see it mounted from Windows.  This could cause HP SUM\n        # to hang.\n        checkIfSppDirIsAccessible()\n\n        # Check which SPP to use. If it's \"latest\", select the latest SPP from the\n        # available SPPs under the \"Media/spp\" directory.  It is expected that the\n        # SPPs are stored under \"Media/spp\", with a directory name of \"YYYY.MM\",\n        # such that the latest SPP has the highest value, according to sort order.\n        if (options.sppVersion.lower() == \"latest\"):\n            writeInfoMessage(\"SPP version is 'latest'\")\n            sppVersion = getLatestSppVersion()\n            writeInfoMessage(\"Latest SPP version is '%s'\" % sppVersion)\n            sppVersionDir = sppDir + \"\\\\\" + sppVersion\n        else:\n            writeInfoMessage(\"SPP version is '%s'\" % options.sppVersion)\n            sppVersionDir = sppDir + \"\\\\\" + options.sppVersion\n            checkIfSppVersionDirIsAccessible()\n\n        # The remote HP SUM directory is \"hp\\swpackages\" under the SPP version\n        # directory.\n        remoteHpSumDir = sppVersionDir + \"\\\\hp\\\\swpackages\"\n\n        # Append any additional HP SUM options to the \"/silent\" option that we\n        # already require.\n        hpSumOptions += \" \" + options.hpSumOptions\n\n        writeInfoMessage(\"HP SUM options => %s\" % hpSumOptions)\n\n        hpSumApp = getHpSumApp()\n\n        # Remove the old HP SUM temporary directory, if exists.\n        removeHpSumTempDir()\n\n        # If the HP SUM application is \"hpsum.bat\", than means we're using\n        # HP SUM 6.X, which must be run from the target server.  So, we must\n        # copy the necessary application files over from the media server to\n        # the target server.\n        if (hpSumApp == hpSumBat):\n            copyHpSum6AppsToTargetServer()\n\n        # Run HP SUM.\n        retCode = runHpSum()\n    except (Exception), why:\n        retCode = 1\n        sys.stderr.write(\"%s\" % why)\n\n    return retCode\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Creates and executes a BAT script on the target server that installs the SPP, but does not wait for it to complete.  The BAT script stops the HP SA agent prior to installing the SPP, and starts the HP SA agent after the SPP installation is complete.  The HP SA agent is stopped while the SPP is being installed, because when the NIC firmware is updated, it may cause connection problems between the HP SA agent and the SA core.\n\nOptions:\n    --spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2012.06.0\" or \"2013.09.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n    --hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\nRequirements:\n* Media Server must be mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.", 
      "current": true, 
      "versionLabel": "12", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-28T00:11:20.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-28T00:11:20.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Creates and executes a BAT script on the target server that installs the SPP, but does not wait for it to complete.  The BAT script stops the HP SA agent prior to installing the SPP, and starts the HP SA agent after the SPP installation is complete.  The HP SA agent is stopped while the SPP is being installed, because when the NIC firmware is updated, it may cause connection problems between the HP SA agent and the SA core.\n\nOptions:\n    --spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2012.06.0\" or \"2013.09.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n    --hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\nRequirements:\n* Media Server must be mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.", 
        "current": false, 
        "versionLabel": "11", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:09:15.000Z"
      }, 
      {
        "usage": "Creates and executes a BAT script on the target server that installs the SPP, but does not wait for it to complete.  The BAT script stops the HP SA agent prior to installing the SPP, and starts the HP SA agent after the SPP installation is complete.  The HP SA agent is stopped while the SPP is being installed, because when the NIC firmware is updated, it may cause connection problems between the HP SA agent and the SA core.\n\nOptions:\n    --spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2012.06.0\" or \"2013.09.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n    --hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\nRequirements:\n* Media Server must be mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.", 
        "current": true, 
        "versionLabel": "12", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-28T00:11:20.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:27.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:26.000Z", 
    "description": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool\n\nUsage: capture_windows_image.cmd path_to_wim_file captured_drive [path_to_wimscript.ini]\n\nScript takes 3 parameters (first 2 are mandatory):\n 1. path where .wim image file will be saved (path + .wim image name)\n 2. drive which will be captured\n 3. path to wimscript.ini file. If this parameter is not provided this script will generate a wimscript.ini file used to exclude SA Opsware Agent from new .wim image and it will extend an existing wimscript.ini file to do the same (exclude SA Opsware Agent)\n \nExample: capture_windows_image.cmd Z:\\media\\newWimFile.wim C: [Z:\\configs\\wimscript.ini]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1100001", 
    "modified": "2014-03-10T21:37:27.000Z", 
    "name": "Capture Windows Image", 
    "source": "@echo off\n\nREM # %1 - .wim image file \nREM # %2 - drive to be captured (C:)\nREM # %3 - path to wimscript.ini file [optional parameter]\n\nREM # if mandatory parameters are not provided, the script will return error\nif \"%2\"==\"\" (\n  echo Not enough parameters provided\n  exit /B 1\n)\n\nif \"%2\"==\"C:\" goto have_targetdrive\nif \"%2\"==\"c:\" goto have_targetdrive\necho WARNING: Only C: drive capture is supported\n\n:have_targetdrive\n\nset wimscript=%SYSTEMDRIVE%\\wimscript%RANDOM%.ini\nset excepted=0\nset wimFilePath=%1\nset drive=%2\n\nREM # no wimscript, we generate one\nif \"%3\"==\"\" (\n  copy nul %wimscript%\n  echo [ExclusionList]>> %wimscript%\n  call:InsertExclusionList\n  call:CaptureImage\n)\n\nREM # we have a wimscript: add -OR- insert to [ExclusionList]\ncopy nul %wimscript%\nfor /f \"tokens=1* delims= \" %%a in (%3) do (\n  echo %%a %%b>> %wimscript%\n  if \"%%a\"==\"[ExclusionList]\" (\n        call:InsertExclusionList\n        set excepted=1\n  )\n)\n\nREM # if exception wasn't inserted yet, we append it to end\nif \"%excepted%\"==\"0\" (\n  echo.>> %wimscript%\n  echo [ExclusionList]>> %wimscript%\n  call:InsertExclusionList\n)\n\ncall:CaptureImage\n\nREM # function definitions\n:CaptureImage\necho execute: imagex.exe /config %wimscript% /capture %drive% \"%wimFilePath%\" \"OS\"\nimagex.exe /config %wimscript% /check /verify /capture %drive% \"%wimFilePath%\" \"OS\"\nexit %errorlevel%\ngoto:eof\n\n:InsertExclusionList\necho \"\\Program Files\\Opsware\">> %wimscript%\necho \"\\Program Files\\Common Files\\Opsware\">> %wimscript%\ngoto:eof\n\n", 
    "state": null, 
    "version": {
      "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool\n\nUsage: capture_windows_image.cmd path_to_wim_file captured_drive [path_to_wimscript.ini]\n\nScript takes 3 parameters (first 2 are mandatory):\n 1. path where .wim image file will be saved (path + .wim image name)\n 2. drive which will be captured\n 3. path to wimscript.ini file. If this parameter is not provided this script will generate a wimscript.ini file used to exclude SA Opsware Agent from new .wim image and it will extend an existing wimscript.ini file to do the same (exclude SA Opsware Agent)\n \nExample: capture_windows_image.cmd Z:\\media\\newWimFile.wim C: [Z:\\configs\\wimscript.ini]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:27.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "BAT", 
    "currentVersionChangedDate": "2014-03-10T21:37:27.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Windows .BAT", 
    "allVersions": [
      {
        "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool\n\nUsage: capture_windows_image.cmd path_to_wim_file captured_drive [path_to_wimscript.ini]\n\nScript takes 3 parameters (first 2 are mandatory):\n 1. path where .wim image file will be saved (path + .wim image name)\n 2. drive which will be captured\n 3. path to wimscript.ini file. If this parameter is not provided this script will generate a wimscript.ini file used to exclude SA Opsware Agent from new .wim image and it will extend an existing wimscript.ini file to do the same (exclude SA Opsware Agent)\n \nExample: capture_windows_image.cmd Z:\\media\\newWimFile.wim C: [Z:\\configs\\wimscript.ini]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:27.000Z"
      }
    ]
  }, 
  {
    "status": null, 
    "category": null, 
    "eTag": "2014-03-10T21:37:31.000Z", 
    "serverChanging": true, 
    "created": "2014-03-10T21:37:30.000Z", 
    "description": "Creates a stub ramdisk so we can load the Linux and initrd images from the network.\nThe ramdisk will not be able to expand.\n\nUsage:\n  -h, --help            show this help message and exit\n  -s SIZE, --size=SIZE  The size of the ramdisk to be created (measured in MB)\n  -m MOUNT_POINT, --mountPoint=MOUNT_POINT\n                        The path where the ramdisk will be mounted\n\nBy default the ramdisk will be mounted in \"/mnt/root\".\nBy default the ramdisk will be 1 GB in size.\n\nThis script expects no command line arguments.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
    "currentVersionChangedBy": "opsware", 
    "uri": "/rest/os-deployment-server-scripts/1170001", 
    "modified": "2014-03-10T21:37:31.000Z", 
    "name": "Create and Mount Ramdisk", 
    "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\nThis program will create a stub ramdisk (default 1 gB) and mount, default mount point /mnt/root\n\n(c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\"\"\"\nimport sys\n\nfrom osprov.osbp import logger\nfrom osprov.util import process\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.decorators import HandleShowErrorMessage\nfrom optparse import OptionValueError\nfrom osprov.errors import ShowErrorMessage\nfrom osprov import helpers\nfrom osprov.sysinfo import LinuxSysInfo\n\nLOG = logger.getIt(\"Create stub ramdisk\")\n\nEC_SUCCESS = 0\nEC_NOT_ENOUGH_MEMORY = 10\nEC_MOUNT_POINT_EXISTS = 183\n\n\nclass MemoryException(ShowErrorMessage):\n    DEFAULT_EC = EC_NOT_ENOUGH_MEMORY\n\n\nclass MountException(ShowErrorMessage):\n    DEFAULT_EC = EC_MOUNT_POINT_EXISTS\n\n\nclass CreateAndMountStubRamdiskStepOptionsParser(OptionParser):\n\n    \"\"\" An options' parser for this step. \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\n            \"-s\", \"--size\", type=\"int\", dest=\"size\", metavar=\"SIZE\", default=1024,\n            help=\"The size of the ramdisk to be created (measured in mB)\")\n        self.add_option(\n            \"-m\", \"--mountPoint\", type=\"string\", dest=\"mountPoint\", metavar=\"MOUNT_POINT\", default=\"/mnt/root\",\n            help=\"The path where the ramdisk will be mounted\")\n\n    def validateArgs(self, opt, args):\n        if args:\n            raise OptionValueError(\"Additional positional arguments are not supported\")\n        if opt.size < 1:\n            raise OptionValueError(\"Ramdisk size must be a positive, non zero integer\")\n\n\ndef checkMounts(mounts, mountPoint):\n    for key, values in mounts.items():\n        for mpoint in values:\n            if mountPoint in mpoint:\n                raise MountException(\n                    \"There is already a device (%s) mounted at %s\", (key, mountPoint))\n\n\ndef checkIfMounted(mountPoint):\n    checkMounts(LinuxSysInfo().mounts, mountPoint)\n\n\ndef createAndMountRamDisk(size, mountPoint):\n    \"\"\"\n            Creates a ramdisk of size \"size\" and mounts it at \"mountPoint\"\n    \"\"\"\n    freeRam = LinuxSysInfo.freeRamkB\n\n    if not freeRam > size * 1024:\n        raise MemoryException(\n            \"Not enough memory on system! Requested %i but only %i Mb available\" % (size, freeRam / 1024))\n    else:\n        checkIfMounted(mountPoint)\n\n    helpers.makeDirs(mountPoint)\n    process.runIt(\"mount -t tmpfs -o size=%sm tmpfs %s\" % (size, mountPoint), log=LOG)\n\n    # Save relevant information in the datastore\n    LOG.info(\"savind mount point: %s\" % mountPoint)\n    keys = helpers.getDataStore()\n    if keys.disk.device_mount == None:\n        keys.disk.device_mount = mountPoint\n        helpers.putDataStore(keys)\n\n\n@HandleShowErrorMessage(\"create stub ramdisk step\", LOG)\ndef main():\n    \"\"\"Main entry point when executed as a script from the command line\"\"\"\n    parser = CreateAndMountStubRamdiskStepOptionsParser()\n    options, args = parser.parse_args()\n\n    createAndMountRamDisk(options.size, options.mountPoint)\n\n    return EC_SUCCESS\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", 
    "state": null, 
    "version": {
      "usage": "Creates a stub ramdisk so we can load the Linux and initrd images from the network.\nThe ramdisk will not be able to expand.\n\nUsage:\n  -h, --help            show this help message and exit\n  -s SIZE, --size=SIZE  The size of the ramdisk to be created (measured in MB)\n  -m MOUNT_POINT, --mountPoint=MOUNT_POINT\n                        The path where the ramdisk will be mounted\n\nBy default the ramdisk will be mounted in \"/mnt/root\".\nBy default the ramdisk will be 1 GB in size.\n\nThis script expects no command line arguments.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
      "current": true, 
      "versionLabel": "1", 
      "createdBy": "opsware", 
      "createdDate": "2014-03-10T21:37:31.000Z"
    }, 
    "isCustomerContent": false, 
    "codeType": "PY2", 
    "currentVersionChangedDate": "2014-03-10T21:37:31.000Z", 
    "runAsSuperUser": true, 
    "displayCodeType": "Python", 
    "allVersions": [
      {
        "usage": "Creates a stub ramdisk so we can load the Linux and initrd images from the network.\nThe ramdisk will not be able to expand.\n\nUsage:\n  -h, --help            show this help message and exit\n  -s SIZE, --size=SIZE  The size of the ramdisk to be created (measured in MB)\n  -m MOUNT_POINT, --mountPoint=MOUNT_POINT\n                        The path where the ramdisk will be mounted\n\nBy default the ramdisk will be mounted in \"/mnt/root\".\nBy default the ramdisk will be 1 GB in size.\n\nThis script expects no command line arguments.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n\nThis script is intended to be used only as a Build Plan step.", 
        "current": true, 
        "versionLabel": "1", 
        "createdBy": "opsware", 
        "createdDate": "2014-03-10T21:37:31.000Z"
      }
    ]
  }
]